var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { createVNode, getCurrentInstance, defineComponent, toRefs, inject, computed, Fragment, mergeProps, resolveComponent, isVNode, ref, reactive, createTextVNode, provide, onMounted, watch, Transition, withDirectives, vShow, nextTick, onUnmounted, unref, withModifiers, Comment as Comment$1, Text, h, cloneVNode, Teleport, onBeforeUnmount, render, resolveDirective, resolveDynamicComponent, toRef, shallowRef, onUpdated, onBeforeMount, readonly, toRaw, watchEffect, renderSlot, useSlots, createApp, shallowReactive, effect, TransitionGroup } from "vue";
import { useRoute } from "vue-router";
import { offset, autoPlacement, arrow, shift, computePosition, flip } from "@floating-ui/dom";
import { onClickOutside, useResizeObserver } from "@vueuse/core";
const accordionProps = {
  data: {
    type: Array,
    default: null
  },
  titleKey: { type: String, default: "title" },
  loadingKey: { type: String, default: "loading" },
  childrenKey: { type: String, default: "children" },
  disabledKey: { type: String, default: "disabled" },
  activeKey: { type: String, default: "active" },
  openKey: { type: String, default: "open" },
  menuItemTemplate: { type: Boolean, default: true },
  itemTemplate: { type: Boolean, default: true },
  menuToggle: {
    type: Function,
    default: null
  },
  itemClick: {
    type: Function,
    default: null
  },
  activeItemChange: {
    type: Function,
    default: null
  },
  restrictOneOpen: { type: Boolean, default: false },
  autoOpenActiveMenu: { type: Boolean, default: false },
  showNoContent: { type: Boolean, default: true },
  noContentTemplate: { type: Boolean, default: true },
  loadingTemplate: { type: Boolean, default: true },
  innerListTemplate: { type: Boolean, default: true },
  linkType: {
    type: String,
    default: ""
  },
  linkTypeKey: { type: String, default: "linkType" },
  linkKey: { type: String, default: "link" },
  linkTargetKey: { type: String, default: "target" },
  linkDefaultTarget: { type: String, default: "_self" },
  accordionType: {
    type: String,
    default: "normal"
  }
};
const OpenIcon = () => {
  const svgProps = {
    width: "1em",
    height: "1em",
    viewBox: "0 0 16 16",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  return createVNode("svg", svgProps, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M12.1464466,6.85355339 L8.35355339,10.6464466 C8.15829124,10.8417088           7.84170876,10.8417088 7.64644661,10.6464466 L3.85355339,6.85355339 C3.65829124,6.65829124           3.65829124,6.34170876 3.85355339,6.14644661 C3.94732158,6.05267842 4.07449854,6 4.20710678,6           L11.7928932,6 C12.0690356,6 12.2928932,6.22385763 12.2928932,6.5 C12.2928932,6.63260824           12.2402148,6.7597852 12.1464466,6.85355339 Z",
    "fill-rule": "nonzero"
  }, null)])]);
};
const getRootSlots = () => {
  const rootComponentName = "DAccordion";
  const getRootComponent = (component) => {
    if (component && component.type.name === rootComponentName) {
      return component;
    }
    if (component && component.parent) {
      const parent = component.parent;
      return getRootComponent(parent);
    }
  };
  const rootComponent = getRootComponent(getCurrentInstance());
  return rootComponent == null ? void 0 : rootComponent.slots;
};
function createBem(namespace, element, modifier) {
  let cls = namespace;
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
}
function useNamespace(block, needDot = false) {
  const namespace = needDot ? `.b-${block}` : `b-${block}`;
  const b = () => createBem(namespace);
  const e = (element) => element ? createBem(namespace, element) : "";
  const m = (modifier) => modifier ? createBem(namespace, "", modifier) : "";
  const em = (element, modifier) => element && modifier ? createBem(namespace, element, modifier) : "";
  return {
    b,
    e,
    m,
    em
  };
}
var DAccordionMenu = defineComponent({
  name: "DAccordionMenu",
  components: {
    OpenIcon
  },
  props: __spreadValues({
    item: {
      type: Object,
      required: true
    },
    deepth: {
      type: Number,
      default: 0
    },
    parent: {
      type: Object,
      default: null
    }
  }, accordionProps),
  setup(props) {
    const {
      item,
      deepth,
      parent,
      openKey,
      activeKey,
      autoOpenActiveMenu,
      disabledKey,
      childrenKey,
      titleKey,
      menuItemTemplate
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const rootSlots = getRootSlots();
    const accordionCtx = inject("accordionContext");
    const parentValue = parent.value;
    const deepValue = deepth.value;
    const toggle = (itemEvent) => {
      accordionCtx == null ? void 0 : accordionCtx.menuToggleFn(itemEvent);
    };
    const hasChildActive = (arr) => {
      let flag = false;
      if (!arr.length) {
        return false;
      }
      for (let i = 0; i < arr.length; i++) {
        if (arr[i][activeKey.value] === true) {
          flag = true;
          break;
        }
        if (arr[i][childrenKey.value]) {
          flag = hasChildActive(arr[i][childrenKey.value]);
          if (flag) {
            break;
          }
        }
      }
      return flag;
    };
    const hasActiveChildren = (curItem) => {
      if (curItem[activeKey.value] === true) {
        return true;
      }
      if (curItem[childrenKey.value]) {
        return hasChildActive(curItem[childrenKey.value]);
      }
    };
    const keyOpen = computed(() => {
      return item.value && item.value[openKey.value];
    });
    const disabled = computed(() => {
      return item.value && item.value[disabledKey.value];
    });
    const title = computed(() => {
      return item.value && item.value[titleKey.value];
    });
    const children = computed(() => {
      return item.value && item.value[childrenKey.value];
    });
    const childActived = computed(() => {
      return hasActiveChildren(item.value);
    });
    const open2 = computed(() => {
      return keyOpen.value === void 0 && autoOpenActiveMenu.value ? childActived.value : keyOpen.value;
    });
    return () => {
      var _a;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("item-title"), ns2.m("overflow-ellipsis"), open2.value && ns2.m("open"), childActived.value && ns2.m("active"), disabled.value && ns2.m("disabled")],
        "title": title.value,
        "style": {
          textIndent: deepValue * 20 + "px"
        },
        "onClick": (e) => !disabled.value && toggle({
          item: item.value,
          open: !open2.value,
          parent: parentValue,
          event: e
        })
      }, [createVNode("div", {
        "class": [ns2.e("splitter"), deepValue === 0 && ns2.e("parent-list")],
        "style": {
          left: deepValue * 20 + 10 + "px"
        }
      }, null), (!(rootSlots == null ? void 0 : rootSlots.menuItemTemplate) || menuItemTemplate.value === false) && createVNode(Fragment, null, [title.value]), (rootSlots == null ? void 0 : rootSlots.menuItemTemplate) && menuItemTemplate.value !== false && ((_a = rootSlots.menuItemTemplate) == null ? void 0 : _a.call(rootSlots, {
        parent: parentValue,
        deepth: deepValue,
        item: item.value
      })), createVNode("span", {
        "class": ns2.e("open-icon")
      }, [createVNode(OpenIcon, null, null)])]), createVNode("div", {
        "class": [!open2.value && ns2.m("menu-hidden"), ns2.e("submenu"), ns2.m("show-animate")]
      }, [createVNode(AccordionList, mergeProps(props, {
        "deepth": deepValue + 1,
        "data": children.value || [],
        "parent": item.value
      }), null)])]);
    };
  }
});
var DAccordionItem = defineComponent({
  name: "DAccordionItem",
  props: __spreadValues({
    item: {
      type: Object,
      required: true
    },
    deepth: {
      type: Number,
      default: 0
    },
    parent: {
      type: Object,
      default: null
    }
  }, accordionProps),
  setup(props) {
    const {
      item,
      deepth,
      parent,
      titleKey,
      activeKey,
      disabledKey,
      itemTemplate
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const rootSlots = getRootSlots();
    const accordionCtx = inject("accordionContext");
    const parentValue = parent.value;
    const deepValue = deepth.value;
    const disabled = computed(() => {
      return item.value && item.value[disabledKey.value];
    });
    const title = computed(() => {
      return item.value && item.value[titleKey.value];
    });
    const active = computed(() => {
      return item.value && item.value[activeKey.value];
    });
    const childActived = computed(() => {
      return active.value;
    });
    const itemClick = (itemEvent) => {
      if (item.value && !disabled.value) {
        accordionCtx == null ? void 0 : accordionCtx.itemClickFn(itemEvent);
      }
    };
    return () => {
      var _a;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("item-title"), ns2.m("overflow-ellipsis"), childActived.value && ns2.m("active"), disabled.value && ns2.m("disabled")],
        "title": title.value,
        "style": {
          textIndent: deepValue * 20 + "px"
        },
        "onClick": (e) => itemClick({
          item: item.value,
          parent: parentValue,
          event: e
        })
      }, [createVNode("div", {
        "class": [ns2.e("splitter"), deepValue === 0 && ns2.e("parent-list")],
        "style": {
          left: deepValue * 20 + 10 + "px"
        }
      }, null), (!(rootSlots == null ? void 0 : rootSlots.itemTemplate) || itemTemplate.value === false) && createVNode(Fragment, null, [title.value]), (rootSlots == null ? void 0 : rootSlots.itemTemplate) && itemTemplate.value !== false && ((_a = rootSlots.itemTemplate) == null ? void 0 : _a.call(rootSlots, {
        parent: parentValue,
        deepth: deepValue,
        item: item.value
      }))])]);
    };
  }
});
var DAccordionItemHreflink = defineComponent({
  name: "DAccordionItemHreflink",
  component: {
    DAccordionItem
  },
  props: __spreadValues({
    item: {
      type: Object,
      required: true
    },
    deepth: {
      type: Number,
      default: 0
    },
    parent: {
      type: Object,
      default: null
    }
  }, accordionProps),
  setup(props) {
    const {
      item,
      deepth,
      parent,
      titleKey,
      linkKey,
      linkTargetKey,
      linkDefaultTarget,
      disabledKey,
      itemTemplate
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const rootSlots = getRootSlots();
    const accordionCtx = inject("accordionContext");
    const title = computed(() => {
      return item.value && item.value[titleKey.value];
    });
    const link = computed(() => {
      return item.value && item.value[linkKey.value];
    });
    const target = computed(() => {
      return item.value && (item.value[linkTargetKey.value] || linkDefaultTarget.value);
    });
    const disabled = computed(() => {
      return item.value && item.value[disabledKey.value];
    });
    const parentValue = parent.value;
    const deepValue = deepth.value;
    const linkItemClickFn = (itemEvent) => {
      if (item.value && !disabled.value) {
        accordionCtx == null ? void 0 : accordionCtx.itemClickFn(itemEvent);
      }
    };
    const renderContent = () => {
      var _a;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("splitter"), deepValue === 0 && ns2.e("parent-list")],
        "style": {
          left: deepValue * 20 + 10 + "px"
        }
      }, null), (!(rootSlots == null ? void 0 : rootSlots.itemTemplate) || itemTemplate.value === false) && createVNode(Fragment, null, [title.value]), (rootSlots == null ? void 0 : rootSlots.itemTemplate) && itemTemplate.value !== false && ((_a = rootSlots.itemTemplate) == null ? void 0 : _a.call(rootSlots, {
        parent: parentValue,
        deepth: deepValue,
        item: item.value
      }))]);
    };
    return () => {
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("item-title"), disabled.value && ns2.m("disabled")],
        "style": {
          textIndent: deepValue * 20 + "px"
        }
      }, [!disabled.value && createVNode("a", {
        "href": link.value,
        "target": target.value,
        "class": ns2.m("overflow-ellipsis"),
        "title": title.value,
        "onClick": (e) => linkItemClickFn({
          item: item.value,
          parent: parentValue,
          event: e
        })
      }, [renderContent()]), disabled.value && createVNode("a", {
        "class": ns2.m("overflow-ellipsis"),
        "title": title.value
      }, [renderContent()])])]);
    };
  }
});
function _isSlot$c(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var DAccordionItemRouterlink = defineComponent({
  name: "DAccordionItemRouterlink",
  component: {
    DAccordionItem
  },
  props: __spreadValues({
    item: {
      type: Object,
      required: true
    },
    deepth: {
      type: Number,
      default: 0
    },
    parent: {
      type: Object,
      default: null
    }
  }, accordionProps),
  setup(props) {
    const {
      item,
      deepth,
      parent,
      titleKey,
      linkKey,
      linkDefaultTarget,
      disabledKey,
      itemTemplate
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const route = useRoute();
    const rootSlots = getRootSlots();
    const accordionCtx = inject("accordionContext");
    const title = computed(() => {
      return item.value && item.value[titleKey.value];
    });
    const link = computed(() => {
      return item.value && item.value[linkKey.value];
    });
    const isUsedVueRouter = computed(() => route !== void 0);
    const routerLinkActive = computed(() => {
      return route === link.value;
    });
    const disabled = computed(() => {
      return item.value && item.value[disabledKey.value];
    });
    const parentValue = parent.value;
    const deepValue = deepth.value;
    const linkItemClickFn = (itemEvent) => {
      if (item.value && !disabled.value) {
        accordionCtx == null ? void 0 : accordionCtx.itemClickFn(itemEvent);
      }
    };
    const renderContent = () => {
      var _a;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("splitter"), deepValue === 0 && ns2.e("parent-list")],
        "style": {
          left: deepValue * 20 + 10 + "px"
        }
      }, null), (!(rootSlots == null ? void 0 : rootSlots.itemTemplate) || itemTemplate.value === false) && createVNode(Fragment, null, [title.value]), (rootSlots == null ? void 0 : rootSlots.itemTemplate) && itemTemplate.value !== false && ((_a = rootSlots.itemTemplate) == null ? void 0 : _a.call(rootSlots, {
        parent: parentValue,
        deepth: deepValue,
        item: item.value
      }))]);
    };
    return () => {
      let _slot;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [ns2.e("item-title"), disabled.value && ns2.m("disabled")],
        "style": {
          textIndent: deepValue * 20 + "px"
        }
      }, [!disabled.value && createVNode(Fragment, null, [isUsedVueRouter.value && createVNode(resolveComponent("router-link"), {
        "to": link.value,
        "class": [ns2.m("overflow-ellipsis"), routerLinkActive.value && ns2.m("router-active")],
        "custom": true,
        "title": title.value,
        "onClick": (e) => linkItemClickFn({
          item: item.value,
          parent: parentValue,
          event: e
        })
      }, _isSlot$c(_slot = renderContent()) ? _slot : {
        default: () => [_slot]
      }), !isUsedVueRouter.value && createVNode("a", {
        "href": link.value,
        "target": linkDefaultTarget.value,
        "class": ns2.m("overflow-ellipsis"),
        "title": title.value,
        "onClick": (e) => linkItemClickFn({
          item: item.value,
          parent: parentValue,
          event: e
        })
      }, [renderContent()])]), disabled.value && createVNode("a", {
        "class": ns2.m("overflow-ellipsis"),
        "title": title.value
      }, [renderContent()])])]);
    };
  }
});
function deepAssign(...objects) {
  const isObject2 = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, from) => {
    Object.keys(from).forEach((key) => {
      const pVal = prev[key];
      const oVal = from[key];
      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = Array.from(/* @__PURE__ */ new Set([...oVal, ...pVal]));
      } else if (isObject2(pVal) && isObject2(oVal)) {
        prev[key] = deepAssign(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}
var zhCN = {
  pagination: {
    totalItemText: "\u6240\u6709\u6761\u76EE",
    goToText: "\u8DF3\u81F3",
    perPage: "\u6761/\u9875"
  },
  accordion: {
    loading: "\u52A0\u8F7D\u4E2D",
    noData: "\u6CA1\u6709\u6570\u636E"
  },
  autoCompleteDropdown: {
    latestInput: "\u6700\u8FD1\u8F93\u5165"
  },
  cascaderList: {
    noData: "\u6CA1\u6709\u6570\u636E"
  },
  colorPicker: {
    foundationPanel: "\u57FA\u7840\u9762\u677F",
    advancedPanel: "\u9AD8\u7EA7\u9762\u677F"
  },
  datePickerPro: {
    ok: "\u786E\u5B9A",
    placeholder: "\u8BF7\u9009\u62E9\u65E5\u671F",
    month1: "1\u6708",
    month2: "2\u6708",
    month3: "3\u6708",
    month4: "4\u6708",
    month5: "5\u6708",
    month6: "6\u6708",
    month7: "7\u6708",
    month8: "8\u6708",
    month9: "9\u6708",
    month10: "10\u6708",
    month11: "11\u6708",
    month12: "12\u6708",
    year: "\u5E74",
    startPlaceholder: "\u8BF7\u9009\u62E9\u5F00\u59CB\u65E5\u671F",
    endPlaceholder: "\u8BF7\u9009\u62E9\u7ED3\u675F\u65E5\u671F",
    getWeekDays() {
      return ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"];
    },
    getTimeArr() {
      return ["\u65F6", "\u5206", "\u79D2"];
    },
    getYearMonthStr(year, month) {
      return `${year}\u5E74${month}\u6708`;
    }
  },
  editableSelect: {
    noRelatedRecords: "\u627E\u4E0D\u5230\u76F8\u5173\u8BB0\u5F55",
    noData: "\u6CA1\u6709\u6570\u636E"
  },
  input: {
    placeholder: "\u8BF7\u8F93\u5165"
  },
  splitterBar: {
    collapse: "\u6536\u8D77",
    expand: "\u5C55\u5F00"
  },
  stepsGuide: {
    previous: "\u4E0A\u4E00\u6B65",
    continue: "\u6211\u77E5\u9053\u5566\uFF0C\u7EE7\u7EED",
    ok: "\u6211\u77E5\u9053\u5566"
  },
  table: {
    selectAll: "\u5168\u9009",
    ok: "\u786E\u5B9A"
  },
  timePopup: {
    ok: "\u786E\u5B9A"
  },
  transfer: {
    unit: "\u9879",
    panelUnit: "\u9879",
    headerUnit: "\u9879",
    noData: "\u6682\u65E0\u6570\u636E",
    placeholder: "\u8BF7\u8F93\u5165\u5173\u952E\u8BCD\u641C\u7D22"
  },
  tree: {
    loading: "\u52A0\u8F7D\u4E2D",
    newNode: "\u65B0\u8282\u70B9",
    selectPlaceholder: "\u8BF7\u9009\u62E9"
  },
  upload: {
    placeholder: "\u9009\u62E9\u6587\u4EF6",
    getExistSameNameFilesMsg(sameNames) {
      return `\u60A8\u4E0A\u4F20\u7684 "${sameNames}" \u5B58\u5728\u91CD\u540D\u6587\u4EF6, \u8BF7\u91CD\u65B0\u9009\u62E9\u6587\u4EF6`;
    },
    getAllFilesBeyondMaximalFileSizeMsg(maximalSize) {
      return `\u6700\u5927\u652F\u6301\u4E0A\u4F20${maximalSize}MB\u7684\u6587\u4EF6, \u60A8\u672C\u6B21\u4E0A\u4F20\u7684\u6240\u6709\u6587\u4EF6\u8D85\u8FC7\u53EF\u4E0A\u4F20\u6587\u4EF6\u5927\u5C0F`;
    },
    getBeyondMaximalFileSizeMsg(filename, maximalSize) {
      return `\u6700\u5927\u652F\u6301\u4E0A\u4F20${maximalSize}MB\u7684\u6587\u4EF6, \u60A8\u4E0A\u4F20\u7684\u6587\u4EF6"${filename}"\u8D85\u8FC7\u53EF\u4E0A\u4F20\u6587\u4EF6\u5927\u5C0F`;
    },
    getNotAllowedFileTypeMsg(filename, scope) {
      return `\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B: "${scope}", \u60A8\u4E0A\u4F20\u7684\u6587\u4EF6"${filename}"\u4E0D\u5728\u5141\u8BB8\u8303\u56F4\u5185\uFF0C\u8BF7\u91CD\u65B0\u9009\u62E9\u6587\u4EF6`;
    }
  },
  search: {
    placeholder: "\u8BF7\u8F93\u5165\u5173\u952E\u5B57"
  },
  select: {
    placeholder: "\u8BF7\u9009\u62E9",
    noDataText: "\u65E0\u6570\u636E",
    noMatchText: "\u627E\u4E0D\u5230\u76F8\u5173\u8BB0\u5F55",
    loadingText: "\u52A0\u8F7D\u4E2D..."
  },
  tagInput: {
    maxTagsText: "\u5DF2\u8FBE\u5230\u6700\u5927\u4E2A\u6570\uFF1A"
  },
  timeSelect: {
    placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4"
  }
};
const lang = ref("zh-CN");
let langMessages = reactive({
  [lang.value]: zhCN
});
const Locale = {
  messages() {
    return langMessages[lang.value];
  },
  lang() {
    return lang.value;
  },
  use(newLang, newMessages2) {
    lang.value = newLang;
    this.add({ [newLang]: newMessages2 });
  },
  add(newMessages2 = {}) {
    langMessages = deepAssign(langMessages, newMessages2);
  }
};
const camelize = (name) => name.substring(1).replace(/^\S/, (s) => s.toLocaleLowerCase());
function get(object4, path) {
  const keys2 = path.split(".");
  let result2 = object4;
  keys2.forEach((key) => {
    var _a;
    result2 = (_a = result2[key]) != null ? _a : "";
  });
  return result2;
}
function createI18nTranslate(name, app, newPrefix) {
  const prefix = newPrefix || camelize(name) + ".";
  return (path) => {
    var _a;
    const messages2 = ((_a = app == null ? void 0 : app.appContext.config.globalProperties.langMessages) == null ? void 0 : _a.value) || Locale.messages();
    const message2 = get(messages2, prefix + path) || get(messages2, path);
    return message2;
  };
}
var AccordionList = defineComponent({
  name: "DAccordionList",
  components: {
    DAccordionMenu,
    DAccordionItem,
    DAccordionItemHreflink,
    DAccordionItemRouterlink
  },
  inheritAttrs: false,
  props: __spreadProps(__spreadValues({}, accordionProps), {
    data: {
      type: Array,
      default: null
    },
    deepth: {
      type: Number,
      default: 0
    },
    parent: {
      type: Object,
      default: null
    },
    innerListTemplate: Boolean
  }),
  setup(props, {
    attrs
  }) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DAccordion", app);
    const {
      childrenKey,
      deepth,
      parent,
      data,
      linkType,
      showNoContent,
      loadingKey,
      titleKey,
      linkTypeKey,
      loadingTemplate,
      noContentTemplate,
      innerListTemplate
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const deepValue = deepth.value;
    const rootSlots = getRootSlots();
    const accordionCtx = inject("accordionContext");
    const loading2 = computed(() => {
      return parent.value && parent.value[loadingKey.value];
    });
    const noContent = computed(() => {
      const dataValue = data.value;
      return dataValue === void 0 || dataValue === null || dataValue.length === 0;
    });
    return () => {
      var _a, _b, _c;
      return createVNode(Fragment, null, [(!(rootSlots == null ? void 0 : rootSlots.innerListTemplate) || deepth.value === 0 || innerListTemplate.value === false) && createVNode("ul", mergeProps({
        "class": [ns2.e("list")]
      }, attrs), [data.value.map((item) => {
        return createVNode("li", {
          "class": ns2.e("item"),
          "key": item[titleKey.value]
        }, [item[childrenKey.value] !== void 0 && createVNode("div", {
          "class": ns2.e("menu-item")
        }, [createVNode(resolveComponent("d-accordion-menu"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null)]), item[childrenKey.value] === void 0 && createVNode(Fragment, null, [(!linkType.value || linkType.value === "") && createVNode(resolveComponent("d-accordion-item"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null), linkType.value === "routerLink" && createVNode(resolveComponent("d-accordion-item-routerlink"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null), linkType.value === "hrefLink" && createVNode(resolveComponent("d-accordion-item-hreflink"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null), linkType.value === "dependOnLinkTypeKey" && createVNode(Fragment, null, [item[linkTypeKey.value] === "routerLink" && createVNode(resolveComponent("d-accordion-item-routerlink"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null), item[linkTypeKey.value] === "hrefLink" && createVNode(resolveComponent("d-accordion-item-hreflink"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null), item[linkTypeKey.value] !== "routerLink" && item[linkTypeKey.value] !== "hrefLink" && createVNode(resolveComponent("d-accordion-item"), mergeProps(props, {
          "item": item,
          "deepth": deepValue,
          "parent": parent.value
        }), null)])])]);
      })]), (rootSlots == null ? void 0 : rootSlots.innerListTemplate) && innerListTemplate.value !== false && deepValue !== 0 && ((_a = rootSlots.innerListTemplate) == null ? void 0 : _a.call(rootSlots, {
        item: parent.value,
        deepth: deepValue,
        itemClickFn: accordionCtx == null ? void 0 : accordionCtx.itemClickFn,
        menuToggleFn: accordionCtx == null ? void 0 : accordionCtx.menuToggleFn
      })), (!(rootSlots == null ? void 0 : rootSlots.innerListTemplate) || innerListTemplate.value === false) && (loading2.value || noContent.value && showNoContent.value) && createVNode("ul", mergeProps({
        "class": [ns2.e("list")]
      }, attrs), [
        loading2.value && (!(rootSlots == null ? void 0 : rootSlots.loadingTemplate) || loadingTemplate.value === false) && createVNode("li", {
          "class": ns2.e("item")
        }, [createVNode("div", {
          "class": [ns2.e("item-title"), ns2.m("overflow-ellipsis")],
          "style": {
            textIndent: deepValue * 20 + "px"
          }
        }, [t("loading"), createTextVNode("...")])]),
        loading2.value && (rootSlots == null ? void 0 : rootSlots.loadingTemplate) && loadingTemplate.value !== false && ((_b = rootSlots.loadingTemplate) == null ? void 0 : _b.call(rootSlots, {
          item: parent.value,
          deepth: deepValue
        })),
        showNoContent.value && !loading2.value && noContent.value && (!(rootSlots == null ? void 0 : rootSlots.noContentTemplate) || noContentTemplate.value === false) && createVNode("li", {
          "class": ns2.e("item")
        }, [createVNode("div", {
          "class": [ns2.e("item-title"), ns2.m("overflow-ellipsis"), ns2.m("disabled")],
          "style": {
            textIndent: deepValue * 20 + "px"
          }
        }, [t("noData")])]),
        showNoContent.value && !loading2.value && noContent.value && (rootSlots == null ? void 0 : rootSlots.noContentTemplate) && noContentTemplate.value !== false && ((_c = rootSlots.noContentTemplate) == null ? void 0 : _c.call(rootSlots, {
          item: parent.value,
          deepth: deepValue
        }))
      ])]);
    };
  }
});
var accordion = "";
var Accordion = defineComponent({
  name: "DAccordion",
  props: accordionProps,
  setup(props, {
    emit
  }) {
    const {
      data,
      childrenKey,
      activeKey,
      openKey,
      accordionType,
      autoOpenActiveMenu,
      restrictOneOpen
    } = toRefs(props);
    const ns2 = useNamespace("accordion");
    const scrollbarNs = useNamespace("scrollbar");
    let clickActiveItem = void 0;
    const flatten = (arr, curChildrenKey = "children", includeParent = false, includeLeaf = true) => {
      return arr.reduce((acc, cur) => {
        const children = cur[curChildrenKey];
        if (children === void 0) {
          if (includeLeaf) {
            acc.push(cur);
          }
        } else {
          if (includeParent) {
            acc.push(cur);
          }
          if (Array.isArray(children)) {
            acc.push(...flatten(children, curChildrenKey, includeParent));
          }
        }
        return acc;
      }, []);
    };
    const activeItemFn = (item) => {
      if (clickActiveItem && clickActiveItem[activeKey.value]) {
        clickActiveItem[activeKey.value] = false;
      }
      item[activeKey.value] = true;
      clickActiveItem = item;
      emit("activeItemChange", clickActiveItem);
    };
    const initActiveItem = () => {
      const activeItem = flatten(data.value, childrenKey.value).filter((item) => item[activeKey.value]).pop();
      if (activeItem) {
        if (!clickActiveItem) {
          activeItemFn(activeItem);
        }
      } else {
        clickActiveItem = void 0;
      }
    };
    const openMenuFn = (item, open2) => {
      if (open2 && restrictOneOpen.value) {
        data.value.forEach((itemtemp) => {
          itemtemp[openKey.value] = false;
        });
      }
      item[openKey.value] = open2;
    };
    const itemClickFn = (itemEvent) => {
      const prevActiveItem = clickActiveItem;
      activeItemFn(itemEvent.item);
      emit("itemClick", __spreadProps(__spreadValues({}, itemEvent), {
        prevActiveItem
      }));
    };
    const linkItemClickFn = (itemEvent) => {
      const prevActiveItem = clickActiveItem;
      clickActiveItem = itemEvent.item;
      emit("linkItemClick", __spreadProps(__spreadValues({}, itemEvent), {
        prevActiveItem
      }));
    };
    const menuToggleFn = (menuEvent) => {
      openMenuFn(menuEvent.item, menuEvent.open);
      emit("menuToggle", menuEvent);
    };
    const cleanOpenData = () => {
      flatten(data.value, childrenKey.value, true, false).forEach((item) => item[openKey.value] = void 0);
    };
    provide("accordionContext", {
      itemClickFn,
      linkItemClickFn,
      menuToggleFn
    });
    onMounted(() => {
      if (data.value) {
        initActiveItem();
      }
    });
    watch(() => autoOpenActiveMenu.value, (current, preV) => {
      if (current && preV === false) {
        cleanOpenData();
      }
    });
    watch(data.value, () => {
      initActiveItem();
    }, {
      deep: true
    });
    return () => {
      return createVNode("div", {
        "class": [ns2.e("menu"), ns2.m("show-animate"), scrollbarNs.b(), accordionType.value === "normal" && ns2.m("menu-normal")]
      }, [createVNode(AccordionList, mergeProps(props, {
        "data": data.value,
        "deepth": 0,
        "parent": void 0
      }), null)]);
    };
  }
});
var AccordionInstall = {
  title: "Accordion \u624B\u98CE\u7434",
  category: "\u5BFC\u822A",
  status: "10%",
  deprecated: {
    value: true,
    reason: "Accordion \u662F Menu \u7EC4\u4EF6\u7684\u4E00\u79CD\u7279\u6027\u5F62\u6001(\u5782\u76F4\u65B9\u5411\u4E0A\u7684\u83DC\u5355)\uFF0C\u5E94\u8BE5\u4F7F\u7528\u66F4\u901A\u7528\u7684 Menu \u66FF\u4EE3\u3002"
  },
  install(app) {
    app.component(Accordion.name, Accordion);
  }
};
const AlertCloseIcon = () => createVNode("svg", {
  "width": "10px",
  "height": "10px",
  "viewBox": "0 0 10 10",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("g", {
  "transform": "translate(-3.000000, -3.000000)",
  "fill-rule": "nonzero"
}, [createVNode("path", {
  "d": "M11.6426,3.19816936 C11.9239974,2.91574512 12.4131626,2.93784891         12.7352108,3.24751057 C13.0571998,3.5572302 13.0901298,4.03723416         12.8087324,4.31965839 L9.14064666,7.99900183 L12.8087324,11.6803416         C13.0645482,11.9370909 13.0605893,12.3571292 12.8158402,12.6640749         L12.7352108,12.7524894 C12.4131626,13.0621511 11.9239974,13.0842548         11.6426,12.8018306 L8,9.14489021 L4.35740003,12.8018306 C4.10158422,13.05858         3.6740594,13.0636532 3.35648225,12.8298003 L3.26478919,12.7524894         C2.94280021,12.4427698 2.90987023,11.9627658 3.19126762,11.6803416         L6.8583349,7.99900183 L3.19126762,4.31965839 C2.93545181,4.06290908         2.93941068,3.64287076 3.18415975,3.3359251 L3.26478919,3.24751057         C3.58683735,2.93784891 4.07600264,2.91574512 4.35740003,3.19816936         L8,6.85411161 L11.6426,3.19816936 Z"
}, null)])])]);
const ns$k = useNamespace("alert");
const AlertTypeIcon = (props) => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg",
  "class": [ns$k.e("icon"), props.type === "danger" ? ns$k.em("icon", "error") : ns$k.em("icon", props.type)]
}, [(() => {
  switch (props.type) {
    case "success":
      return createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("path", {
        "fill-rule": "nonzero",
        "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16 C12.4,16 16,12.4 16,8 C16,3.6 12.4,0 8,0 Z"
      }, null), createVNode("polygon", {
        "stroke-width": "0.3",
        "fill-rule": "nonzero",
        "points": "6.82767602 11.5282799 3 7.24668779 3.89864233 6.37912367 6.82767602 9.04910002 12.2964408 4 13 4.64144383"
      }, null)]);
    case "warning":
      return createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("path", {
        "class": "warning-outer",
        "d": "M8.96244623,0.57254229 L15.8714442,13.4101975 C16.1549662,13.9370117               15.9538562,14.5918482 15.4222523,14.8728158 C15.2642579,14.9563203 15.0879506,15               14.9088903,15 L1.09089441,15 C0.488410063,15 0,14.5159904 0,13.9189343 C0,13.7414873               0.0440768395,13.5667684 0.128340519,13.4101975 L7.03733844,0.57254229               C7.32086049,0.0457280838 7.98165058,-0.153569987 8.51325441,0.127397589               C8.70423071,0.228333932 8.8605922,0.383286648 8.96244623,0.57254229 Z"
      }, null), createVNode("path", {
        "class": "warning-inner",
        "stroke-width": "0.3",
        "fill-rule": "nonzero",
        "d": "M8.87894737,13 L7.08947368,13 L7.08947368,11.2105263 L8.87894737,11.2105263               L8.87894737,13 Z M8.62102372,9.86842105 L7.32800539,9.86842105 L7,4.5               L8.96842105,4.5 L8.62102372,9.86842105 Z"
      }, null)]);
    case "info":
      return createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "fill-rule": "nonzero"
      }, [createVNode("path", {
        "class": "info-outer",
        "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16 C12.4,16 16,12.4 16,8 C16,3.6 12.4,0 8,0 Z"
      }, null), createVNode("path", {
        "class": "info-inner",
        "d": "M9.19008504,7 L8.79402696,13 L7.15622605,13 L6.73158434,7 L9.19008504,7 Z M9,3 L9,5 L7,5 L7,3 L9,3 Z",
        "stroke-width": "0.2"
      }, null)])]);
    case "danger":
      return createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "fill-rule": "nonzero"
      }, [createVNode("path", {
        "class": "error-outer",
        "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16 C12.4,16 16,12.4 16,8 C16,3.6 12.4,0 8,0 Z"
      }, null), createVNode("path", {
        "class": "error-inner",
        "d": "M9,10.6 L9,12.6 L7,12.6 L7,10.6 L9,10.6 Z M9.1,3.1 L8.65924344,9.1 L7.28422786,9.1 L6.9,3.1 L9.1,3.1 Z",
        "stroke-width": "0.2"
      }, null)])]);
    default:
      return null;
  }
})()]);
const alertProps = {
  type: {
    type: String,
    default: "info"
  },
  cssClass: {
    type: String,
    default: ""
  },
  closeable: {
    type: Boolean,
    default: true
  },
  showIcon: {
    type: Boolean,
    default: true
  },
  dismissTime: {
    type: Number,
    default: 0
  },
  center: {
    type: Boolean,
    default: false
  }
};
var alert = "";
var Alert = defineComponent({
  name: "DAlert",
  props: alertProps,
  emits: ["close"],
  setup(props, ctx2) {
    const ns2 = useNamespace("alert");
    const hide = ref(false);
    const closing = ref(false);
    const alertEl = ref();
    let dismissTimer = void 0;
    const close2 = (event) => {
      dismissTimer && clearTimeout(dismissTimer);
      closing.value = true;
      ctx2.emit("close", event);
    };
    const afterLeave = () => {
      dismissTimer = void 0;
      hide.value = true;
      closing.value = false;
    };
    onMounted(() => {
      if (props.dismissTime) {
        dismissTimer = window.setTimeout(() => {
          close2();
        }, props.dismissTime);
      }
    });
    return () => {
      return !hide.value ? createVNode(Transition, {
        "name": ns2.b(),
        "onAfterLeave": afterLeave
      }, {
        default: () => {
          var _a, _b;
          return [withDirectives(createVNode("div", {
            "ref": alertEl,
            "class": [ns2.b(), ns2.m(props.type), props.cssClass, closing.value && ns2.m("close"), props.center && ns2.m("center")]
          }, [props.showIcon !== false && props.type !== "simple" ? createVNode("span", {
            "class": ns2.e("icon-wrap")
          }, [createVNode(AlertTypeIcon, {
            "type": props.type
          }, null)]) : null, createVNode("div", {
            "class": ns2.e("content")
          }, [createVNode("span", null, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]), props.closeable ? createVNode("div", {
            "class": ns2.e("close-icon"),
            "onClick": close2
          }, [createVNode(AlertCloseIcon, null, null)]) : null])]), [[vShow, !closing.value]])];
        }
      }) : null;
    };
  }
});
var AlertInstall = {
  title: "Alert \u8B66\u544A",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Alert.name, Alert);
  }
};
var Anchor = defineComponent({
  name: "DAnchor",
  props: {},
  setup() {
    return () => {
      return createVNode("div", null, [createTextVNode(" ")]);
    };
  }
});
let repeatCount = 0;
let cTimeout;
const timeoutIntervalSpeed = 10;
let hashName;
let scollFlag = false;
let activeLink = null;
let rootActiveLink = null;
let rootClassName = "";
function elementPosition(obj) {
  let curleft = 0, curtop = 0;
  curleft = obj.offsetLeft;
  curtop = obj.offsetTop;
  return { x: curleft, y: curtop };
}
function getSidebarLinks(curRootClassName) {
  return [].slice.call(document.querySelectorAll(`.${curRootClassName} > .step-nav > li.bar-link-item > a`));
}
function getAnchors(sidebarLinks) {
  return [].slice.call(document.querySelectorAll(".box-anchor")).filter((anchor2) => sidebarLinks.some((sidebarLink) => sidebarLink.hash === anchor2.hash));
}
function throttleAndDebounce(fn, delay) {
  let timeout;
  let called = false;
  return () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    if (!called) {
      fn();
      called = true;
      setTimeout(() => {
        called = false;
      }, delay);
    } else {
      timeout = setTimeout(fn, delay);
    }
  };
}
function deactiveLink(link) {
  link && link.classList.remove("active");
}
function hightLightFn(curHashName) {
  var _a;
  const childLength = document.getElementsByClassName("mysidebar")[0].children.length;
  for (let i = 0; i < childLength; i++) {
    if (document.getElementsByClassName("mysidebar")[0].children[i].classList.value.indexOf("active") > -1) {
      document.getElementsByClassName("mysidebar")[0].children[i].classList.remove("active");
    }
  }
  if (curHashName) {
    (_a = document.getElementById(curHashName)) == null ? void 0 : _a.classList.add("active");
  }
}
function activateLink(hash) {
  deactiveLink(activeLink);
  deactiveLink(rootActiveLink);
  hash ? activeLink = document.querySelector(`${hash}`) : activeLink = document.querySelector(`.${rootClassName} ul li`);
  if (!activeLink) {
    return;
  }
  if (!scollFlag) {
    hash && hightLightFn(hash.split("#")[1]);
  } else {
    hightLightFn(hashName);
  }
  const rootLi = activeLink.closest(".mycontainer > ul > li");
  if (rootLi && rootLi !== activeLink.parentElement) {
    rootActiveLink = rootLi;
    rootActiveLink && rootActiveLink.classList.add("active");
  } else {
    rootActiveLink = null;
  }
}
function getPageOffset() {
  return document.querySelector(".mysidebar ").getBoundingClientRect().y;
}
function getAnchorTop(anchor2) {
  var _a;
  const pageOffset = getPageOffset();
  return ((_a = anchor2.parentElement) == null ? void 0 : _a.offsetTop) - pageOffset - 5;
}
function isAnchorActive(index2, anchor2, nextAnchor) {
  let scrollTop;
  document.getElementsByClassName("scrollTarget").length ? scrollTop = document.getElementsByClassName("scrollTarget")[0].scrollTop : scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  if (index2 === 0 && scrollTop === 0) {
    return [true, null];
  }
  if (scrollTop < getAnchorTop(anchor2)) {
    return [false, null];
  }
  if (!nextAnchor || scrollTop < getAnchorTop(nextAnchor)) {
    return [true, decodeURIComponent(anchor2.hash)];
  }
  return [false, null];
}
function scrollSmoothly(scrollPos, repeatTimes, container) {
  if (repeatCount <= repeatTimes) {
    scrollPos > 0 ? container.scrollBy(0, timeoutIntervalSpeed) : container.scrollBy(0, -timeoutIntervalSpeed);
  } else {
    repeatCount = 0;
    clearTimeout(cTimeout);
    history.replaceState(null, "", document.location.pathname + "#" + hashName);
    hightLightFn(hashName);
    setTimeout(() => {
      scollFlag = false;
    }, 310);
    return;
  }
  repeatCount++;
  cTimeout = setTimeout(() => {
    scrollSmoothly(scrollPos, repeatTimes, container);
  }, 10);
}
function scrollToControl(elem, container) {
  hashName = elem.getAttribute("name");
  scollFlag = true;
  const tops = container.scrollTop >= 0 ? container.scrollTop : -document.getElementsByClassName("mycontainer")[0].offsetTop;
  let scrollPos = elementPosition(elem).y - tops;
  scrollPos = scrollPos - document.documentElement.scrollTop;
  const remainder = scrollPos % timeoutIntervalSpeed;
  const repeatTimes = Math.abs((scrollPos - remainder) / timeoutIntervalSpeed);
  if (scrollPos < 0 && container || elem.getBoundingClientRect().top < container.offsetTop) {
    window.scrollBy(0, elem.getBoundingClientRect().top - container.offsetTop - 16);
  }
  scrollSmoothly(scrollPos, repeatTimes, container);
}
const setActiveLink = (timeId) => {
  if (scollFlag) {
    return;
  }
  timeId ? rootClassName = timeId : rootClassName = document.getElementsByClassName("mymain")[0].id;
  const sidebarLinks = getSidebarLinks(rootClassName);
  const anchors = getAnchors(sidebarLinks);
  try {
    anchors.forEach((index2, i) => {
      const anchor2 = anchors[i];
      const nextAnchor = anchors[i + 1];
      const [isActive, hash] = isAnchorActive(i, anchor2, nextAnchor);
      if (isActive) {
        history.replaceState(null, document.title, hash ? hash : " ");
        activateLink(hash);
        throw Error(hash + "");
      }
    });
  } catch (e) {
  }
};
const onScroll = throttleAndDebounce(setActiveLink, 300);
function hasClass(el, className2) {
  if (el.classList) {
    return el.classList.contains(className2);
  }
  const originClass = el.className;
  return ` ${originClass} `.indexOf(` ${className2} `) > -1;
}
function addClass(el, className2) {
  if (el.classList) {
    el.classList.add(className2);
  } else {
    if (!hasClass(el, className2)) {
      el.className = `${el.className} ${className2}`;
    }
  }
}
function removeClass(el, className2) {
  if (el.classList) {
    el.classList.remove(className2);
  } else {
    if (hasClass(el, className2)) {
      const originClass = el.className;
      el.className = ` ${originClass} `.replace(` ${className2} `, " ");
    }
  }
}
const inBrowser = typeof window !== "undefined";
function getElement(element) {
  if (element instanceof Element) {
    return element;
  }
  if (element && typeof element === "object" && element.$el instanceof Element) {
    return element.$el;
  }
  return null;
}
function lockScroll() {
  if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
    const scrollTop = document.documentElement.scrollTop;
    const style = document.documentElement.getAttribute("style");
    document.documentElement.style.position = "fixed";
    document.documentElement.style.top = `-${scrollTop}px`;
    document.documentElement.style.width = document.documentElement.style.width || "100%";
    document.documentElement.style.overflowY = "scroll";
    return () => {
      if (style) {
        document.documentElement.setAttribute("style", style);
      } else {
        document.documentElement.removeAttribute("style");
      }
      document.documentElement.scrollTop = scrollTop;
    };
  }
  return;
}
function getPropsSlot(slots, props, prop = "default") {
  var _a, _b;
  return (_b = props[prop]) != null ? _b : (_a = slots[prop]) == null ? void 0 : _a.call(slots);
}
function randomId(n = 8) {
  const str = "abcdefghijklmnopqrstuvwxyz0123456789";
  let result2 = "";
  for (let i = 0; i < n; i++) {
    result2 += str[parseInt((Math.random() * str.length).toString())];
  }
  return result2;
}
function setStyle(element, style) {
  const oldStyle = {};
  const styleKeys = Object.keys(style);
  styleKeys.forEach((key) => {
    oldStyle[key] = element.style[key];
  });
  styleKeys.forEach((key) => {
    element.style[key] = style[key];
  });
  return oldStyle;
}
function middleNum(num, min = 0, max = 100) {
  let middle = 0;
  middle = Math.min(num, max);
  middle = Math.max(middle, min);
  return middle;
}
const isNumber = (value) => typeof value === "number";
const isBoolean = (value) => typeof value === "boolean";
const isString$2 = (value) => typeof value === "string";
const isFunction$3 = (value) => Object.prototype.toString.call(value) === "[object Function]";
const isUndefined = (value) => value === void 0;
const isHTMLElement = (value) => inBrowser && "HTMLElement" in window && value instanceof HTMLElement;
function omit(obj, fields) {
  const shallowCopy = Object.assign({}, obj);
  for (let i = 0; i < fields.length; i += 1) {
    const key = fields[i];
    delete shallowCopy[key];
  }
  return shallowCopy;
}
const cssChange = (mysidebar, postion, top, left) => {
  mysidebar.style.position = postion;
  mysidebar.style.top = top + "px";
  mysidebar.style.left = left + "px";
};
const addEvent = function() {
  if (inBrowser && "addEventListener" in window) {
    return function(elm, type4, handle) {
      elm.addEventListener(type4, handle, false);
    };
  }
}();
var dAnchorBox = {
  name: "DAnchorBox",
  mounted(el) {
    const timeId = "m" + randomId(8);
    el.id = timeId;
    const classList = el.classList;
    classList.add("mycontainer", "mymain", timeId);
    let windoScrollTop;
    const div = document.querySelector(`#${timeId}`);
    const mysidebar = document.querySelector(`#${timeId} .mysidebar`);
    const mysidebarHeight = mysidebar.clientHeight;
    window.addEventListener("resize", () => {
      cssChange(mysidebar, "absolute", 0, 0);
    });
    window.onscroll = function() {
      windoScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      if (!document.getElementsByClassName("scrollTarget").length) {
        if (windoScrollTop + mysidebarHeight - 16 >= div.offsetTop + div.clientHeight) {
          cssChange(mysidebar, "absolute", div.clientHeight - mysidebarHeight - 8, 0);
        } else if (windoScrollTop > div.offsetTop) {
          cssChange(mysidebar, "fixed", div.offsetTop, div.getBoundingClientRect().left);
        } else if (div.offsetTop >= windoScrollTop && windoScrollTop >= 0) {
          cssChange(mysidebar, "absolute", 0, 0);
        } else {
          cssChange(mysidebar, "absolute", div.clientHeight - mysidebarHeight - 8, 0);
        }
      } else {
        cssChange(mysidebar, "absolute", div.scrollTop, 0);
      }
    };
    addEvent == null ? void 0 : addEvent(div, "scroll", function() {
      if (document.getElementsByClassName("scrollTarget").length) {
        cssChange(mysidebar, "fixed", div.getBoundingClientRect().top, div.getBoundingClientRect().left);
      }
    });
    setActiveLink(timeId);
    document.getElementsByClassName("scrollTarget").length ? addEvent == null ? void 0 : addEvent(div, "scroll", onScroll) : window.addEventListener("scroll", onScroll);
  }
};
var dAnchorLink = {
  name: "DAnchorLink",
  mounted(el, binding) {
    const parent = el.parentNode;
    if (!parent.className) {
      parent.className = "mysidebar step-nav";
    }
    el.className = "bar-link-item";
    el.innerHTML += '<a class="d-d-anchor" style="display:none" href="#' + binding.value + '">?</a>';
    el.setAttribute("id", binding.value);
    el.onclick = () => {
      let scrollContainer;
      const scollToDomY = document.getElementsByName(binding.value)[0];
      document.getElementsByClassName("scrollTarget").length ? scrollContainer = document.getElementsByClassName("scrollTarget")[0] : scrollContainer = window;
      scrollToControl(scollToDomY, scrollContainer);
    };
  }
};
var dAnchor = {
  name: "DAnchor",
  mounted(el, binding) {
    const parent = el.parentNode;
    if (!parent.className) {
      parent.className = "mycontent";
    }
    el.innerHTML = '<a class="box-anchor" style="display:none" href="#' + binding.value + '">?</a>' + el.innerHTML;
    el.className = "section-block";
    el.setAttribute("name", binding.value);
    el.onclick = () => {
      hightLightFn(binding.value);
    };
  }
};
var anchor = "";
var AnchorInstall = {
  title: "Anchor \u951A\u70B9",
  category: "\u5BFC\u822A",
  status: "50%",
  install(app) {
    app.directive(dAnchor.name, dAnchor);
    app.directive(dAnchorLink.name, dAnchorLink);
    app.directive(dAnchorBox.name, dAnchorBox);
    app.component(Anchor.name, Anchor);
  }
};
const defaultFormatter = (item) => {
  if (typeof item === "string") {
    return item;
  }
  return item !== null ? item.label || item.toString() : "";
};
const defaultValueParse = (item) => item;
const autoCompleteProps = {
  modelValue: {
    type: String,
    default: ""
  },
  source: {
    type: Array,
    default: null
  },
  allowEmptyValueSearch: {
    type: Boolean,
    default: false
  },
  appendToBody: {
    type: Boolean,
    default: false
  },
  position: {
    type: Array,
    default: ["bottom-end"]
  },
  disabled: {
    type: Boolean,
    default: false
  },
  delay: {
    type: Number,
    default: 300
  },
  disabledKey: {
    type: String,
    default: null
  },
  formatter: {
    type: Function,
    default: defaultFormatter
  },
  isSearching: {
    type: Boolean,
    default: false
  },
  sceneType: {
    type: String,
    default: null
  },
  searchFn: {
    type: Function,
    default: null
  },
  tipsText: {
    type: String,
    default: "\u6700\u8FD1\u8F93\u5165"
  },
  latestSource: {
    type: Array,
    default: null
  },
  valueParser: {
    type: Function,
    default: defaultValueParse
  },
  enableLazyLoad: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 400
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  maxHeight: {
    type: Number,
    default: 300
  },
  transInputFocusEmit: {
    type: Function,
    default: null
  },
  selectValue: {
    type: Function,
    default: null
  },
  loadMore: {
    type: Function,
    default: null
  },
  placeholder: {
    type: String,
    default: "Search"
  },
  prefix: {
    type: String,
    default: ""
  },
  suffix: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: "md"
  },
  clearable: {
    type: Boolean,
    default: false
  }
};
const DropdownPropsKey = Symbol("DropdownPropsKey");
function useCustomTemplate(ctx2, modelValue) {
  const itemTemplate = (item, index2) => {
    const arr = { item, index: index2 };
    if (ctx2.slots.item) {
      return ctx2.slots.item(arr);
    }
    return null;
  };
  const noResultItemTemplate = () => {
    if (ctx2.slots.nothing) {
      return ctx2.slots.nothing(modelValue.value);
    }
    return null;
  };
  const searchingTemplate = () => {
    if (ctx2.slots.searching) {
      return ctx2.slots.searching(modelValue.value);
    }
    return null;
  };
  const customRenderSolts = () => {
    const slots = {};
    if (ctx2.slots.item) {
      slots["itemTemplate"] = itemTemplate;
    }
    if (ctx2.slots.nothing) {
      slots["noResultItemTemplate"] = noResultItemTemplate;
    }
    if (ctx2.slots.searching) {
      slots["searchingTemplate"] = searchingTemplate;
    }
    return slots;
  };
  return { customRenderSolts };
}
function useSearchFn(ctx2, allowEmptyValueSearch, source, searchFn, formatter) {
  const searchList = ref([]);
  const showNoResultItemTemplate = ref(false);
  const defaultSearchFn = (term) => {
    const arr = [];
    source.value.forEach((item) => {
      let cur = formatter.value(item);
      cur = cur.toLowerCase();
      if (cur.startsWith(term)) {
        arr.push(item);
      }
    });
    return arr;
  };
  const handleSearch = async (term, enableLazyLoad = false) => {
    if (term === "" && !allowEmptyValueSearch.value) {
      searchList.value = [];
      showNoResultItemTemplate.value = false;
      return;
    }
    let arr = [];
    term = term.toLowerCase();
    if (enableLazyLoad) {
      arr = source.value;
    } else if (!searchFn.value) {
      arr = defaultSearchFn(term);
    } else {
      arr = await searchFn.value(term);
    }
    searchList.value = arr;
    if (searchList.value.length === 0) {
      showNoResultItemTemplate.value = true;
    } else {
      showNoResultItemTemplate.value = false;
    }
  };
  const recentlyFocus = (latestSource) => {
    if (latestSource) {
      searchList.value = latestSource;
    }
  };
  return {
    handleSearch,
    recentlyFocus,
    searchList,
    showNoResultItemTemplate
  };
}
function useInputHandle(ctx2, searchList, showNoResultItemTemplate, modelValue, isDisabled, delay, handleSearch, transInputFocusEmit, recentlyFocus, latestSource) {
  const visible = ref(false);
  const inputRef = ref();
  const searchStatus = ref(false);
  const isFocus = ref(false);
  const debounce = (cb, time) => {
    let timer;
    return (arg) => {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(async () => {
        searchStatus.value = true;
        await cb(arg);
        searchStatus.value = false;
      }, time);
    };
  };
  const onInputCb = async (value) => {
    await handleSearch(value);
    visible.value = true;
  };
  const onInputDebounce = debounce(onInputCb, delay.value);
  const onInput = (e) => {
    const inp = e.target;
    searchStatus.value = false;
    showNoResultItemTemplate.value = false;
    ctx2.emit("update:modelValue", inp.value);
    onInputDebounce(inp.value);
  };
  const onFocus = () => {
    isFocus.value = true;
    handleSearch(modelValue.value);
    recentlyFocus(latestSource == null ? void 0 : latestSource.value);
    transInputFocusEmit.value && transInputFocusEmit.value();
  };
  const onBlur = () => {
    isFocus.value = false;
    ctx2.emit("blur");
  };
  const onClear = () => {
    ctx2.emit("update:modelValue", "");
    ctx2.emit("clear");
  };
  const handleClose = () => {
    visible.value = false;
    searchStatus.value = false;
    showNoResultItemTemplate.value = false;
  };
  const toggleMenu = () => {
    if (!isDisabled.value) {
      if (visible.value) {
        handleClose();
      } else {
        visible.value = true;
        if (ctx2.slots.noResultItemTemplate && searchList.value.length === 0 && modelValue.value.trim() !== "") {
          showNoResultItemTemplate.value = true;
        }
      }
    }
  };
  return {
    handleClose,
    toggleMenu,
    onInput,
    onFocus,
    onBlur,
    onClear,
    isFocus,
    inputRef,
    visible,
    searchStatus
  };
}
function useSelectHandle(ctx2, searchList, selectValue, handleSearch, formatter, handleClose) {
  const selectedIndex = ref(0);
  const getListIndex = (cur) => {
    if (searchList.value.length === 0) {
      return 0;
    }
    let ind = 0;
    searchList.value.forEach((item, index2) => {
      if (typeof item === "string") {
        if (item === cur) {
          ind = index2;
        }
      } else {
        if (String(item.label) === cur) {
          ind = index2;
        }
      }
    });
    return ind === -1 ? 0 : ind;
  };
  const selectOptionClick = async (item) => {
    const cur = formatter.value(item);
    ctx2.emit("update:modelValue", cur);
    handleClose();
    await handleSearch(cur);
    selectedIndex.value = getListIndex(cur);
    selectValue.value && selectValue.value(cur);
  };
  return {
    selectedIndex,
    selectOptionClick
  };
}
function useLazyHandle(props, ctx2, handleSearch) {
  const showLoading = ref(false);
  const dropDownRef = ref();
  const loadMore = () => {
    if (!props.enableLazyLoad && showLoading) {
      return;
    }
    const dropDownValue = dropDownRef.value;
    const height = dropDownValue.scrollHeight;
    const scrollTop = dropDownValue.clientHeight + dropDownValue.scrollTop;
    if (scrollTop >= height && scrollTop >= props.maxHeight) {
      props.loadMore();
      showLoading.value = true;
    }
  };
  async function loadFinish() {
    await handleSearch(props.modelValue, props.enableLazyLoad);
    showLoading.value = false;
  }
  ctx2.expose({ loadFinish });
  return {
    showLoading,
    dropDownRef,
    loadMore
  };
}
function useKeyBoardHandle(dropDownRef, visible, searchList, selectedIndex, searchStatus, showNoResultItemTemplate, selectOptionClick, handleClose) {
  var _a;
  const hoverIndex = ref((_a = selectedIndex.value) != null ? _a : 0);
  const scrollToActive = (index2) => {
    const ul = dropDownRef.value;
    const li = ul.children[index2];
    nextTick(() => {
      if (li.scrollIntoViewIfNeeded) {
        li.scrollIntoViewIfNeeded(false);
      } else {
        const containerInfo = ul.getBoundingClientRect();
        const elementInfo = li.getBoundingClientRect();
        if (elementInfo.bottom > containerInfo.bottom || elementInfo.top < containerInfo.top) {
          li.scrollIntoView(false);
        }
      }
    });
  };
  const handlekeyDown = (e) => {
    var _a2;
    const keyCode = e.key || e.code;
    if (keyCode === "Escape" && (visible.value && searchList.value.length || searchStatus.value || showNoResultItemTemplate.value)) {
      handleClose();
      return;
    }
    const status2 = visible.value && searchList.value.length && !searchStatus.value && !showNoResultItemTemplate.value;
    if (keyCode === "ArrowDown" && status2) {
      if (hoverIndex.value === searchList.value.length - 1) {
        hoverIndex.value = 0;
        scrollToActive(hoverIndex.value);
        return;
      }
      hoverIndex.value = hoverIndex.value + 1;
      scrollToActive(hoverIndex.value);
    } else if (keyCode === "ArrowUp" && status2) {
      if (hoverIndex.value === 0) {
        hoverIndex.value = searchList.value.length - 1;
        scrollToActive(hoverIndex.value);
        return;
      }
      hoverIndex.value = hoverIndex.value - 1;
      scrollToActive(hoverIndex.value);
    }
    if (keyCode === "Enter" && status2) {
      selectOptionClick(searchList.value[hoverIndex.value]);
      hoverIndex.value = (_a2 = selectedIndex.value) != null ? _a2 : 0;
      return;
    }
  };
  return {
    hoverIndex,
    handlekeyDown
  };
}
const formProps = {
  data: {
    type: Object,
    default: () => ({})
  },
  layout: {
    type: String,
    default: "horizontal"
  },
  labelSize: {
    type: String,
    default: "md"
  },
  labelAlign: {
    type: String,
    default: "start"
  },
  rules: {
    type: Object
  },
  messageType: {
    type: String,
    default: "popover"
  },
  popPosition: {
    type: Array,
    default: ["right", "bottom"]
  },
  validateOnRuleChange: {
    type: Boolean,
    default: false
  },
  showFeedback: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  size: {
    type: String
  }
};
const FORM_TOKEN = Symbol("dForm");
function useFieldCollection() {
  const itemContexts = [];
  const addItemContext = (field) => {
    itemContexts.push(field);
  };
  const removeItemContext = (field) => {
    itemContexts.splice(itemContexts.indexOf(field), 1);
  };
  return { itemContexts, addItemContext, removeItemContext };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE2 = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags2 = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var cloneableTags2 = {};
    cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
    cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array4, setter, iteratee, accumulator) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        var value = array4[index2];
        setter(accumulator, value, iteratee(value), array4);
      }
      return accumulator;
    }
    function arrayEach2(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (iteratee(array4[index2], index2, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEachRight(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      while (length--) {
        if (iteratee(array4[length], length, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEvery(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (!predicate(array4[index2], index2, array4)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter2(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (predicate(value, index2, array4)) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    function arrayIncludes(array4, value) {
      var length = array4 == null ? 0 : array4.length;
      return !!length && baseIndexOf(array4, value, 0) > -1;
    }
    function arrayIncludesWith(array4, value, comparator) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (comparator(value, array4[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, result2 = Array(length);
      while (++index2 < length) {
        result2[index2] = iteratee(array4[index2], index2, array4);
      }
      return result2;
    }
    function arrayPush2(array4, values) {
      var index2 = -1, length = values.length, offset2 = array4.length;
      while (++index2 < length) {
        array4[offset2 + index2] = values[index2];
      }
      return array4;
    }
    function arrayReduce(array4, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array4[index2], index2, array4);
      }
      return accumulator;
    }
    function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
      var length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array4[length], length, array4);
      }
      return accumulator;
    }
    function arraySome(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (predicate(array4[index2], index2, array4)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string3) {
      return string3.split("");
    }
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result2;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    }
    function baseFindIndex(array4, predicate, fromIndex, fromRight) {
      var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array4[index2], index2, array4)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array4, value, fromIndex) {
      return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array4, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (comparator(array4[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      return length ? baseSum(array4, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object4) {
        return object4 == null ? undefined$1 : object4[key];
      };
    }
    function basePropertyOf(object4) {
      return function(key) {
        return object4 == null ? undefined$1 : object4[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array4, comparer) {
      var length = array4.length;
      array4.sort(comparer);
      while (length--) {
        array4[length] = array4[length].value;
      }
      return array4;
    }
    function baseSum(array4, iteratee) {
      var result2, index2 = -1, length = array4.length;
      while (++index2 < length) {
        var current = iteratee(array4[index2]);
        if (current !== undefined$1) {
          result2 = result2 === undefined$1 ? current : result2 + current;
        }
      }
      return result2;
    }
    function baseTimes2(n, iteratee) {
      var index2 = -1, result2 = Array(n);
      while (++index2 < n) {
        result2[index2] = iteratee(index2);
      }
      return result2;
    }
    function baseToPairs(object4, props) {
      return arrayMap(props, function(key) {
        return [key, object4[key]];
      });
    }
    function baseTrim(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
    }
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object4, props) {
      return arrayMap(props, function(key) {
        return object4[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array4, placeholder) {
      var length = array4.length, result2 = 0;
      while (length--) {
        if (array4[length] === placeholder) {
          ++result2;
        }
      }
      return result2;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object4, key) {
      return object4 == null ? undefined$1 : object4[key];
    }
    function hasUnicode(string3) {
      return reHasUnicode.test(string3);
    }
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    function iteratorToArray(iterator) {
      var data, result2 = [];
      while (!(data = iterator.next()).done) {
        result2.push(data.value);
      }
      return result2;
    }
    function mapToArray(map) {
      var index2 = -1, result2 = Array(map.size);
      map.forEach(function(value, key) {
        result2[++index2] = [key, value];
      });
      return result2;
    }
    function overArg2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array4, placeholder) {
      var index2 = -1, length = array4.length, resIndex = 0, result2 = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array4[index2] = PLACEHOLDER;
          result2[resIndex++] = index2;
        }
      }
      return result2;
    }
    function setToArray(set) {
      var index2 = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index2] = value;
      });
      return result2;
    }
    function setToPairs(set) {
      var index2 = -1, result2 = Array(set.size);
      set.forEach(function(value) {
        result2[++index2] = [value, value];
      });
      return result2;
    }
    function strictIndexOf(array4, value, fromIndex) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array4, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string3) {
      return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
    }
    function stringToArray(string3) {
      return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
    }
    function trimmedEndIndex(string3) {
      var index2 = string3.length;
      while (index2-- && reWhitespace.test(string3.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string3) {
      var result2 = reUnicode.lastIndex = 0;
      while (reUnicode.test(string3)) {
        ++result2;
      }
      return result2;
    }
    function unicodeToArray(string3) {
      return string3.match(reUnicode) || [];
    }
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData2 = context["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString = funcToString2.call(Object2);
      var oldDash = root2._;
      var reIsNative2 = RegExp2("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString = symbolProto2 ? symbolProto2.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate2 = function() {
        function object4() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto);
          }
          object4.prototype = proto;
          var result3 = new object4();
          object4.prototype = undefined$1;
          return result3;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result3 = new LazyWrapper(this.__wrapped__);
        result3.__actions__ = copyArray2(this.__actions__);
        result3.__dir__ = this.__dir__;
        result3.__filtered__ = this.__filtered__;
        result3.__iteratees__ = copyArray2(this.__iteratees__);
        result3.__takeCount__ = this.__takeCount__;
        result3.__views__ = copyArray2(this.__views__);
        return result3;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result3 = new LazyWrapper(this);
          result3.__dir__ = -1;
          result3.__filtered__ = true;
        } else {
          result3 = this.clone();
          result3.__dir__ *= -1;
        }
        return result3;
      }
      function lazyValue() {
        var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array4, this.__actions__);
        }
        var result3 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array4[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type4 = data.type, computed2 = iteratee2(value);
              if (type4 == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type4 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result3[resIndex++] = value;
          }
        return result3;
      }
      LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key) {
        var result3 = this.has(key) && delete this.__data__[key];
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result3 = data[key];
          return result3 === HASH_UNDEFINED2 ? undefined$1 : result3;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet2(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        var result3 = getMapData2(this, key)["delete"](key);
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        var data = getMapData2(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache2();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete2(key) {
        var data = this.__data__, result3 = data["delete"](key);
        this.size = data.size;
        return result3;
      }
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      function stackSet2(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result3.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function arraySample(array4) {
        var length = array4.length;
        return length ? array4[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array4, n) {
        return shuffleSelf(copyArray2(array4), baseClamp(n, 0, array4.length));
      }
      function arrayShuffle(array4) {
        return shuffleSelf(copyArray2(array4));
      }
      function assignMergeValue(object4, key, value) {
        if (value !== undefined$1 && !eq2(object4[key], value) || value === undefined$1 && !(key in object4)) {
          baseAssignValue2(object4, key, value);
        }
      }
      function assignValue2(object4, key, value) {
        var objValue = object4[key];
        if (!(hasOwnProperty2.call(object4, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object4)) {
          baseAssignValue2(object4, key, value);
        }
      }
      function assocIndexOf2(array4, key) {
        var length = array4.length;
        while (length--) {
          if (eq2(array4[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign2(object4, source) {
        return object4 && copyObject2(source, keys2(source), object4);
      }
      function baseAssignIn2(object4, source) {
        return object4 && copyObject2(source, keysIn2(source), object4);
      }
      function baseAssignValue2(object4, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object4, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object4[key] = value;
        }
      }
      function baseAt(object4, paths) {
        var index2 = -1, length = paths.length, result3 = Array2(length), skip = object4 == null;
        while (++index2 < length) {
          result3[index2] = skip ? undefined$1 : get2(object4, paths[index2]);
        }
        return result3;
      }
      function baseClamp(number4, lower, upper) {
        if (number4 === number4) {
          if (upper !== undefined$1) {
            number4 = number4 <= upper ? number4 : upper;
          }
          if (lower !== undefined$1) {
            number4 = number4 >= lower ? number4 : lower;
          }
        }
        return number4;
      }
      function baseClone2(value, bitmask, customizer, key, object4, stack) {
        var result3, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
        if (customizer) {
          result3 = object4 ? customizer(value, key, object4, stack) : customizer(value);
        }
        if (result3 !== undefined$1) {
          return result3;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result3 = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result3);
          }
        } else {
          var tag2 = getTag2(value), isFunc = tag2 == funcTag2 || tag2 == genTag2;
          if (isBuffer2(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag2 == objectTag2 || tag2 == argsTag2 || isFunc && !object4) {
            result3 = isFlat || isFunc ? {} : initCloneObject2(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn2(value, baseAssignIn2(result3, value)) : copySymbols2(value, baseAssign2(result3, value));
            }
          } else {
            if (!cloneableTags2[tag2]) {
              return object4 ? value : {};
            }
            result3 = initCloneByTag2(value, tag2, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result3);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result3.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result3.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result3, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
        });
        return result3;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object4) {
          return baseConformsTo(object4, source, props);
        };
      }
      function baseConformsTo(object4, source, props) {
        var length = props.length;
        if (object4 == null) {
          return !length;
        }
        object4 = Object2(object4);
        while (length--) {
          var key = props[length], predicate = source[key], value = object4[key];
          if (value === undefined$1 && !(key in object4) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array4, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array4.length, result3 = [], valuesLength = values2.length;
        if (!length) {
          return result3;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary2(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE2) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result3.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result3.push(value);
            }
          }
        return result3;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result3 = true;
        baseEach(collection, function(value, index2, collection2) {
          result3 = !!predicate(value, index2, collection2);
          return result3;
        });
        return result3;
      }
      function baseExtremum(array4, iteratee2, comparator) {
        var index2 = -1, length = array4.length;
        while (++index2 < length) {
          var value = array4[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
            var computed2 = current, result3 = value;
          }
        }
        return result3;
      }
      function baseFill(array4, value, start, end) {
        var length = array4.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array4[start++] = value;
        }
        return array4;
      }
      function baseFilter(collection, predicate) {
        var result3 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result3.push(value);
          }
        });
        return result3;
      }
      function baseFlatten(array4, depth, predicate, isStrict, result3) {
        var index2 = -1, length = array4.length;
        predicate || (predicate = isFlattenable);
        result3 || (result3 = []);
        while (++index2 < length) {
          var value = array4[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result3);
            } else {
              arrayPush2(result3, value);
            }
          } else if (!isStrict) {
            result3[result3.length] = value;
          }
        }
        return result3;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object4, iteratee2) {
        return object4 && baseFor(object4, iteratee2, keys2);
      }
      function baseForOwnRight(object4, iteratee2) {
        return object4 && baseForRight(object4, iteratee2, keys2);
      }
      function baseFunctions(object4, props) {
        return arrayFilter2(props, function(key) {
          return isFunction2(object4[key]);
        });
      }
      function baseGet(object4, path) {
        path = castPath(path, object4);
        var index2 = 0, length = path.length;
        while (object4 != null && index2 < length) {
          object4 = object4[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object4 : undefined$1;
      }
      function baseGetAllKeys2(object4, keysFunc, symbolsFunc) {
        var result3 = keysFunc(object4);
        return isArray2(object4) ? result3 : arrayPush2(result3, symbolsFunc(object4));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object4, key) {
        return object4 != null && hasOwnProperty2.call(object4, key);
      }
      function baseHasIn(object4, key) {
        return object4 != null && key in Object2(object4);
      }
      function baseInRange(number4, start, end) {
        return number4 >= nativeMin(start, end) && number4 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
        while (othIndex--) {
          var array4 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array4 = arrayMap(array4, baseUnary2(iteratee2));
          }
          maxLength = nativeMin(array4.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : undefined$1;
        }
        array4 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result3.length < maxLength) {
            var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result3, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseInverter(object4, setter, iteratee2, accumulator) {
        baseForOwn(object4, function(value, key, object5) {
          setter(accumulator, iteratee2(value), key, object5);
        });
        return accumulator;
      }
      function baseInvoke(object4, path, args) {
        path = castPath(path, object4);
        object4 = parent(object4, path);
        var func = object4 == null ? object4 : object4[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object4, args);
      }
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object4), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object4), othTag = othIsArr ? arrayTag2 : getTag2(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object4)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap2(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag2;
      }
      function baseIsMatch(object4, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object4 == null) {
          return !length;
        }
        object4 = Object2(object4);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object4[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object4)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result3 = customizer(objValue, srcValue, key, object4, source, stack);
            }
            if (!(result3 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern4 = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern4.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
      }
      function baseIsSet2(value) {
        return isObjectLike2(value) && getTag2(value) == setTag2;
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys2(object4) {
        if (!isPrototype2(object4)) {
          return nativeKeys2(object4);
        }
        var result3 = [];
        for (var key in Object2(object4)) {
          if (hasOwnProperty2.call(object4, key) && key != "constructor") {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseKeysIn2(object4) {
        if (!isObject2(object4)) {
          return nativeKeysIn2(object4);
        }
        var isProto = isPrototype2(object4), result3 = [];
        for (var key in object4) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object4, key)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result3 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result3[++index2] = iteratee2(value, key, collection2);
        });
        return result3;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object4) {
          return object4 === source || baseIsMatch(object4, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object4) {
          var objValue = get2(object4, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object4, source, srcIndex, customizer, stack) {
        if (object4 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object4, key, newValue);
          }
        }, keysIn2);
      }
      function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object4, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer2(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray2(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject2(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object4, key, newValue);
      }
      function baseNth(array4, n) {
        var length = array4.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex2(n, length) ? array4[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
        var result3 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result3, function(object4, other) {
          return compareMultiple(object4, other, orders);
        });
      }
      function basePick(object4, paths) {
        return basePickBy(object4, paths, function(value, path) {
          return hasIn(object4, path);
        });
      }
      function basePickBy(object4, paths, predicate) {
        var index2 = -1, length = paths.length, result3 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object4, path);
          if (predicate(value, path)) {
            baseSet(result3, castPath(path, object4), value);
          }
        }
        return result3;
      }
      function basePropertyDeep(path) {
        return function(object4) {
          return baseGet(object4, path);
        };
      }
      function basePullAll(array4, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array4;
        if (array4 === values2) {
          values2 = copyArray2(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array4, baseUnary2(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array4) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array4, fromIndex, 1);
          }
        }
        return array4;
      }
      function basePullAt(array4, indexes) {
        var length = array4 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex2(index2)) {
              splice2.call(array4, index2, 1);
            } else {
              baseUnset(array4, index2);
            }
          }
        }
        return array4;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step2, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result3 = Array2(length);
        while (length--) {
          result3[fromRight ? length : ++index2] = start;
          start += step2;
        }
        return result3;
      }
      function baseRepeat(string3, n) {
        var result3 = "";
        if (!string3 || n < 1 || n > MAX_SAFE_INTEGER2) {
          return result3;
        }
        do {
          if (n % 2) {
            result3 += string3;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string3 += string3;
          }
        } while (n);
        return result3;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array4 = values(collection);
        return shuffleSelf(array4, baseClamp(n, 0, array4.length));
      }
      function baseSet(object4, path, value, customizer) {
        if (!isObject2(object4)) {
          return object4;
        }
        path = castPath(path, object4);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object4;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object4;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex2(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue2(nested, key, newValue);
          nested = nested[key];
        }
        return object4;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty2 ? identity : function(func, string3) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string3),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array4, start, end) {
        var index2 = -1, length = array4.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result3 = Array2(length);
        while (++index2 < length) {
          result3[index2] = array4[index2 + start];
        }
        return result3;
      }
      function baseSome(collection, predicate) {
        var result3;
        baseEach(collection, function(value, index2, collection2) {
          result3 = predicate(value, index2, collection2);
          return !result3;
        });
        return !!result3;
      }
      function baseSortedIndex(array4, value, retHighest) {
        var low = 0, high = array4 == null ? low : array4.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array4[mid];
            if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array4, value, identity, retHighest);
      }
      function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
        var low = 0, high = array4 == null ? 0 : array4.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array4[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array4, iteratee2) {
        var index2 = -1, length = array4.length, resIndex = 0, result3 = [];
        while (++index2 < length) {
          var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq2(computed2, seen)) {
            var seen = computed2;
            result3[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result3;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function baseUniq(array4, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array4.length, isCommon = true, result3 = [], seen = result3;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE2) {
          var set2 = iteratee2 ? null : createSet(array4);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result3;
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result3.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result3) {
                seen.push(computed2);
              }
              result3.push(value);
            }
          }
        return result3;
      }
      function baseUnset(object4, path) {
        path = castPath(path, object4);
        object4 = parent(object4, path);
        return object4 == null || delete object4[toKey(last(path))];
      }
      function baseUpdate(object4, path, updater, customizer) {
        return baseSet(object4, path, updater(baseGet(object4, path)), customizer);
      }
      function baseWhile(array4, predicate, isDrop, fromRight) {
        var length = array4.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array4[index2], index2, array4)) {
        }
        return isDrop ? baseSlice(array4, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array4, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result3 = value;
        if (result3 instanceof LazyWrapper) {
          result3 = result3.value();
        }
        return arrayReduce(actions, function(result4, action) {
          return action.func.apply(action.thisArg, arrayPush2([result4], action.args));
        }, result3);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result3 = Array2(length);
        while (++index2 < length) {
          var array4 = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result3[index2] = baseDifference(result3[index2] || array4, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result3 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result3, props[index2], value);
        }
        return result3;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object4) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object4) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array4, start, end) {
        var length = array4.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array4 : baseSlice(array4, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result3);
        return result3;
      }
      function cloneArrayBuffer2(arrayBuffer) {
        var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result3).set(new Uint8Array3(arrayBuffer));
        return result3;
      }
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp2(regexp4) {
        var result3 = new regexp4.constructor(regexp4.source, reFlags2.exec(regexp4));
        result3.lastIndex = regexp4.lastIndex;
        return result3;
      }
      function cloneSymbol2(symbol) {
        return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
      }
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object4, other, orders) {
        var index2 = -1, objCriteria = object4.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result3 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result3) {
            if (index2 >= ordersLength) {
              return result3;
            }
            var order = orders[index2];
            return result3 * (order == "desc" ? -1 : 1);
          }
        }
        return object4.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result3[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result3[leftIndex++] = args[argsIndex++];
        }
        return result3;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result3[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result3[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result3;
      }
      function copyArray2(source, array4) {
        var index2 = -1, length = source.length;
        array4 || (array4 = Array2(length));
        while (++index2 < length) {
          array4[index2] = source[index2];
        }
        return array4;
      }
      function copyObject2(source, props, object4, customizer) {
        var isNew = !object4;
        object4 || (object4 = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue2(object4, key, newValue);
          } else {
            assignValue2(object4, key, newValue);
          }
        }
        return object4;
      }
      function copySymbols2(source, object4) {
        return copyObject2(source, getSymbols2(source), object4);
      }
      function copySymbolsIn2(source, object4) {
        return copyObject2(source, getSymbolsIn2(source), object4);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object4, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object4 = Object2(object4);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object4, source, index2, customizer);
            }
          }
          return object4;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object4, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object4), props = keysFunc(object4), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object4;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string3) {
          string3 = toString(string3);
          var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string3) {
          return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate2(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
          return isObject2(result3) ? result3 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result3 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result3 = funcs[index3].call(this, result3);
            }
            return result3;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object4, iteratee2) {
          return baseInverter(object4, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result3;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result3 = value;
          }
          if (other !== undefined$1) {
            if (result3 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result3 = operator(value, other);
          }
          return result3;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step2) {
          if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
            end = step2 = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step2 = step2 === undefined$1 ? start < end ? 1 : -1 : toFinite(step2);
          return baseRange(start, end, step2, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result3 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result3, newData);
        }
        result3.placeholder = placeholder;
        return setWrapToString(result3, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number4, precision) {
          number4 = toNumber(number4);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number4)) {
            var pair = (toString(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number4);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object4) {
          var tag2 = getTag2(object4);
          if (tag2 == mapTag2) {
            return mapToArray(object4);
          }
          if (tag2 == setTag2) {
            return setToPairs(object4);
          }
          return baseToPairs(object4, keysFunc(object4));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result3 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result3 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result3 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result3 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result3, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object4) {
        if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object4, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object4, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array4.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array4);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array4;
        }
        var index2 = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array4, other);
        stack.set(other, array4);
        while (++index2 < arrLength) {
          var arrValue = array4[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result3 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result3 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result3 = false;
            break;
          }
        }
        stack["delete"](array4);
        stack["delete"](other);
        return result3;
      }
      function equalByTag(object4, other, tag2, bitmask, customizer, equalFunc, stack) {
        switch (tag2) {
          case dataViewTag2:
            if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
              return false;
            }
            object4 = object4.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object4), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object4, +other);
          case errorTag2:
            return object4.name == other.name && object4.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object4 == other + "";
          case mapTag2:
            var convert = mapToArray;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object4.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object4);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object4, other);
            var result3 = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object4);
            return result3;
          case symbolTag2:
            if (symbolValueOf2) {
              return symbolValueOf2.call(object4) == symbolValueOf2.call(other);
            }
        }
        return false;
      }
      function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys2(object4), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object4);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object4;
        }
        var result3 = true;
        stack.set(object4, other);
        stack.set(other, object4);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object4[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result3 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result3 && !skipCtor) {
          var objCtor = object4.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result3 = false;
          }
        }
        stack["delete"](object4);
        stack["delete"](other);
        return result3;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys2(object4) {
        return baseGetAllKeys2(object4, keys2, getSymbols2);
      }
      function getAllKeysIn2(object4) {
        return baseGetAllKeys2(object4, keysIn2, getSymbolsIn2);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result3 = func.name + "", array4 = realNames[result3], length = hasOwnProperty2.call(realNames, result3) ? array4.length : 0;
        while (length--) {
          var data = array4[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result3;
      }
      function getHolder(func) {
        var object4 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object4.placeholder;
      }
      function getIteratee() {
        var result3 = lodash2.iteratee || iteratee;
        result3 = result3 === iteratee ? baseIteratee : result3;
        return arguments.length ? result3(arguments[0], arguments[1]) : result3;
      }
      function getMapData2(map2, key) {
        var data = map2.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object4) {
        var result3 = keys2(object4), length = result3.length;
        while (length--) {
          var key = result3[length], value = object4[key];
          result3[length] = [key, value, isStrictComparable(value)];
        }
        return result3;
      }
      function getNative2(object4, key) {
        var value = getValue2(object4, key);
        return baseIsNative2(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag2 = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result3 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag2;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result3;
      }
      var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object4) {
        if (object4 == null) {
          return [];
        }
        object4 = Object2(object4);
        return arrayFilter2(nativeGetSymbols2(object4), function(symbol) {
          return propertyIsEnumerable2.call(object4, symbol);
        });
      };
      var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object4) {
        var result3 = [];
        while (object4) {
          arrayPush2(result3, getSymbols2(object4));
          object4 = getPrototype2(object4);
        }
        return result3;
      };
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value) {
          var result3 = baseGetTag2(value), Ctor = result3 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result3;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object4, path, hasFunc) {
        path = castPath(path, object4);
        var index2 = -1, length = path.length, result3 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result3 = object4 != null && hasFunc(object4, key))) {
            break;
          }
          object4 = object4[key];
        }
        if (result3 || ++index2 != length) {
          return result3;
        }
        length = object4 == null ? 0 : object4.length;
        return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object4) || isArguments2(object4));
      }
      function initCloneArray2(array4) {
        var length = array4.length, result3 = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty2.call(array4, "index")) {
          result3.index = array4.index;
          result3.input = array4.input;
        }
        return result3;
      }
      function initCloneObject2(object4) {
        return typeof object4.constructor == "function" && !isPrototype2(object4) ? baseCreate2(getPrototype2(object4)) : {};
      }
      function initCloneByTag2(object4, tag2, isDeep) {
        var Ctor = object4.constructor;
        switch (tag2) {
          case arrayBufferTag2:
            return cloneArrayBuffer2(object4);
          case boolTag2:
          case dateTag2:
            return new Ctor(+object4);
          case dataViewTag2:
            return cloneDataView2(object4, isDeep);
          case float32Tag2:
          case float64Tag2:
          case int8Tag2:
          case int16Tag2:
          case int32Tag2:
          case uint8Tag2:
          case uint8ClampedTag2:
          case uint16Tag2:
          case uint32Tag2:
            return cloneTypedArray2(object4, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag2:
          case stringTag2:
            return new Ctor(object4);
          case regexpTag2:
            return cloneRegExp2(object4);
          case setTag2:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol2(object4);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex2(value, length) {
        var type4 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type4 == "number" || type4 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object4) {
        if (!isObject2(object4)) {
          return false;
        }
        var type4 = typeof index2;
        if (type4 == "number" ? isArrayLike2(object4) && isIndex2(index2, object4.length) : type4 == "string" && index2 in object4) {
          return eq2(object4[index2], value);
        }
        return false;
      }
      function isKey(value, object4) {
        if (isArray2(value)) {
          return false;
        }
        var type4 = typeof value;
        if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object2(object4);
      }
      function isKeyable2(value) {
        var type4 = typeof value;
        return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object4) {
          if (object4 == null) {
            return false;
          }
          return object4[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object4));
        };
      }
      function memoizeCapped(func) {
        var result3 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result3.cache;
        return result3;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn2(object4) {
        var result3 = [];
        if (object4 != null) {
          for (var key in Object2(object4)) {
            result3.push(key);
          }
        }
        return result3;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array4 = Array2(length);
          while (++index2 < length) {
            array4[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array4);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object4, path) {
        return path.length < 2 ? object4 : baseGet(object4, baseSlice(path, 0, -1));
      }
      function reorder(array4, indexes) {
        var arrLength = array4.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array4);
        while (length--) {
          var index2 = indexes[length];
          array4[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array4;
      }
      function safeGet(object4, key) {
        if (key === "constructor" && typeof object4[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object4[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array4, size2) {
        var index2 = -1, length = array4.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array4[rand];
          array4[rand] = array4[index2];
          array4[index2] = value;
        }
        array4.length = size2;
        return array4;
      }
      var stringToPath = memoizeCapped(function(string3) {
        var result3 = [];
        if (string3.charCodeAt(0) === 46) {
          result3.push("");
        }
        string3.replace(rePropName, function(match, number4, quote, subString) {
          result3.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
        });
        return result3;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result3 = value + "";
        return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach2(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result3.__actions__ = copyArray2(wrapper.__actions__);
        result3.__index__ = wrapper.__index__;
        result3.__values__ = wrapper.__values__;
        return result3;
      }
      function chunk2(array4, size2, guard) {
        if (guard ? isIterateeCall(array4, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array4 == null ? 0 : array4.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result3[resIndex++] = baseSlice(array4, index2, index2 += size2);
        }
        return result3;
      }
      function compact(array4) {
        var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result3 = [];
        while (++index2 < length) {
          var value = array4[index2];
          if (value) {
            result3[resIndex++] = value;
          }
        }
        return result3;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array4 = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush2(isArray2(array4) ? copyArray2(array4) : [array4], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array4, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array4, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array4) ? baseDifference(array4, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array4, n < 0 ? 0 : n, length);
      }
      function dropRight(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array4, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true) : [];
      }
      function fill(array4, value, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array4, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array4, value, start, end);
      }
      function findIndex(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array4, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array4, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4, 1) : [];
      }
      function flattenDeep(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4, INFINITY) : [];
      }
      function flattenDepth(array4, depth) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array4, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result3[pair[0]] = pair[1];
        }
        return result3;
      }
      function head(array4) {
        return array4 && array4.length ? array4[0] : undefined$1;
      }
      function indexOf(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array4, value, index2);
      }
      function initial(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice(array4, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array4, separator2) {
        return array4 == null ? "" : nativeJoin.call(array4, separator2);
      }
      function last(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? array4[length - 1] : undefined$1;
      }
      function lastIndexOf(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array4, value, index2) : baseFindIndex(array4, baseIsNaN, index2, true);
      }
      function nth(array4, n) {
        return array4 && array4.length ? baseNth(array4, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array4, values2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
      }
      function pullAllBy(array4, values2, iteratee2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
      }
      function pullAllWith(array4, values2, comparator) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined$1, comparator) : array4;
      }
      var pullAt = flatRest(function(array4, indexes) {
        var length = array4 == null ? 0 : array4.length, result3 = baseAt(array4, indexes);
        basePullAt(array4, arrayMap(indexes, function(index2) {
          return isIndex2(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result3;
      });
      function remove(array4, predicate) {
        var result3 = [];
        if (!(array4 && array4.length)) {
          return result3;
        }
        var index2 = -1, indexes = [], length = array4.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array4[index2];
          if (predicate(value, index2, array4)) {
            result3.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array4, indexes);
        return result3;
      }
      function reverse(array4) {
        return array4 == null ? array4 : nativeReverse.call(array4);
      }
      function slice(array4, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array4, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array4, start, end);
      }
      function sortedIndex(array4, value) {
        return baseSortedIndex(array4, value);
      }
      function sortedIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value);
          if (index2 < length && eq2(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array4, value) {
        return baseSortedIndex(array4, value, true);
      }
      function sortedLastIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value, true) - 1;
          if (eq2(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array4) {
        return array4 && array4.length ? baseSortedUniq(array4) : [];
      }
      function sortedUniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice(array4, 1, length) : [];
      }
      function take(array4, n, guard) {
        if (!(array4 && array4.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array4, 0, n < 0 ? 0 : n);
      }
      function takeRight(array4, n, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array4, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array4) {
        return array4 && array4.length ? baseUniq(array4) : [];
      }
      function uniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array4, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array4 && array4.length ? baseUniq(array4, undefined$1, comparator) : [];
      }
      function unzip(array4) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var length = 0;
        array4 = arrayFilter2(array4, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes2(length, function(index2) {
          return arrayMap(array4, baseProperty(index2));
        });
      }
      function unzipWith(array4, iteratee2) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var result3 = unzip(array4);
        if (iteratee2 == null) {
          return result3;
        }
        return arrayMap(result3, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array4, values2) {
        return isArrayLikeObject(array4) ? baseDifference(array4, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter2(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter2(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter2(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue2);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result3 = lodash2(value);
        result3.__chain__ = true;
        return result3;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object4) {
          return baseAt(object4, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array4) {
          if (length && !array4.length) {
            array4.push(undefined$1);
          }
          return array4;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result3, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result3) {
            previous.__wrapped__ = clone2;
          } else {
            result3 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result3;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          ++result3[key];
        } else {
          baseAssignValue2(result3, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach2 : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result3, value, key) {
        if (hasOwnProperty2.call(result3, key)) {
          result3[key].push(value);
        } else {
          baseAssignValue2(result3, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result3 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result3[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result3;
      });
      var keyBy = createAggregator(function(result3, value, key) {
        baseAssignValue2(result3, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result3, value, key) {
        result3[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag2 = getTag2(collection);
        if (tag2 == mapTag2 || tag2 == setTag2) {
          return collection.size;
        }
        return baseKeys2(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result3;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result3 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result3;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object4, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object4, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result3.placeholder = curry.placeholder;
        return result3;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result3.placeholder = curryRight.placeholder;
        return result3;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result3 = func.apply(thisArg, args);
          return result3;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result3;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result3;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result3 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result3;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result3 = func.apply(this, args);
          memoized.cache = cache.set(key, result3) || cache;
          return result3;
        };
        memoized.cache = new (memoize.Cache || MapCache2)();
        return memoized;
      }
      memoize.Cache = MapCache2;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary2(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary2(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array4 = args[start], otherArgs = castSlice(args, 0, start);
          if (array4) {
            arrayPush2(otherArgs, array4);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone2(value, CLONE_SYMBOLS_FLAG2);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
      }
      function cloneDeep2(value) {
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
      }
      function conformsTo(object4, source) {
        return source == null || baseConformsTo(object4, source, keys2(source));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments2(function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse2;
      var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag2 = getTag2(value);
        if (tag2 == mapTag2 || tag2 == setTag2) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys2(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result3 = customizer ? customizer(value, other) : undefined$1;
        return result3 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result3;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag2 = baseGetTag2(value);
        return tag2 == errorTag2 || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag2 = baseGetTag2(value);
        return tag2 == funcTag2 || tag2 == genTag2 || tag2 == asyncTag2 || tag2 == proxyTag2;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type4 = typeof value;
        return value != null && (type4 == "object" || type4 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
      function isMatch(object4, source) {
        return object4 === source || baseIsMatch(object4, source, getMatchData(source));
      }
      function isMatchWith(object4, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object4, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
      }
      function isPlainObject(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto = getPrototype2(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag2;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag2 = getTag2(value), func = tag2 == mapTag2 ? mapToArray : tag2 == setTag2 ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result3 = toFinite(value), remainder = result3 % 1;
        return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject2(value, keysIn2(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object4, source) {
        if (isPrototype2(source) || isArrayLike2(source)) {
          copyObject2(source, keys2(source), object4);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue2(object4, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object4, source) {
        copyObject2(source, keysIn2(source), object4);
      });
      var assignInWith = createAssigner(function(object4, source, srcIndex, customizer) {
        copyObject2(source, keysIn2(source), object4, customizer);
      });
      var assignWith = createAssigner(function(object4, source, srcIndex, customizer) {
        copyObject2(source, keys2(source), object4, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result3 = baseCreate2(prototype);
        return properties == null ? result3 : baseAssign2(result3, properties);
      }
      var defaults = baseRest(function(object4, sources) {
        object4 = Object2(object4);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn2(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object4[key];
            if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object4, key)) {
              object4[key] = source[key];
            }
          }
        }
        return object4;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object4, iteratee2) {
        return object4 == null ? object4 : baseFor(object4, getIteratee(iteratee2, 3), keysIn2);
      }
      function forInRight(object4, iteratee2) {
        return object4 == null ? object4 : baseForRight(object4, getIteratee(iteratee2, 3), keysIn2);
      }
      function forOwn(object4, iteratee2) {
        return object4 && baseForOwn(object4, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object4, iteratee2) {
        return object4 && baseForOwnRight(object4, getIteratee(iteratee2, 3));
      }
      function functions(object4) {
        return object4 == null ? [] : baseFunctions(object4, keys2(object4));
      }
      function functionsIn(object4) {
        return object4 == null ? [] : baseFunctions(object4, keysIn2(object4));
      }
      function get2(object4, path, defaultValue) {
        var result3 = object4 == null ? undefined$1 : baseGet(object4, path);
        return result3 === undefined$1 ? defaultValue : result3;
      }
      function has2(object4, path) {
        return object4 != null && hasPath(object4, path, baseHas);
      }
      function hasIn(object4, path) {
        return object4 != null && hasPath(object4, path, baseHasIn);
      }
      var invert = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result3[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result3, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result3, value)) {
          result3[value].push(key);
        } else {
          result3[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object4) {
        return isArrayLike2(object4) ? arrayLikeKeys2(object4) : baseKeys2(object4);
      }
      function keysIn2(object4) {
        return isArrayLike2(object4) ? arrayLikeKeys2(object4, true) : baseKeysIn2(object4);
      }
      function mapKeys(object4, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object4, function(value, key, object5) {
          baseAssignValue2(result3, iteratee2(value, key, object5), value);
        });
        return result3;
      }
      function mapValues(object4, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object4, function(value, key, object5) {
          baseAssignValue2(result3, key, iteratee2(value, key, object5));
        });
        return result3;
      }
      var merge = createAssigner(function(object4, source, srcIndex) {
        baseMerge(object4, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object4, source, srcIndex, customizer) {
        baseMerge(object4, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object4, paths) {
        var result3 = {};
        if (object4 == null) {
          return result3;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object4);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject2(object4, getAllKeysIn2(object4), result3);
        if (isDeep) {
          result3 = baseClone2(result3, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result3, paths[length]);
        }
        return result3;
      });
      function omitBy(object4, predicate) {
        return pickBy(object4, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object4, paths) {
        return object4 == null ? {} : basePick(object4, paths);
      });
      function pickBy(object4, predicate) {
        if (object4 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn2(object4), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object4, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result2(object4, path, defaultValue) {
        path = castPath(path, object4);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object4 = undefined$1;
        }
        while (++index2 < length) {
          var value = object4 == null ? undefined$1 : object4[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object4 = isFunction2(value) ? value.call(object4) : value;
        }
        return object4;
      }
      function set(object4, path, value) {
        return object4 == null ? object4 : baseSet(object4, path, value);
      }
      function setWith(object4, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object4 == null ? object4 : baseSet(object4, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn2);
      function transform(object4, iteratee2, accumulator) {
        var isArr = isArray2(object4), isArrLike = isArr || isBuffer2(object4) || isTypedArray2(object4);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object4 && object4.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object4)) {
            accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object4)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach2 : baseForOwn)(object4, function(value, index2, object5) {
          return iteratee2(accumulator, value, index2, object5);
        });
        return accumulator;
      }
      function unset(object4, path) {
        return object4 == null ? true : baseUnset(object4, path);
      }
      function update(object4, path, updater) {
        return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater));
      }
      function updateWith(object4, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object4 == null ? object4 : baseUpdate(object4, path, castFunction(updater), customizer);
      }
      function values(object4) {
        return object4 == null ? [] : baseValues(object4, keys2(object4));
      }
      function valuesIn(object4) {
        return object4 == null ? [] : baseValues(object4, keysIn2(object4));
      }
      function clamp2(number4, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number4), lower, upper);
      }
      function inRange(number4, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number4 = toNumber(number4);
        return baseInRange(number4, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result3, word, index2) {
        word = word.toLowerCase();
        return result3 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string3) {
        return upperFirst(toString(string3).toLowerCase());
      }
      function deburr(string3) {
        string3 = toString(string3);
        return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string3, target, position) {
        string3 = toString(string3);
        target = baseToString(target);
        var length = string3.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string3.slice(position, end) == target;
      }
      function escape(string3) {
        string3 = toString(string3);
        return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
      }
      function escapeRegExp(string3) {
        string3 = toString(string3);
        return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar2, "\\$&") : string3;
      }
      var kebabCase = createCompounder(function(result3, word, index2) {
        return result3 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result3, word, index2) {
        return result3 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        if (!length || strLength >= length) {
          return string3;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd2(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
      }
      function padStart(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
      }
      function parseInt2(string3, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string3).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string3, n, guard) {
        if (guard ? isIterateeCall(string3, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string3), n);
      }
      function replace() {
        var args = arguments, string3 = toString(args[0]);
        return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result3, word, index2) {
        return result3 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string3, separator2, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string3, separator2, limit)) {
          separator2 = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string3 = toString(string3);
        if (string3 && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2))) {
          separator2 = baseToString(separator2);
          if (!separator2 && hasUnicode(string3)) {
            return castSlice(stringToArray(string3), 0, limit);
          }
        }
        return string3.split(separator2, limit);
      }
      var startCase = createCompounder(function(result3, word, index2) {
        return result3 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string3, target, position) {
        string3 = toString(string3);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
        target = baseToString(target);
        return string3.slice(position, position + target.length) == target;
      }
      function template(string3, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string3, options, guard)) {
          options = undefined$1;
        }
        string3 = toString(string3);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string3.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result3 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result3.source = source;
        if (isError(result3)) {
          throw result3;
        }
        return result3;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string3, chars, guard) {
        string3 = toString(string3);
        if (string3 && (guard || chars === undefined$1)) {
          return baseTrim(string3);
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string3, chars, guard) {
        string3 = toString(string3);
        if (string3 && (guard || chars === undefined$1)) {
          return string3.slice(0, trimmedEndIndex(string3) + 1);
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string3, chars, guard) {
        string3 = toString(string3);
        if (string3 && (guard || chars === undefined$1)) {
          return string3.replace(reTrimStart, "");
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string3, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator2 = "separator" in options ? options.separator : separator2;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string3 = toString(string3);
        var strLength = string3.length;
        if (hasUnicode(string3)) {
          var strSymbols = stringToArray(string3);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string3;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
        if (separator2 === undefined$1) {
          return result3 + omission;
        }
        if (strSymbols) {
          end += result3.length - end;
        }
        if (isRegExp(separator2)) {
          if (string3.slice(end).search(separator2)) {
            var match, substring = result3;
            if (!separator2.global) {
              separator2 = RegExp2(separator2.source, toString(reFlags2.exec(separator2)) + "g");
            }
            separator2.lastIndex = 0;
            while (match = separator2.exec(substring)) {
              var newEnd = match.index;
            }
            result3 = result3.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string3.indexOf(baseToString(separator2), end) != end) {
          var index2 = result3.lastIndexOf(separator2);
          if (index2 > -1) {
            result3 = result3.slice(0, index2);
          }
        }
        return result3 + omission;
      }
      function unescape(string3) {
        string3 = toString(string3);
        return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
      }
      var upperCase = createCompounder(function(result3, word, index2) {
        return result3 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string3, pattern4, guard) {
        string3 = toString(string3);
        pattern4 = guard ? undefined$1 : pattern4;
        if (pattern4 === undefined$1) {
          return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
        }
        return string3.match(pattern4) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object4, methodNames) {
        arrayEach2(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue2(object4, key, bind2(object4[key], object4));
        });
        return object4;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
      }
      function matches(source) {
        return baseMatches(baseClone2(source, CLONE_DEEP_FLAG2));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
      }
      var method4 = baseRest(function(path, args) {
        return function(object4) {
          return baseInvoke(object4, path, args);
        };
      });
      var methodOf = baseRest(function(object4, args) {
        return function(path) {
          return baseInvoke(object4, path, args);
        };
      });
      function mixin(object4, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object4;
          object4 = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object4);
        arrayEach2(methodNames, function(methodName) {
          var func = source[methodName];
          object4[methodName] = func;
          if (isFunc) {
            object4.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result3 = object4(this.__wrapped__), actions = result3.__actions__ = copyArray2(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object4 });
                result3.__chain__ = chainAll;
                return result3;
              }
              return func.apply(object4, arrayPush2([this.value()], arguments));
            };
          }
        });
        return object4;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object4) {
        return function(path) {
          return object4 == null ? undefined$1 : baseGet(object4, path);
        };
      }
      var range3 = createRange();
      var rangeRight = createRange(true);
      function stubArray2() {
        return [];
      }
      function stubFalse2() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result3 = baseTimes2(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result3;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray2(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity, baseGt) : undefined$1;
      }
      function maxBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array4) {
        return baseMean(array4, identity);
      }
      function meanBy(array4, iteratee2) {
        return baseMean(array4, getIteratee(iteratee2, 2));
      }
      function min(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity, baseLt) : undefined$1;
      }
      function minBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array4) {
        return array4 && array4.length ? baseSum(array4, identity) : 0;
      }
      function sumBy(array4, iteratee2) {
        return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk2;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn2;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method4;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range3;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep2;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq2;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments2;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray2;
      lodash2.stubFalse = stubFalse2;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd2;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result2;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach2(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result3 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result3.__filtered__) {
            result3.__takeCount__ = nativeMin(n, result3.__takeCount__);
          } else {
            result3.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
            });
          }
          return result3;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach2(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type4 = index2 + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result3 = this.clone();
          result3.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type4
          });
          result3.__filtered__ = result3.__filtered__ || isFilter;
          return result3;
        };
      });
      arrayEach2(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach2(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result3 = this;
        if (result3.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result3);
        }
        if (start < 0) {
          result3 = result3.takeRight(-start);
        } else if (start) {
          result3 = result3.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
        }
        return result3;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result4 = lodashFunc.apply(lodash2, arrayPush2([value2], args));
            return isTaker && chainAll ? result4[0] : result4;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result3 = func.apply(value, args);
            result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result3, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result3 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
        };
      });
      arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root2._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
function useFormValidation(itemContexts) {
  const getValidateFields = (fields) => {
    if (!itemContexts.length) {
      return [];
    }
    const normalizedFields = lodash.exports.castArray(fields);
    const filteredFields = normalizedFields.length ? itemContexts.filter((context) => context.field && normalizedFields.includes(context.field)) : itemContexts;
    if (!filteredFields.length) {
      return [];
    }
    return filteredFields;
  };
  const execValidateFields = async (fields = []) => {
    const validateFields2 = getValidateFields(fields);
    if (!validateFields2.length) {
      return true;
    }
    let errors = {};
    for (const field of validateFields2) {
      try {
        await field.validate("");
      } catch (err) {
        errors = __spreadValues(__spreadValues({}, errors), err);
      }
    }
    if (!Object.keys(errors).length) {
      return true;
    }
    return Promise.reject(errors);
  };
  const validateFields = async (fields = [], callback) => {
    try {
      const result2 = await execValidateFields(fields);
      if (result2) {
        callback == null ? void 0 : callback(result2);
      }
      return result2;
    } catch (err) {
      const invalidFields = err;
      callback == null ? void 0 : callback(false, invalidFields);
      return !callback && Promise.reject(invalidFields);
    }
  };
  const validate = async (callback) => validateFields(void 0, callback);
  const clearValidate = (fields = []) => {
    getValidateFields(fields).forEach((field) => field.clearValidate());
  };
  const resetFields = (fields = []) => {
    getValidateFields(fields).forEach((field) => field.resetField());
  };
  return { validate, validateFields, resetFields, clearValidate };
}
var Form = defineComponent({
  name: "DForm",
  props: formProps,
  emits: ["validate"],
  setup(props, ctx2) {
    const ns2 = useNamespace("form");
    const {
      itemContexts,
      addItemContext,
      removeItemContext
    } = useFieldCollection();
    const {
      validate,
      validateFields,
      resetFields,
      clearValidate
    } = useFormValidation(itemContexts);
    const onSubmit = (e) => {
      e.preventDefault();
    };
    watch(() => props.rules, () => {
      if (props.validateOnRuleChange) {
        validate();
      }
    }, {
      deep: true
    });
    provide(FORM_TOKEN, reactive(__spreadProps(__spreadValues({}, toRefs(props)), {
      emit: ctx2.emit,
      addItemContext,
      removeItemContext
    })));
    ctx2.expose({
      validate,
      validateFields,
      resetFields,
      clearValidate
    });
    return () => {
      var _a, _b;
      return createVNode("form", {
        "onSubmit": onSubmit,
        "class": ns2.b()
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
const formItemProps = {
  label: {
    type: String
  },
  field: {
    type: String,
    default: ""
  },
  required: {
    type: Boolean,
    default: false
  },
  messageType: {
    type: String
  },
  popPosition: {
    type: Array
  },
  rules: {
    type: [Object, Array]
  },
  showFeedback: {
    type: Boolean,
    default: void 0
  },
  helpTips: {
    type: String,
    default: ""
  },
  feedbackStatus: {
    type: String
  },
  extraInfo: {
    type: String,
    default: ""
  }
};
const FORM_ITEM_TOKEN = Symbol("dFormItem");
const LABEL_DATA = Symbol("labelData");
const formLabelProps = {
  helpTips: {
    type: String,
    default: ""
  }
};
const fixedOverlayProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  }
};
function useFixedOverlay(props, ctx2) {
  let lockScrollCb;
  const onClick = (event) => {
    event.preventDefault();
    ctx2.emit("click", event);
    if (props.closeOnClickOverlay) {
      ctx2.emit("update:modelValue", false);
    }
  };
  const removeBodyAdditions = () => {
    lockScrollCb == null ? void 0 : lockScrollCb();
  };
  watch(() => props.modelValue, (val) => {
    if (val) {
      props.lockScroll && (lockScrollCb = lockScroll());
    } else {
      removeBodyAdditions();
    }
  });
  onUnmounted(removeBodyAdditions);
  return { onClick };
}
var fixedOverlay = "";
const FixedOverlay = defineComponent({
  name: "DFixedOverlay",
  inheritAttrs: false,
  props: fixedOverlayProps,
  emits: ["update:modelValue", "click"],
  setup(props, ctx2) {
    const {
      modelValue
    } = toRefs(props);
    const ns2 = useNamespace("fixed-overlay");
    const {
      onClick
    } = useFixedOverlay(props, ctx2);
    return () => createVNode(Transition, {
      "name": ns2.m("fade")
    }, {
      default: () => {
        var _a, _b;
        return [modelValue.value && createVNode("div", mergeProps({
          "class": ns2.b()
        }, ctx2.attrs, {
          "onClick": onClick
        }), [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])];
      }
    });
  }
});
const flexibleOverlayProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  origin: {
    type: Object,
    require: true
  },
  position: {
    type: Array,
    default: ["bottom"]
  },
  offset: {
    type: [Number, Object],
    default: 8
  },
  shiftOffset: {
    type: Number
  },
  align: {
    type: String,
    default: null
  },
  showArrow: {
    type: Boolean,
    default: false
  },
  isArrowCenter: {
    type: Boolean,
    default: true
  },
  clickEventBubble: {
    type: Boolean,
    default: false
  }
};
function getScrollParent(element) {
  const overflowRegex = /(auto|scroll|hidden)/;
  for (let parent = element; parent = parent.parentElement; parent.parentElement !== document.body) {
    const style = window.getComputedStyle(parent);
    if (overflowRegex.test(style.overflow + style.overflowX + style.overflowY)) {
      return parent;
    }
  }
  return window;
}
function adjustArrowPosition(isArrowCenter, point, placement, originRect) {
  let { x, y } = point;
  if (!isArrowCenter) {
    const { width, height } = originRect;
    if (x && placement.includes("start")) {
      x = 12;
    }
    if (x && placement.includes("end")) {
      x = Math.round(width - 24);
    }
    if (y && placement.includes("start")) {
      y = 10;
    }
    if (y && placement.includes("end")) {
      y = height - 14;
    }
  }
  return { x, y };
}
function useOverlay(props, emit) {
  const overlayRef = ref();
  const arrowRef = ref();
  let originParent = null;
  const updateArrowPosition = (arrowEl, placement, point, overlayEl) => {
    const { x, y } = adjustArrowPosition(props.isArrowCenter, point, placement, overlayEl.getBoundingClientRect());
    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right"
    }[placement.split("-")[0]];
    Object.assign(arrowEl.style, {
      left: x ? `${x}px` : "",
      top: y ? `${y}px` : "",
      right: "",
      bottom: "",
      [staticSide]: "-4px"
    });
  };
  const updatePosition = async () => {
    const hostEl = props.origin;
    const overlayEl = unref(overlayRef.value);
    const arrowEl = unref(arrowRef.value);
    const middleware = [
      offset(props.offset),
      autoPlacement({
        alignment: props.align,
        allowedPlacements: props.position
      })
    ];
    props.showArrow && middleware.push(arrow({ element: arrowEl }));
    props.shiftOffset !== void 0 && middleware.push(shift());
    const { x, y, placement, middlewareData } = await computePosition(hostEl, overlayEl, {
      strategy: "fixed",
      middleware
    });
    let applyX = x;
    let applyY = y;
    if (props.shiftOffset !== void 0) {
      const { x: shiftX, y: shiftY } = middlewareData.shift;
      shiftX < 0 && (applyX -= props.shiftOffset);
      shiftX > 0 && (applyX += props.shiftOffset);
      shiftY < 0 && (applyY -= props.shiftOffset);
      shiftY > 0 && (applyY += props.shiftOffset);
    }
    emit("positionChange", placement);
    Object.assign(overlayEl.style, { top: `${applyY}px`, left: `${applyX}px` });
    props.showArrow && updateArrowPosition(arrowEl, placement, middlewareData.arrow, overlayEl);
  };
  watch(() => props.modelValue, () => {
    if (props.modelValue && props.origin) {
      originParent = getScrollParent(props.origin);
      nextTick(updatePosition);
      originParent == null ? void 0 : originParent.addEventListener("scroll", updatePosition);
      originParent !== window && window.addEventListener("scroll", updatePosition);
      window.addEventListener("resize", updatePosition);
    } else {
      originParent == null ? void 0 : originParent.removeEventListener("scroll", updatePosition);
      originParent !== window && window.removeEventListener("scroll", updatePosition);
      window.removeEventListener("resize", updatePosition);
    }
  });
  onUnmounted(() => {
    originParent == null ? void 0 : originParent.removeEventListener("scroll", updatePosition);
    originParent !== window && window.removeEventListener("scroll", updatePosition);
    window.removeEventListener("resize", updatePosition);
  });
  return { arrowRef, overlayRef, updatePosition };
}
var flexibleOverlay = "";
const FlexibleOverlay = defineComponent({
  name: "DFlexibleOverlay",
  inheritAttrs: false,
  props: flexibleOverlayProps,
  emits: ["update:modelValue", "positionChange"],
  setup(props, {
    slots,
    attrs,
    emit,
    expose
  }) {
    const ns2 = useNamespace("flexible-overlay");
    const {
      clickEventBubble
    } = toRefs(props);
    const {
      arrowRef,
      overlayRef,
      updatePosition
    } = useOverlay(props, emit);
    expose({
      updatePosition
    });
    return () => {
      var _a;
      return props.modelValue && createVNode("div", mergeProps({
        "ref": overlayRef,
        "class": ns2.b()
      }, attrs, {
        "onClick": withModifiers(() => ({}), [clickEventBubble.value ? "" : "stop"]),
        "onPointerup": withModifiers(() => ({}), ["stop"])
      }), [(_a = slots.default) == null ? void 0 : _a.call(slots), props.showArrow && createVNode("div", {
        "ref": arrowRef,
        "class": ns2.e("arrow")
      }, null)]);
    };
  }
});
var OverlayInstall = {
  title: "Overlay \u906E\u7F69\u5C42",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.component(FixedOverlay.name, FixedOverlay);
    app.component(FlexibleOverlay.name, FlexibleOverlay);
    if (inBrowser && !document.getElementById("d-overlay-anchor")) {
      const overlayAnchor = document.createElement("div");
      overlayAnchor.setAttribute("id", "d-overlay-anchor");
      overlayAnchor.style.position = "fixed";
      overlayAnchor.style.left = "0";
      overlayAnchor.style.top = "0";
      overlayAnchor.style.zIndex = "1000";
      document.body.appendChild(overlayAnchor);
    }
  }
};
const POPPER_TRIGGER_TOKEN = Symbol("popper-trigger");
const isString$1 = (val) => typeof val === "string";
const isObject$7 = (val) => val !== null && typeof val === "object";
const ns$j = useNamespace("popper-trigger");
function wrapContent(content2) {
  return h("span", { class: ns$j.b() }, content2);
}
function getFirstValidChild(nodes) {
  for (const child of nodes) {
    if (isObject$7(child)) {
      if (child.type === Comment$1) {
        continue;
      }
      if (child.type === "svg" || child.type === Text) {
        return wrapContent(child);
      }
      if (child.type === Fragment) {
        return getFirstValidChild(child.children);
      }
      return child;
    }
    return wrapContent(child);
  }
  return null;
}
var PopperTrigger = defineComponent({
  name: "DPopperTrigger",
  setup(_, ctx2) {
    const {
      slots,
      attrs
    } = ctx2;
    return () => {
      var _a;
      const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
      const triggerRef = inject(POPPER_TRIGGER_TOKEN);
      if (!defaultSlot) {
        return null;
      }
      const firstValidChild = getFirstValidChild(defaultSlot);
      if (!firstValidChild) {
        return null;
      }
      return withDirectives(cloneVNode(firstValidChild, attrs), [[{
        mounted(el) {
          triggerRef.value = el;
        },
        updated(el) {
          triggerRef.value = el;
        },
        unmounted() {
          triggerRef.value = null;
        }
      }]]);
    };
  }
});
const popoverProps = {
  isOpen: {
    type: Boolean,
    default: false
  },
  position: {
    type: Array,
    default: ["bottom"]
  },
  align: {
    type: String,
    default: null
  },
  offset: {
    type: [Number, Object],
    default: 8
  },
  content: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    default: "click"
  },
  popType: {
    type: String,
    default: "default"
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  mouseEnterDelay: {
    type: Number,
    default: 150
  },
  mouseLeaveDelay: {
    type: Number,
    default: 100
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
const TransformOriginMap = {
  top: "50% calc(100% + 8px)",
  bottom: "50% -8px",
  left: "calc(100% + 8px)",
  right: "-8px 50%"
};
function usePopover(props, visible, placement, origin, popoverRef) {
  const { trigger, isOpen } = toRefs(props);
  const overlayStyles = computed(() => ({
    zIndex: "var(--b-z-index-pop-up, 1060)",
    transformOrigin: TransformOriginMap[placement.value]
  }));
  const onDocumentClick = (e) => {
    var _a, _b;
    if (!((_a = origin.value) == null ? void 0 : _a.contains(e.target)) && !((_b = popoverRef.value.$el) == null ? void 0 : _b.contains(e.target))) {
      visible.value = false;
    }
  };
  watch(isOpen, (isOpenVal) => {
    visible.value = isOpenVal;
  });
  watch(visible, () => {
    if (visible.value && trigger.value !== "manually") {
      document.addEventListener("click", onDocumentClick);
    } else {
      document.removeEventListener("click", onDocumentClick);
    }
  });
  onUnmounted(() => {
    document.removeEventListener("click", onDocumentClick);
  });
  return { overlayStyles };
}
function usePopoverEvent(props, visible, origin) {
  const { trigger, position, mouseEnterDelay, mouseLeaveDelay, disabled } = toRefs(props);
  const isClick = computed(() => trigger.value === "click");
  const placement = ref(position.value[0].split("-")[0]);
  const isEnter = ref(false);
  const onClick = () => {
    if (disabled.value) {
      return;
    }
    isClick.value && (visible.value = !visible.value);
  };
  const enter = lodash.exports.debounce(() => {
    isEnter.value && (visible.value = true);
  }, mouseEnterDelay.value);
  const leave = lodash.exports.debounce(() => {
    !isEnter.value && (visible.value = false);
  }, mouseLeaveDelay.value);
  const onMouseenter = () => {
    if (disabled.value) {
      return;
    }
    if (!isClick.value) {
      isEnter.value = true;
      enter();
    }
  };
  const onMouseleave = () => {
    if (!isClick.value) {
      isEnter.value = false;
      leave();
    }
  };
  const quickLeave = () => {
    isEnter.value = false;
    visible.value = false;
  };
  watch(disabled, (newVal) => {
    if (newVal && visible.value) {
      quickLeave();
    }
  });
  const handlePositionChange = (pos) => {
    placement.value = pos.split("-")[0];
  };
  onMounted(() => {
    if (trigger.value === "click") {
      origin.value.addEventListener("click", onClick);
    } else if (trigger.value === "hover") {
      origin.value.addEventListener("mouseenter", onMouseenter);
      origin.value.addEventListener("mouseleave", onMouseleave);
    }
  });
  return { placement, handlePositionChange, onMouseenter, onMouseleave };
}
const ns$i = useNamespace("popover");
function SuccessIcon$3() {
  return createVNode("svg", {
    "class": [ns$i.e("icon"), ns$i.em("icon", "success")],
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "cx": "8",
    "cy": "8",
    "r": "7"
  }, null), createVNode("path", {
    "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16 C12.4,16 16,12.4 16,8 C16,3.6 12.4,0 8,0 Z",
    "fill-rule": "nonzero"
  }, null), createVNode("polygon", {
    "stroke-width": "0.4",
    "fill-rule": "nonzero",
    "points": "8.16 10.48 7.32 11.32 6.48 10.48 6.48 10.48 3.6 7.68 4.44 6.84 7.28 9.68 11.52 5.44 12.36 6.28"
  }, null)])]);
}
function WarningIcon$2() {
  return createVNode("svg", {
    "class": [ns$i.e("icon"), ns$i.em("icon", "warning")],
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("polygon", {
    "points": "7.5 1.74501946 1.39184847 13.5954649 7.08947368         14.2207621 13.9973698 13.5954649 10.9383683 5.61273879 8.40084114 1.27624313"
  }, null), createVNode("path", {
    "d": "M8.51325441,0.127397589 C8.70423071,0.228333932         8.8605922,0.383286648 8.96244623,0.57254229 L15.8714442,13.4101975         C16.1549662,13.9370117 15.9538562,14.5918482 15.4222523,14.8728158         C15.2642579,14.9563203 15.0879506,15 14.9088903,15 L1.09089441,15         C0.488410063,15 0,14.5159904 0,13.9189343 C0,13.7414873 0.0440768395,13.5667684         0.128340519,13.4101975 L7.03733844,0.57254229 C7.32086049,0.0457280838 7.98165058,-0.153569987         8.51325441,0.127397589 Z M8.87894737,11.2105263 L7.08947368,11.2105263 L7.08947368,13         L8.87894737,13 L8.87894737,11.2105263 Z M8.96842105,4.5 L7,4.5 L7.08947368,9.86842105         L8.87894737,9.86842105 L8.96842105,4.5 Z"
  }, null)])]);
}
function InfoIcon$2() {
  return createVNode("svg", {
    "class": [ns$i.e("icon"), ns$i.em("icon", "info")],
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "cx": "8",
    "cy": "8",
    "r": "7"
  }, null), createVNode("g", {
    "stroke-width": "1"
  }, [createVNode("path", {
    "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16           C12.4,16 16,12.4 16,8 C16,3.6 12.4,0 8,0 Z M9,5 L7,5 L7,3 L9,3 L9,5 Z M9,12.6 L7,12.6 L7,6.6 L9,6.6 L9,12.6 Z"
  }, null)])])]);
}
function ErrorIcon$3() {
  return createVNode("svg", {
    "class": [ns$i.e("icon"), ns$i.em("icon", "error")],
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "cx": "8",
    "cy": "8",
    "r": "7"
  }, null), createVNode("path", {
    "d": "M8,0 C3.6,0 0,3.6 0,8 C0,12.4 3.6,16 8,16 C12.4,16 16,12.4 16,8           C16,3.6 12.4,0 8,0 Z M9,12.6 L7,12.6 L7,10.6 L9,10.6 L9,12.6 Z M9,9.1 L7,9.1 L6.9,3.1 L9.1,3.1 L9,9.1 Z",
    "fill-rule": "nonzero"
  }, null)])]);
}
var popoverIcon = "";
var PopoverIcon = defineComponent({
  props: {
    type: {
      type: String,
      default: "default"
    }
  },
  setup(props) {
    const ns2 = useNamespace("popover");
    return () => props.type && props.type !== "default" && createVNode("span", {
      "class": ns2.e("icon-wrap")
    }, [props.type === "success" && createVNode(SuccessIcon$3, null, null), props.type === "warning" && createVNode(WarningIcon$2, null, null), props.type === "info" && createVNode(InfoIcon$2, null, null), props.type === "error" && createVNode(ErrorIcon$3, null, null)]);
  }
});
var popover = "";
var Popover = defineComponent({
  name: "DPopover",
  inheritAttrs: false,
  props: popoverProps,
  emits: ["show", "hide"],
  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const {
      content: content2,
      popType,
      position,
      align,
      offset: offset2,
      showAnimation
    } = toRefs(props);
    const origin = ref();
    const popoverRef = ref();
    const visible = ref(false);
    const {
      placement,
      handlePositionChange,
      onMouseenter,
      onMouseleave
    } = usePopoverEvent(props, visible, origin);
    const {
      overlayStyles
    } = usePopover(props, visible, placement, origin, popoverRef);
    const ns2 = useNamespace("popover");
    provide(POPPER_TRIGGER_TOKEN, origin);
    watch(visible, (newVal) => {
      if (newVal) {
        emit("show");
      } else {
        emit("hide");
      }
    });
    return () => createVNode(Fragment, null, [createVNode(PopperTrigger, null, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    }), createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode(Transition, {
        "name": showAnimation.value ? ns2.m(`fade-${placement.value}`) : ""
      }, {
        default: () => [createVNode(FlexibleOverlay, mergeProps({
          "modelValue": visible.value,
          "onUpdate:modelValue": ($event) => visible.value = $event,
          "ref": popoverRef,
          "origin": origin.value,
          "position": position.value,
          "align": align.value,
          "offset": offset2.value,
          "class": [ns2.e("content"), popType.value !== "default" ? "is-icon" : ""],
          "show-arrow": true,
          "is-arrow-center": false,
          "style": overlayStyles.value
        }, attrs, {
          "onPositionChange": handlePositionChange,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave
        }), {
          default: () => {
            var _a;
            return [createVNode(PopoverIcon, {
              "type": popType.value
            }, null), ((_a = slots.content) == null ? void 0 : _a.call(slots)) || createVNode("span", null, [content2.value])];
          }
        })]
      })]
    })]);
  }
});
function HelpTipsIcon() {
  return createVNode("svg", {
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", null, [createVNode("path", {
    "d": "M8.5,8.95852078 L8.5,11 L7.5,11 L7.5,8.5 C7.5,8.22385763             7.72385763,8 8,8 C9.1045695,8 10,7.1045695 10,6 C10,4.8954305             9.1045695,4 8,4 C6.8954305,4 6,4.8954305 6,6 L5,6 C5,4.34314575             6.34314575,3 8,3 C9.65685425,3 11,4.34314575 11,6 C11,7.48649814             9.91885667,8.72048173 8.5,8.95852078 L8.5,8.95852078 Z M8,16 C3.581722,16             0,12.418278 0,8 C0,3.581722 3.581722,0 8,0 C12.418278,0 16,3.581722 16,8 C16,12.418278             12.418278,16 8,16 Z M8,15 C11.8659932,15 15,11.8659932 15,8 C15,4.13400675 11.8659932,1 8,1             C4.13400675,1 1,4.13400675 1,8 C1,11.8659932 4.13400675,15 8,15 Z M7.5,12 L8.5,12 L8.5,13 L7.5,13 L7.5,12 Z",
    "fill": "#293040",
    "fill-rule": "nonzero"
  }, null)])])]);
}
function ErrorIcon$2() {
  return createVNode("svg", {
    "width": "14px",
    "height": "14px",
    "viewBox": "0 0 16 16"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "cx": "8",
    "cy": "8",
    "r": "8"
  }, null), createVNode("polygon", {
    "points": "8.07106781 6.65685425 10.8994949 3.82842712 12.3137085         5.24264069 9.48528137 8.07106781 12.3137085 10.8994949 10.8994949 12.3137085         8.07106781 9.48528137 5.24264069 12.3137085 3.82842712 10.8994949 6.65685425         8.07106781 3.82842712 5.24264069 5.24264069 3.82842712"
  }, null)])]);
}
function SuccessIcon$2() {
  return createVNode("svg", {
    "width": "14px",
    "height": "14px",
    "viewBox": "0 0 16 16"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "cx": "8",
    "cy": "8",
    "r": "8"
  }, null), createVNode("polygon", {
    "points": "6.53553391 9.77817459 12.1923882 4.12132034 13.6066017 5.53553391         6.53553391 12.6066017 3 9.07106781 4.41421356 7.65685425 6.53553391 9.77817459"
  }, null)])]);
}
function PendingIcon() {
  return createVNode("svg", {
    "width": "14px",
    "height": "14px",
    "viewBox": "0 0 16 16"
  }, [createVNode("g", {
    "id": "loading",
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M8,0 C12.4,0 16,3.6 16,8 C16,12.4 12.4,16 8,16 C3.6,16 0,12.4 0,8 C0,3.6 3.6,0 8,0           Z M8,1 C4.15,1 1,4.15 1,8 C1,11.85 4.15,15 8,15 C11.85,15 15,11.85 15,8 C15,4.15 11.85,1 8,1 Z",
    "fill-rule": "nonzero"
  }, null), createVNode("path", {
    "d": "M8,0 C12.4,0 16,3.6 16,8 L15,8 C15,4.15 11.85,1 8,1 L8,0 Z",
    "fill-rule": "nonzero"
  }, null)])]);
}
function useFormLabel() {
  const formItemContext = inject(FORM_ITEM_TOKEN);
  const labelData = inject(LABEL_DATA);
  const ns2 = useNamespace("form");
  const labelClasses = computed(() => ({
    [`${ns2.e("label")}`]: true,
    [`${ns2.em("label", "vertical")}`]: labelData.value.layout === "vertical",
    [`${ns2.em("label", labelData.value.labelSize)}`]: labelData.value.layout === "horizontal",
    [`${ns2.em("label", labelData.value.labelAlign)}`]: labelData.value.layout === "horizontal"
  }));
  const labelInnerClasses = computed(() => ({
    [`${ns2.e("label-span")}`]: true,
    [`${ns2.em("label", "required")}`]: formItemContext.isRequired
  }));
  return { labelClasses, labelInnerClasses };
}
var formLabel = "";
var FormLabel = defineComponent({
  name: "DFormLabel",
  props: formLabelProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("form");
    const {
      labelClasses,
      labelInnerClasses
    } = useFormLabel();
    return () => {
      var _a, _b;
      return createVNode("span", {
        "class": labelClasses.value
      }, [createVNode("span", {
        "class": labelInnerClasses.value
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]), props.helpTips && createVNode(Popover, {
        "content": props.helpTips,
        "position": ["top"],
        "trigger": "hover",
        "pop-type": "info"
      }, {
        default: () => [createVNode(HelpTipsIcon, {
          "class": ns2.e("label-help")
        }, null), createTextVNode(",")]
      })]);
    };
  }
});
const formControlProps = {
  feedbackStatus: {
    type: String
  },
  extraInfo: {
    type: String,
    default: ""
  }
};
var PopoverInstall = {
  title: "Popover \u60AC\u6D6E\u63D0\u793A",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Popover.name, Popover);
  }
};
function useFormControl(props) {
  const labelData = inject(LABEL_DATA);
  const ns2 = useNamespace("form");
  const { feedbackStatus } = toRefs(props);
  const controlClasses = computed(() => ({
    [ns2.e("control")]: true,
    [ns2.em("control", "horizontal")]: labelData.value.layout === "horizontal"
  }));
  const controlContainerClasses = computed(() => ({
    [ns2.e("control-container")]: true,
    [ns2.em("control-container", "horizontal")]: labelData.value.layout === "horizontal",
    [ns2.em("control-container", "has-feedback")]: Boolean(feedbackStatus == null ? void 0 : feedbackStatus.value),
    [ns2.em("control-container", "feedback-error")]: Boolean((feedbackStatus == null ? void 0 : feedbackStatus.value) === "error")
  }));
  return { controlClasses, controlContainerClasses };
}
function useFormControlValidate() {
  const formItemContext = inject(FORM_ITEM_TOKEN);
  const feedbackStatus = computed(() => formItemContext.validateState);
  const showFeedback = computed(() => formItemContext.showFeedback && Boolean(formItemContext.validateState));
  const showPopover = computed(() => formItemContext.messageType === "popover" && formItemContext.validateState === "error");
  const showMessage = computed(() => formItemContext.messageType === "text" && formItemContext.validateState === "error");
  const errorMessage = computed(() => formItemContext.validateMessage);
  const popPosition = computed(() => formItemContext.popPosition);
  return { feedbackStatus, showFeedback, showPopover, showMessage, errorMessage, popPosition };
}
var formControl = "";
var FormControl = defineComponent({
  name: "DFormControl",
  props: formControlProps,
  setup(props, ctx2) {
    const formControl2 = ref();
    const ns2 = useNamespace("form");
    const {
      controlClasses,
      controlContainerClasses
    } = useFormControl(props);
    const {
      feedbackStatus,
      showFeedback,
      showPopover,
      showMessage,
      errorMessage,
      popPosition
    } = useFormControlValidate();
    return () => createVNode("div", {
      "class": controlClasses.value,
      "ref": formControl2
    }, [createVNode("div", {
      "class": controlContainerClasses.value
    }, [createVNode(Popover, {
      "is-open": showPopover.value,
      "trigger": "manually",
      "content": errorMessage.value,
      "pop-type": "error",
      "position": popPosition.value
    }, {
      default: () => {
        var _a, _b;
        return [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)];
      }
    }), showFeedback.value && createVNode("span", {
      "class": [ns2.e("feedback-icon"), ns2.em("feedback-icon", feedbackStatus.value)]
    }, [feedbackStatus.value === "error" && createVNode(ErrorIcon$2, null, null), feedbackStatus.value === "success" && createVNode(SuccessIcon$2, null, null), feedbackStatus.value === "pending" && createVNode(PendingIcon, null, null)])]), createVNode("div", {
      "class": ns2.e("control-info")
    }, [showMessage.value && createVNode("div", {
      "class": "error-message"
    }, [errorMessage.value]), props.extraInfo && createVNode("div", {
      "class": ns2.e("control-extra")
    }, [props.extraInfo])])]);
  }
});
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning$1 = function warning() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning$1 = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error2) {
    var field = error2.field;
    fields[field] = fields[field] || [];
    fields[field].push(error2);
  });
  return fields;
}
function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results2 = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results2.push.apply(results2, errors || []);
    total++;
    if (total === arrLength) {
      callback(results2);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option2, func, callback, source) {
  if (option2.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option2.firstFields === true ? Object.keys(objArr) : option2.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results2 = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results2.push.apply(results2, errors);
      total++;
      if (total === objArrLength) {
        callback(results2);
        return results2.length ? reject(new AsyncValidationError(results2, convertFieldsError(results2))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results2);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$2(value, path) {
  var v = value;
  for (var i = 0; i < path.length; i++) {
    if (v == void 0) {
      return v;
    }
    v = v[path[i]];
  }
  return v;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$2(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];
        if (typeof value === "object" && typeof target[s] === "object") {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(pattern$2.url);
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules$1 = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules$1.type(rule, value, source, errors, options);
      rules$1.range(rule, value, source, errors, options);
      rules$1.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules$1.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
      rules$1.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules$1.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
      rules$1.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
      rules$1.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules$1.type(rule, value, source, errors, options);
      rules$1.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules$1[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules$1.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules$1.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules$1.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules$1.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules$1.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;
    if (o === void 0) {
      o = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options = o;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results2) {
      var errors = [];
      var fields = {};
      function add(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results2.length; i++) {
        add(results2[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value,
          source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results2) {
      complete(results2);
    }, source);
  };
  _proto.getType = function getType2(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning$1;
Schema.messages = messages;
Schema.validators = validators;
function getFieldValue(obj, path) {
  return {
    get value() {
      return lodash.exports.get(obj, path);
    },
    set value(val) {
      lodash.exports.set(obj, path, val);
    }
  };
}
function useFormItem(messageType, _rules, validateState) {
  const formContext = inject(FORM_TOKEN);
  const ns2 = useNamespace("form");
  const itemClasses = computed(() => ({
    [`${ns2.em("item", "horizontal")}`]: formContext.layout === "horizontal",
    [`${ns2.em("item", "vertical")}`]: formContext.layout === "vertical",
    [`${ns2.em("item", "error")}`]: messageType.value === "text" && validateState.value === "error"
  }));
  const isRequired = computed(() => _rules.value.some((rule) => Boolean(rule.required)));
  return { itemClasses, isRequired };
}
function useFormItemRule(props) {
  const formContext = inject(FORM_TOKEN);
  const _rules = computed(() => {
    const rules2 = props.rules ? lodash.exports.castArray(props.rules) : [];
    const formRules = formContext.rules;
    if (formRules && props.field) {
      const _itemRules = lodash.exports.get(formRules, props.field, void 0);
      if (_itemRules) {
        rules2.push(...lodash.exports.castArray(_itemRules));
      }
    }
    if (props.required) {
      rules2.push({ required: Boolean(props.required) });
    }
    return rules2;
  });
  return { _rules };
}
function useFormItemValidate(props, _rules) {
  const formContext = inject(FORM_TOKEN);
  const validateState = ref("");
  const validateMessage = ref("");
  let initFieldValue = void 0;
  let isResetting = false;
  const computedField = computed(() => {
    return typeof props.field === "string" ? props.field : "";
  });
  const fieldValue = computed(() => {
    const formData = formContext.data;
    if (!formData || !props.field) {
      return;
    }
    return getFieldValue(formData, props.field).value;
  });
  const getRuleByTrigger = (triggerVal) => {
    return _rules.value.filter((rule) => {
      if (!rule.trigger || !triggerVal) {
        return true;
      }
      if (Array.isArray(rule.trigger)) {
        return rule.trigger.includes(triggerVal);
      } else {
        return rule.trigger === triggerVal;
      }
    }).map((_a) => {
      var rule = __objRest(_a, []);
      return rule;
    });
  };
  const onValidateSuccess = () => {
    validateState.value = "success";
    validateMessage.value = "";
    formContext.emit("validate", props.field, true, "");
  };
  const onValidateError = ({ errors }) => {
    var _a;
    validateState.value = "error";
    validateMessage.value = ((_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) || "";
    formContext.emit("validate", props.field, false, validateMessage.value);
  };
  const execValidate = async (rules2) => {
    const ruleName = computedField.value;
    const validator = new Schema({
      [ruleName]: rules2
    });
    return validator.validate({ [ruleName]: fieldValue.value }, { firstFields: true }).then(() => {
      onValidateSuccess();
      return true;
    }).catch((error2) => {
      onValidateError(error2);
      return Promise.reject(error2);
    });
  };
  const validate = async (trigger, callback) => {
    if (isResetting) {
      isResetting = false;
      return false;
    }
    const rules2 = getRuleByTrigger(trigger);
    if (!rules2.length) {
      callback == null ? void 0 : callback(true);
      return true;
    }
    validateState.value = "pending";
    return execValidate(rules2).then(() => {
      callback == null ? void 0 : callback(true);
      return true;
    }).catch((error2) => {
      const { fields } = error2;
      callback == null ? void 0 : callback(false, fields);
      return lodash.exports.isFunction(callback) ? false : Promise.reject(fields);
    });
  };
  const clearValidate = () => {
    validateState.value = "";
    validateMessage.value = "";
  };
  const resetField = async () => {
    if (!formContext.data || !props.field) {
      return;
    }
    const currentValue = getFieldValue(formContext.data, props.field);
    if (!lodash.exports.isEqual(currentValue.value, initFieldValue)) {
      isResetting = true;
    }
    currentValue.value = initFieldValue;
    await nextTick();
    clearValidate();
  };
  onMounted(() => {
    initFieldValue = lodash.exports.clone(fieldValue.value);
  });
  return { validateState, validateMessage, validate, resetField, clearValidate };
}
var formItem = "";
var FormItem = defineComponent({
  name: "DFormItem",
  props: formItemProps,
  setup(props, ctx2) {
    const formContext = inject(FORM_TOKEN);
    const _a = toRefs(props), {
      messageType: itemMessageType,
      popPosition: itemPopPosition,
      showFeedback: itemShowFeedback
    } = _a, otherProps = __objRest(_a, [
      "messageType",
      "popPosition",
      "showFeedback"
    ]);
    const {
      label,
      helpTips,
      feedbackStatus,
      extraInfo
    } = toRefs(props);
    const showFeedback = computed(() => (itemShowFeedback == null ? void 0 : itemShowFeedback.value) !== void 0 ? itemShowFeedback.value : formContext.showFeedback);
    const messageType = computed(() => (itemMessageType == null ? void 0 : itemMessageType.value) || formContext.messageType);
    const popPosition = computed(() => (itemPopPosition == null ? void 0 : itemPopPosition.value) || formContext.popPosition);
    const {
      _rules
    } = useFormItemRule(props);
    const {
      validateState,
      validateMessage,
      validate,
      resetField,
      clearValidate
    } = useFormItemValidate(props, _rules);
    const {
      itemClasses,
      isRequired
    } = useFormItem(messageType, _rules, validateState);
    const labelData = computed(() => ({
      layout: formContext.layout,
      labelSize: formContext.labelSize,
      labelAlign: formContext.labelAlign
    }));
    provide(LABEL_DATA, labelData);
    const context = reactive(__spreadProps(__spreadValues({}, otherProps), {
      showFeedback,
      messageType,
      popPosition,
      isRequired,
      validateState,
      validateMessage,
      validate,
      resetField,
      clearValidate
    }));
    provide(FORM_ITEM_TOKEN, context);
    ctx2.expose({
      resetField,
      clearValidate
    });
    onMounted(() => {
      if (props.field) {
        formContext == null ? void 0 : formContext.addItemContext(context);
      }
    });
    onBeforeUnmount(() => {
      formContext == null ? void 0 : formContext.removeItemContext(context);
    });
    return () => createVNode("div", {
      "class": itemClasses.value
    }, [createVNode(FormLabel, {
      "help-tips": helpTips.value
    }, {
      default: () => [label == null ? void 0 : label.value]
    }), createVNode(FormControl, {
      "feedback-status": feedbackStatus == null ? void 0 : feedbackStatus.value,
      "extra-info": extraInfo.value
    }, {
      default: () => {
        var _a2, _b;
        return [(_b = (_a2 = ctx2.slots).default) == null ? void 0 : _b.call(_a2)];
      }
    })]);
  }
});
var formOperation = "";
var FormOperation = defineComponent({
  name: "DFormOperation",
  setup(props, ctx2) {
    const formContext = inject(FORM_TOKEN);
    const LabelSizeMap = {
      sm: 80,
      md: 100,
      lg: 150
    };
    const styles = computed(() => ({
      marginLeft: formContext.layout === "horizontal" ? `${LabelSizeMap[formContext.labelSize] + 16}px` : void 0
    }));
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": "devui-form-operation",
        "style": styles.value
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var FormInstall = {
  title: "Form \u8868\u5355",
  category: "\u6570\u636E\u5F55\u5165",
  status: "75%",
  install(app) {
    app.component(Form.name, Form);
    app.component(FormItem.name, FormItem);
    app.component(FormOperation.name, FormOperation);
  }
};
function useAutoCompleteRender(props, ctx2, visible, isFocus, isDisabled, autoCompleteSize) {
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const ns2 = useNamespace("auto-complete");
  const inputNs = useNamespace("auto-complete-input");
  const slotNs = useNamespace("auto-complete-slot");
  const formNs = useNamespace("form-group");
  const feedbackNs = useNamespace("has-feedback");
  const selectNs = useNamespace("select-open");
  const formControlNs = useNamespace("form-control");
  const dropdownNs = useNamespace("dropdown-origin");
  const dropdownOpenNs = useNamespace("dropdown-origin-open");
  const slots = ctx2.slots;
  const isValidatorError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const autoCompleteTopClasses = computed(() => ({
    [ns2.b()]: true,
    [ns2.m(autoCompleteSize.value)]: true,
    [formNs.b()]: true,
    [feedbackNs.b()]: true,
    [selectNs.b()]: visible.value
  }));
  const inputClasses = computed(() => ({
    [inputNs.b()]: true,
    [ns2.m("focus")]: isFocus.value,
    [slotNs.b()]: slots.prepend || slots.append || props.prefix || props.suffix,
    [ns2.m("append")]: slots.append,
    [ns2.m("prepend")]: slots.prepend
  }));
  const inputWrapperClasses = computed(() => ({
    [inputNs.e("wrapper")]: true,
    [inputNs.em("wrapper", "error")]: isValidatorError.value,
    [inputNs.em("wrapper", "feedback")]: Boolean(formItemContext == null ? void 0 : formItemContext.validateState) && (formItemContext == null ? void 0 : formItemContext.showFeedback),
    [ns2.m("disabled")]: isDisabled.value
  }));
  const inputInnerClasses = computed(() => [
    {
      [formControlNs.b()]: true,
      [dropdownNs.b()]: true,
      [dropdownOpenNs.b()]: isFocus.value,
      ["disabled"]: isDisabled.value
    }
  ]);
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.log(err));
  });
  return { autoCompleteTopClasses, inputClasses, inputWrapperClasses, inputInnerClasses };
}
class View {
  constructor() {
    __publicField(this, "top", "50%");
    __publicField(this, "left", "50%");
  }
}
const loadingProps = {
  message: String,
  backdrop: Boolean,
  view: {
    type: Object,
    default: () => new View()
  },
  zIndex: Number,
  isFull: {
    type: Boolean,
    default: false
  }
};
class LoadingOptions {
  constructor() {
    __publicField(this, "target");
    __publicField(this, "message");
    __publicField(this, "loadingTemplateRef");
    __publicField(this, "backdrop", true);
    __publicField(this, "positionType", "relative");
    __publicField(this, "view", new View());
    __publicField(this, "zIndex");
  }
}
var loading$1 = "";
var Loading = defineComponent({
  name: "Loading",
  inheritAttrs: false,
  props: loadingProps,
  setup(props) {
    const style = {
      top: props.view.top,
      left: props.view.left,
      zIndex: props.zIndex
    };
    if (!props.message) {
      style.background = "none";
    }
    const isShow = ref(false);
    const open2 = () => {
      isShow.value = true;
    };
    const close2 = () => {
      isShow.value = false;
    };
    return {
      style,
      isShow,
      open: open2,
      close: close2
    };
  },
  render() {
    var _a;
    const {
      isShow,
      isFull,
      backdrop,
      style,
      message: message2,
      $slots
    } = this;
    const ns2 = useNamespace("loading");
    return isShow && createVNode("div", {
      "class": [ns2.b(), isFull ? ns2.m("full") : ""]
    }, [((_a = $slots.default) == null ? void 0 : _a.call($slots)) || createVNode("div", {
      "class": ns2.e("wrapper")
    }, [backdrop ? createVNode("div", {
      "class": ns2.e("mask")
    }, null) : null, createVNode("div", {
      "style": style,
      "class": ns2.e("area")
    }, [createVNode("div", {
      "class": ns2.e("busy-default-spinner")
    }, [createVNode("div", {
      "class": ns2.e("bar1")
    }, null), createVNode("div", {
      "class": ns2.e("bar2")
    }, null), createVNode("div", {
      "class": ns2.e("bar3")
    }, null), createVNode("div", {
      "class": ns2.e("bar4")
    }, null)]), message2 ? createVNode("span", {
      "class": ns2.e("text")
    }, [message2]) : null])])]);
  }
});
const COMPONENT_CONTAINER_SYMBOL = Symbol("dev_component_container");
function createComponent$1(component, props, children = null) {
  const vnode = h(component, __spreadValues({}, props), children);
  const container = document.createElement("div");
  vnode[COMPONENT_CONTAINER_SYMBOL] = container;
  render(vnode, container);
  return vnode.component;
}
function unmountComponent(ComponnetInstance) {
  render(null, ComponnetInstance == null ? void 0 : ComponnetInstance.vnode[COMPONENT_CONTAINER_SYMBOL]);
}
const loadingConstructor$1 = defineComponent(Loading);
const cacheInstance = /* @__PURE__ */ new WeakSet();
const isEmpty = (val) => {
  if (!val) {
    return true;
  }
  if (Array.isArray(val)) {
    return val.length === 0;
  }
  if (val instanceof Set || val instanceof Map) {
    return val.size === 0;
  }
  if (val instanceof Promise) {
    return false;
  }
  if (typeof val === "object") {
    try {
      return Object.keys(val).length === 0;
    } catch (e) {
      return false;
    }
  }
  return false;
};
const getType = (vari) => {
  return Object.prototype.toString.call(vari).slice(8, -1).toLowerCase();
};
const isPromise = (value) => {
  const type4 = getType(value);
  switch (type4) {
    case "promise":
      return [value];
    case "array":
      if (value.some((val) => getType(val) !== "promise")) {
        console.error(new TypeError("Binding values should all be of type Promise"));
        return "error";
      }
      return value;
    default:
      return false;
  }
};
const unmount = (el) => {
  cacheInstance.delete(el);
  el.instance.proxy.close();
  unmountComponent(el.instance);
};
const toggleLoading = (el, binding) => {
  var _a, _b, _c;
  if (binding.value) {
    const vals = isPromise(binding.value);
    if (vals === "error") {
      return;
    }
    (_c = (_b = (_a = el == null ? void 0 : el.instance) == null ? void 0 : _a.proxy) == null ? void 0 : _b.open) == null ? void 0 : _c.call(_b);
    el.appendChild(el.mask);
    cacheInstance.add(el);
    if (vals) {
      Promise.all(vals).catch((err) => {
        console.error(new Error("Promise handling errors"), err);
      }).finally(() => {
        unmount(el);
      });
    }
  } else {
    unmount(el);
  }
};
const removeAttribute = (el) => {
  el.removeAttribute("zindex");
  el.removeAttribute("positiontype");
  el.removeAttribute("backdrop");
  el.removeAttribute("message");
  el.removeAttribute("view");
  el.removeAttribute("loadingtemplateref");
};
const handleProps = (el, vprops) => {
  var _a;
  const props = __spreadValues(__spreadValues({}, new LoadingOptions()), vprops);
  const loadingTemplateRef = props.loadingTemplateRef;
  const loadingInstance = createComponent$1(loadingConstructor$1, __spreadValues({}, props), loadingTemplateRef ? () => loadingTemplateRef : null);
  el.style.position = props.positionType || "relative";
  el.options = props;
  el.instance = loadingInstance;
  el.mask = (_a = loadingInstance == null ? void 0 : loadingInstance.proxy) == null ? void 0 : _a.$el;
};
const LoadingDirective = {
  mounted: function(el, binding, vnode) {
    handleProps(el, vnode.props);
    removeAttribute(el);
    !isEmpty(binding.value) && toggleLoading(el, binding);
  },
  updated: function(el, binding, vnode) {
    if (!isEmpty(binding.value) && cacheInstance.has(el) || isEmpty(binding.value) && !cacheInstance.has(el)) {
      return;
    }
    !cacheInstance.has(el) && handleProps(el, vnode.props);
    removeAttribute(el);
    toggleLoading(el, binding);
  }
};
var DAutoCompleteDropdown = defineComponent({
  name: "DAutoCompleteDropdown",
  directives: {
    Loading: LoadingDirective
  },
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DAutoCompleteDropdown", app);
    const propsData = inject(DropdownPropsKey);
    const {
      visible,
      isDisabled,
      selectedIndex,
      selectOptionClick,
      searchList,
      searchStatus,
      dropDownRef,
      loadMore,
      showLoading,
      showNoResultItemTemplate,
      latestSource,
      modelValue,
      hoverIndex,
      valueParser
    } = propsData;
    const {
      maxHeight,
      formatter,
      disabledKey,
      isSearching
    } = propsData.props;
    const ns2 = useNamespace("auto-complete");
    const noDataNs = useNamespace("no-data-tip");
    const dropdownMenuNs = useNamespace("dropdown-menu");
    const dropdownItemNs = useNamespace("dropdown-item");
    const onSelect = (item) => {
      item = valueParser.value(item);
      if (typeof item === "object" && item[disabledKey]) {
        return;
      }
      selectOptionClick(item);
    };
    return () => {
      return withDirectives(createVNode("div", {
        "class": [dropdownMenuNs.b(), ns2.e("dropdown-menu-cdk"), isDisabled.value && "disabled", latestSource.value && ns2.e("dropdown-latestSource")]
      }, [createVNode("ul", {
        "ref": dropDownRef,
        "class": [ns2.e("list-unstyled"), "scroll-height"],
        "style": {
          maxHeight: `${maxHeight}px`
        },
        "onScroll": loadMore
      }, [isSearching && ctx2.slots.searchingTemplate && (searchStatus == null ? void 0 : searchStatus.value) && createVNode("li", {
        "class": ns2.e("searching-template")
      }, [createVNode("div", {
        "class": noDataNs.b()
      }, [ctx2.slots.searchingTemplate()])]), latestSource.value && !modelValue.value && createVNode("li", {
        "class": ns2.e("popup-tips")
      }, [t("latestInput")]), !showNoResultItemTemplate.value && !(searchStatus == null ? void 0 : searchStatus.value) && searchList != null && searchList.value.length > 0 && searchList.value.map((item, index2) => {
        return createVNode("li", {
          "onClick": () => onSelect(item),
          "class": [dropdownItemNs.b(), selectedIndex.value === index2 && "selected", {
            disabled: disabledKey && typeof item === "object" && item[disabledKey]
          }, {
            [ns2.e("dropdown-bg")]: hoverIndex.value === index2
          }],
          "title": formatter(item),
          "key": formatter(item)
        }, [ctx2.slots.itemTemplate ? ctx2.slots.itemTemplate(item, index2) : formatter(item)]);
      }), !(searchStatus == null ? void 0 : searchStatus.value) && searchList.value.length === 0 && ctx2.slots.noResultItemTemplate && showNoResultItemTemplate.value && createVNode("li", {
        "class": ns2.e("no-result-template")
      }, [createVNode("div", {
        "class": noDataNs.b()
      }, [ctx2.slots.noResultItemTemplate()])])])]), [[resolveDirective("loading"), showLoading.value], [vShow, visible.value && searchList.value.length > 0 || ctx2.slots.noResultItemTemplate && showNoResultItemTemplate.value || isSearching && ctx2.slots.searchingTemplate && (searchStatus == null ? void 0 : searchStatus.value)]]);
    };
  }
});
function on(element, eventName, handler) {
  if (document.addEventListener) {
    if (element && eventName && handler) {
      element.addEventListener(eventName, handler, false);
    }
  } else {
    if (element && eventName && handler) {
      element.attachEvent("on" + eventName, handler);
    }
  }
}
function off(element, eventName, handler) {
  if (document.removeEventListener) {
    if (element && eventName && handler) {
      element.removeEventListener(eventName, handler, false);
    }
  } else {
    if (element && eventName && handler) {
      element.detachEvent("on" + eventName, handler);
    }
  }
}
const ctx = Symbol("@@clickoutside");
const nodeList = /* @__PURE__ */ new Map();
let startClick;
let nid = 0;
let isFirst = true;
function createDocumentHandler(el, binding, vnode) {
  if (inBrowser && isFirst) {
    isFirst = false;
    on(document, "mousedown", (e) => {
      startClick = e;
    });
    on(document, "mouseup", (e) => {
      for (const [id, node] of nodeList) {
        node[ctx].documentHandler(e, startClick);
      }
    });
  }
  return function(mouseup, mousedown) {
    if (!vnode || !binding.instance || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target) {
      return;
    }
    el[ctx].bindingFn && el[ctx].bindingFn();
  };
}
const clickoutsideDirective = {
  beforeMount: function(el, binding, vnode) {
    nid++;
    nodeList.set(nid, el);
    el[ctx] = {
      nid,
      documentHandler: createDocumentHandler(el, binding, vnode),
      bindingFn: binding.value
    };
  },
  updated: function(el, binding, vnode) {
    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);
    el[ctx].bindingFn = binding.value;
  },
  unmounted: function(el) {
    nodeList.delete(el[ctx].nid);
    delete el[ctx];
  }
};
var autoComplete = "";
const DEFAULT_PREFIX = "icon";
const iconProps = {
  name: {
    type: String,
    default: "",
    required: true
  },
  size: {
    type: [Number, String],
    default: "inherit"
  },
  color: {
    type: String,
    default: "inherit"
  },
  component: {
    type: Object,
    default: null
  },
  classPrefix: {
    type: String,
    default: DEFAULT_PREFIX
  },
  operable: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  rotate: {
    type: [Number, String]
  }
};
const svgIconProps = {
  name: {
    type: String,
    default: "",
    required: true
  },
  color: {
    type: String,
    default: "inherit"
  },
  size: {
    type: [Number, String],
    default: "inherit"
  }
};
var icon = "";
var svgIcon = defineComponent({
  name: "DSvgIcon",
  props: svgIconProps,
  setup(props) {
    const {
      name,
      color: color2,
      size
    } = toRefs(props);
    const ns2 = useNamespace("svg-icon");
    const iconName = computed(() => `#icon-${name.value}`);
    const iconSize = computed(() => {
      return typeof size.value === "number" ? `${size.value}px` : size.value;
    });
    const styles = {
      width: iconSize.value,
      height: iconSize.value
    };
    return () => {
      return createVNode("svg", {
        "class": ns2.b(),
        "style": styles
      }, [createVNode("use", {
        "xlink:href": iconName.value,
        "fill": color2.value
      }, null)]);
    };
  }
});
function isUrl(value) {
  return /^((http|https):)?\/\//.test(value);
}
function isBase64(value) {
  return /^data:image\/.*;base64,/.test(value);
}
function useIconDom(props, ctx2) {
  const {
    component,
    name,
    size,
    color: color2,
    classPrefix,
    rotate
  } = toRefs(props);
  const ns2 = useNamespace("icon");
  const iconSize = computed(() => {
    return typeof size.value === "number" ? `${size.value}px` : size.value;
  });
  const IconComponent = component.value ? resolveDynamicComponent(component.value) : resolveDynamicComponent(svgIcon);
  const imgIconDom = () => {
    return createVNode("img", mergeProps({
      "src": name.value,
      "alt": name.value.split("/")[name.value.split("/").length - 1],
      "class": [(rotate == null ? void 0 : rotate.value) === "infinite" && ns2.m("spin")],
      "style": {
        width: iconSize.value || "",
        transform: `rotate(${rotate == null ? void 0 : rotate.value}deg)`,
        verticalAlign: "middle"
      }
    }, ctx2.attrs), null);
  };
  const svgIconDom = () => {
    return createVNode(IconComponent, mergeProps({
      "name": name.value,
      "color": color2.value,
      "size": iconSize.value,
      "class": [(rotate == null ? void 0 : rotate.value) === "infinite" && ns2.m("spin")],
      "style": {
        transform: `rotate(${rotate == null ? void 0 : rotate.value}deg)`
      }
    }, ctx2.attrs), null);
  };
  const fontIconDom = () => {
    const fontIconClass = /^icon-/.test(name.value) ? name.value : `${classPrefix.value}-${name.value}`;
    return createVNode("i", mergeProps({
      "class": [classPrefix.value, fontIconClass, (rotate == null ? void 0 : rotate.value) === "infinite" && ns2.m("spin")],
      "style": {
        fontSize: iconSize.value,
        color: color2.value,
        transform: `rotate(${rotate == null ? void 0 : rotate.value}deg)`
      }
    }, ctx2.attrs), null);
  };
  const iconDom = () => {
    return component.value ? svgIconDom() : isUrl(name.value) ? imgIconDom() : fontIconDom();
  };
  return {
    iconDom
  };
}
var DIcon = defineComponent({
  name: "DIcon",
  props: iconProps,
  emits: ["click"],
  setup(props, ctx2) {
    const {
      disabled,
      operable
    } = toRefs(props);
    const {
      iconDom
    } = useIconDom(props, ctx2);
    const ns2 = useNamespace("icon");
    const wrapClassed = computed(() => ({
      [ns2.e("container")]: true,
      [ns2.m("disabled")]: disabled.value,
      [ns2.m("operable")]: operable.value,
      [ns2.m("no-slots")]: !Object.keys(ctx2.slots).length
    }));
    const onClick = (e) => {
      if (disabled.value) {
        return;
      }
      ctx2.emit("click", e);
    };
    return () => {
      var _a, _b, _c, _d;
      return createVNode("div", {
        "class": wrapClassed.value,
        "onClick": onClick
      }, [(_b = (_a = ctx2.slots).prefix) == null ? void 0 : _b.call(_a), iconDom(), (_d = (_c = ctx2.slots).suffix) == null ? void 0 : _d.call(_c)]);
    };
  }
});
var iconGroup = "";
var IconGroup = defineComponent({
  name: "DIconGroup",
  setup(_, ctx2) {
    const ns2 = useNamespace("icon-group");
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": ns2.b()
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var IconInstall = {
  title: "Icon \u56FE\u6807",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.component(DIcon.name, DIcon);
    app.component(IconGroup.name, IconGroup);
  }
};
function _isSlot$b(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var AutoComplete = defineComponent({
  name: "DAutoComplete",
  directives: {
    ClickOutside: clickoutsideDirective
  },
  props: autoCompleteProps,
  emits: ["update:modelValue", "clear", "blur"],
  setup(props, ctx2) {
    const formContext = inject(FORM_TOKEN, void 0);
    const {
      disabled,
      modelValue,
      width,
      delay,
      allowEmptyValueSearch,
      appendToBody,
      formatter,
      transInputFocusEmit,
      selectValue,
      source,
      searchFn,
      position,
      latestSource,
      showAnimation,
      valueParser,
      placeholder
    } = toRefs(props);
    const ns2 = useNamespace("auto-complete");
    const inputNs = useNamespace("auto-complete-input");
    const isDisabled = computed(() => (formContext == null ? void 0 : formContext.disabled) || disabled.value);
    const autoCompleteSize = computed(() => (formContext == null ? void 0 : formContext.size) || props.size);
    const {
      handleSearch,
      searchList,
      showNoResultItemTemplate,
      recentlyFocus
    } = useSearchFn(ctx2, allowEmptyValueSearch, source, searchFn, formatter);
    const {
      onInput,
      onFocus,
      onBlur,
      onClear,
      inputRef,
      isFocus,
      visible,
      searchStatus,
      handleClose,
      toggleMenu
    } = useInputHandle(ctx2, searchList, showNoResultItemTemplate, modelValue, isDisabled, delay, handleSearch, transInputFocusEmit, recentlyFocus, latestSource);
    const {
      selectedIndex,
      selectOptionClick
    } = useSelectHandle(ctx2, searchList, selectValue, handleSearch, formatter, handleClose);
    const {
      showLoading,
      dropDownRef,
      loadMore
    } = useLazyHandle(props, ctx2, handleSearch);
    const {
      customRenderSolts
    } = useCustomTemplate(ctx2, modelValue);
    const {
      hoverIndex,
      handlekeyDown
    } = useKeyBoardHandle(dropDownRef, visible, searchList, selectedIndex, searchStatus, showNoResultItemTemplate, selectOptionClick, handleClose);
    const {
      autoCompleteTopClasses,
      inputClasses,
      inputWrapperClasses,
      inputInnerClasses
    } = useAutoCompleteRender(props, ctx2, visible, isFocus, isDisabled, autoCompleteSize);
    provide(DropdownPropsKey, {
      props,
      visible,
      isDisabled,
      term: "",
      searchList,
      selectedIndex,
      searchStatus,
      selectOptionClick,
      dropDownRef,
      showLoading,
      loadMore,
      latestSource,
      modelValue,
      showNoResultItemTemplate,
      hoverIndex,
      valueParser
    });
    const origin = ref();
    const prefixVisible = ctx2.slots.prefix || props.prefix;
    const suffixVisible = ctx2.slots.suffix || props.suffix || props.clearable;
    const showClearable = computed(() => props.clearable && !isDisabled.value);
    const renderBasicDropdown = () => {
      let _slot;
      return createVNode(Transition, {
        "name": showAnimation ? "fade" : ""
      }, {
        default: () => [createVNode(FlexibleOverlay, {
          "origin": origin.value,
          "position": position.value,
          "modelValue": visible.value,
          "onUpdate:modelValue": ($event) => visible.value = $event,
          "style": {
            zIndex: "var(--b-z-index-dropdown, 1052)"
          }
        }, {
          default: () => [createVNode("div", {
            "class": ns2.e("menu"),
            "style": {
              width: `
                      ${width.value + "px"}
                    `
            }
          }, [createVNode(DAutoCompleteDropdown, null, _isSlot$b(_slot = customRenderSolts()) ? _slot : {
            default: () => [_slot]
          })])]
        })]
      });
    };
    const renderDropdown = () => {
      if (appendToBody.value) {
        let _slot2;
        return createVNode(Teleport, {
          "to": "body"
        }, _isSlot$b(_slot2 = renderBasicDropdown()) ? _slot2 : {
          default: () => [_slot2]
        });
      } else {
        return renderBasicDropdown();
      }
    };
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return withDirectives(createVNode("div", {
        "class": autoCompleteTopClasses.value,
        "ref": origin,
        "style": {
          width: `${width.value + "px"}`
        }
      }, [createVNode("div", {
        "class": inputClasses.value
      }, [ctx2.slots.prepend && createVNode("div", {
        "class": inputNs.e("prepend")
      }, [(_b = (_a = ctx2.slots).prepend) == null ? void 0 : _b.call(_a)]), createVNode("div", {
        "class": inputWrapperClasses.value
      }, [prefixVisible && createVNode("span", {
        "class": inputNs.e("prefix")
      }, [ctx2.slots.prefix && ((_d = (_c = ctx2.slots).prefix) == null ? void 0 : _d.call(_c)), props.prefix && createVNode(DIcon, {
        "size": "inherit",
        "name": props.prefix
      }, null)]), createVNode("input", {
        "disabled": isDisabled.value,
        "type": "text",
        "onClick": toggleMenu,
        "class": inputInnerClasses.value,
        "placeholder": placeholder.value,
        "onInput": onInput,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "value": modelValue.value,
        "ref": inputRef,
        "onKeydown": handlekeyDown
      }, null), suffixVisible && createVNode("span", {
        "class": inputNs.e("suffix")
      }, [props.suffix && createVNode(DIcon, {
        "size": "inherit",
        "name": props.suffix
      }, null), ctx2.slots.suffix && ((_f = (_e = ctx2.slots).suffix) == null ? void 0 : _f.call(_e)), showClearable.value && createVNode(DIcon, {
        "size": autoCompleteSize.value,
        "class": ns2.em("clear", "icon"),
        "name": "close",
        "onClick": onClear
      }, null)])]), ctx2.slots.append && createVNode("div", {
        "class": inputNs.e("append")
      }, [(_h = (_g = ctx2.slots).append) == null ? void 0 : _h.call(_g)])]), renderDropdown()]), [[resolveDirective("click-outside"), handleClose]]);
    };
  }
});
var AutoCompleteInstall = {
  title: "AutoComplete \u81EA\u52A8\u8865\u5168",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(AutoComplete.name, AutoComplete);
  }
};
const IconBody = (props) => {
  const {
    width,
    height
  } = props;
  return createVNode("svg", {
    "style": {
      width: `${width}px`,
      height: `${height}px`,
      verticalAlign: "middle"
    },
    "viewBox": "0 0 30 30",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "id": "\u672A\u547D\u540D",
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("circle", {
    "id": "Oval",
    "fill": "#CACFD8",
    "cx": "15",
    "cy": "15",
    "r": "15"
  }, null), createVNode("path", {
    "d": "M14.9997866,16 C12.5145053,16 10.4997866,13.9852814 10.4997866,            11.5 C10.4997866,9.01471863 12.5145053,7 14.9997866,7 C17.485068,            7 19.4997866,9.01471863 19.4997866,11.5 C19.4997866,13.9852814 17.485068,            16 14.9997866,16 Z M23,23 L7,22.998553 C7,19.0122153 10.8892296,            16.5 14.9997866,16.5 C19.1103437,16.5 23,20 23,23 Z",
    "id": "\u5F62\u72B6\u7ED3\u5408",
    "fill": "#FFFFFF"
  }, null)])]);
};
var AvatarBodyIcon = defineComponent({
  name: "AvatarBodyIcon",
  props: {
    width: {
      type: Number,
      default: 16
    },
    height: {
      type: Number,
      default: 16
    }
  },
  render() {
    const {
      width,
      height
    } = this;
    return createVNode(IconBody, {
      "width": width,
      "height": height
    }, null);
  }
});
const IconNobody = (props) => {
  const {
    width,
    height
  } = props;
  return createVNode("svg", {
    "style": {
      width: `${width}px`,
      height: `${height}px`,
      verticalAlign: "middle"
    },
    "viewBox": "0 0 30 30",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M22.31,19.2474562 L22.31,21.9974562 L20.81,21.9974562 L20.81,            19.2474562 L18.06,19.2474562 L18.06,17.7474562 L20.81,17.7474562 L20.81,            14.9974562 L22.31,14.9974562 L22.31,17.7474562 L25.06,17.7474562 L25.06,            19.2474562 L22.31,19.2474562 Z M14.9297866,14.9974562 C12.4445053,            14.9974562 10.4297866,12.9827376 10.4297866,10.4974562 C10.4297866,            8.01217483 12.4445053,5.9974562 14.9297866,5.9974562 C17.415068,            5.9974562 19.4297866,8.01217483 19.4297866,10.4974562 C19.4297866,            12.9827376 17.415068,14.9974562 14.9297866,14.9974562 Z M19.6797866,            20.2474562 L19.6797866,21.9971623 L6.93,21.9960092 C6.93,18.0096715 10.8192296,            15.4974562 14.9297866,15.4974562 C16.4608397,15.4974562 17.9612467,15.983021 19.2414296,            16.7474562 L17.06,16.7474562 L17.06,20.2474562 L19.6797866,20.2474562 Z",
    "id": "\u5F62\u72B6\u7ED3\u5408",
    "fill": "#959EB2"
  }, null), createVNode("path", {
    "d": "M0,15 L1,15 C1,15.6118966 1.03919561,16.2186526 1.11683409,            16.8178549 L0.125124012,16.9463505 C0.0425740367,16.309242 0,            15.6595925 0,15 Z M0.503241262,18.867175 L1.46961749,18.6100428 C1.62594651,            19.1975718 1.8203704,19.7729973 2.05141295,20.3332823 L1.12693074,            20.7145074 C0.880599065,20.1171459 0.67172715,19.500393 0.503241262,            18.867175 Z M1.99122134,22.4730778 L2.85786221,21.9741453 C3.16078316,            22.5003161 3.49772502,23.0063252 3.86631639,23.4889602 L3.0715754,            24.0959089 C2.6777461,23.5802273 2.31659753,23.0382531 1.99122134,            22.4730778 Z M4.38894559,25.6021078 L5.09634867,24.8952974 C5.52582519,            25.3251341 5.98272136,25.7268214 6.46397085,26.0975793 L5.85367498,            26.8897529 C5.33779918,26.4923186 4.84851395,26.0620615 4.38894559,            25.6021078 Z M7.4424647,27.9597887 L7.94703323,27.096417 C8.47111119,            27.4026968 9.0146817,27.6746032 9.57453904,27.9101878 L9.18668461,            28.8319084 C8.58423501,28.5784013 8.00181692,28.2866833 7.4424647,            27.9597887 Z M11.0671021,29.4791103 L11.3286494,28.5139196 C11.9126912,            28.6721832 12.5080563,28.7925378 13.1119738,28.8738935 L12.9784667,            29.8649413 C12.3271613,29.7772019 11.6891102,29.647662 11.0671021,            29.4791103 Z M15,30 C14.9951965,30 14.9903936,29.9999977 14.9855912,            30 L14.9865313,28.9999937 C14.9929361,28.9999987 14.9929361,            28.9999987 14.999296,29 C15.6071552,29 16.2093364,28.9614092 16.8041774,            28.8849313 L16.9316965,29.8767674 C16.2992813,29.9580762 15.6545362,            30 15,30 Z M18.8545762,29.5001051 L18.5982903,28.5335041 C19.1860387,            28.3776677 19.7617059,28.1837179 20.3222555,27.9531286 L20.7026875,            28.8779375 C20.1050484,29.123784 19.4880358,29.3321488 18.8545762,            29.5001051 Z M22.4608087,28.0158343 L21.9626951,27.1487226 C22.4893928,            26.8461604 22.9959399,26.5095265 23.479119,26.1411926 L24.0853678,            26.9364676 C23.5691101,27.3300178 23.0265585,27.6908386 22.4608087,            28.0158343 Z M25.5921583,25.6209863 L24.8860071,24.9129252 C25.3161421,            24.4839504 25.7181674,24.0275419 26.0893023,23.5467621 L26.8808873,            24.1578212 C26.4830546,24.6731862 26.0524368,25.1619493 25.5921583,            25.6209863 Z M27.9526445,22.5697466 L27.0897495,22.0643633 C27.3964738,            21.5406601 27.6688549,20.9974409 27.904942,20.4379104 L28.8262855,            20.8266601 C28.5722411,21.4287497 28.2800163,22.0107897 27.9526445,            22.5697466 Z M29.4756977,18.9454696 L28.5107363,18.6830777 C28.6695136,            18.099165 28.7903877,17.5039035 28.8722662,16.9000659 L29.8631978,            17.0344333 C29.7748946,17.6856516 29.6447979,18.3235936 29.4756977,            18.9454696 Z M30,15 C30,15.0093541 29.9999914,15.0187063 29.9999743,            15.0280564 L28.999976,15.0262257 C28.9999956,15.0134169 28.9999956,            15.0134169 29,15.0006466 C29,14.3970304 28.9619395,13.7989704 28.8865088,            13.208136 L29.8784576,13.0814959 C29.9586571,13.7096843 30,14.3500145 30,            15 Z M29.5038108,11.1594275 L28.5369608,11.4147728 C28.3816616,            10.8267413 28.1882232,10.2507676 27.9581175,9.68988857 L28.8832852,            9.31033004 C29.1286141,9.90831524 29.3364318,10.5256569 29.5038108,            11.1594275 Z M28.0228788,7.55146763 L27.1552968,8.0487618 C26.853241,            7.52179373 26.5170958,7.0149453 26.1492295,6.53143425 L26.9450761,            5.92593594 C27.3381231,6.44254364 27.6984223,6.98541919 28.0228788,            7.55146763 Z M25.6309089,4.41780044 L24.9221905,5.12329189 C24.4935639,            4.69270467 24.0374698,4.2902078 23.5569705,3.9185855 L24.1687554,            3.12756133 C24.6838129,3.52591118 25.1722392,3.95703271 25.6309089,            4.41780044 Z M22.5819506,2.05451093 L22.0757531,2.91692851 C21.5523008,            2.60968727 21.0092999,2.33677531 20.4499564,2.10014728 L20.8395722,            1.17916981 C21.4414531,1.43379309 22.0232574,1.72658499 22.5819506,            2.05451093 Z M18.9594329,0.528106464 L18.696103,1.4928123 C18.1122842,            1.33345081 17.517086,1.21199245 16.9132846,1.12953261 L17.0485964,            0.138729543 C17.6997753,0.227659622 18.3376514,0.358382523 18.9594329,            0.528106464 Z M15,-1.11022302e-16 C15.0139048,-1.11022302e-16 15.0278052,            1.892004e-05 15.0417011,5.673578e-05 L15.0389797,1.00005303 C15.0197685,            1.00000934 15.0197685,1.00000934 15.0005868,1.00000001 C14.4012162,            1 13.8072783,1.03753392 13.2204527,1.11192427 L13.0946918,0.119863691 C13.7186509,            0.0407660189 14.3545651,-1.11022302e-16 15,-1.11022302e-16 Z M11.1720354,            0.492865376 L11.4265338,1.45993857 C10.8386468,1.61464899 10.2627801,            1.80746996 9.70196444,2.03693489 L9.32327455,1.11141127 C9.92118954,            0.86676666 10.5384173,0.659610554 11.1720354,0.492865376 Z M7.56375123,            1.97008801 L8.06022548,2.83813946 C7.53298826,3.13968806 7.02583975,            3.47534367 6.54199783,3.84274131 L5.93725081,3.04632368 C6.4542073,            2.65378102 6.99740556,2.29400434 7.56375123,1.97008801 Z M4.42776842,            4.35917772 L5.13259949,5.06855291 C4.70156141,5.49682984 4.29859416,            5.95260763 3.92648544,6.43282469 L3.13602297,5.82031423 C3.53488885,            5.30556625 3.96651291,4.81747851 4.42776842,4.35917772 Z M2.0616775,            7.40585279 L2.92361696,7.91286401 C2.61586086,8.43606175 2.34241977,            8.97884042 2.10525197,9.53799293 L1.18464153,9.14751063 C1.43984243,            8.54584288 1.73319965,7.96427837 2.0616775,7.40585279 Z M0.531541456,            11.0280046 L1.49601653,11.2921785 C1.33614878,11.8758413 1.21417484,            12.4709081 1.13119244,13.074601 L0.140507978,12.9384235 C0.230001486,            12.2873626 0.361276825,11.6496255 0.531541456,11.0280046 Z",
    "id": "\u8499\u7248",
    "fill": "#CACFD8",
    "fill-rule": "nonzero"
  }, null)])]);
};
var AvatarNoBodyIcon = defineComponent({
  name: "AvatarNobodyIcon",
  props: {
    width: {
      type: Number,
      default: 16
    },
    height: {
      type: Number,
      default: 16
    }
  },
  render() {
    const {
      width,
      height
    } = this;
    return createVNode(IconNobody, {
      "width": width,
      "height": height
    }, null);
  }
});
const avatarProps = {
  name: {
    type: String,
    default: null
  },
  gender: {
    type: String,
    default: null
  },
  width: {
    type: Number,
    default: 36
  },
  height: {
    type: Number,
    default: 36
  },
  isRound: {
    type: Boolean,
    default: true
  },
  imgSrc: {
    type: String,
    default: ""
  },
  customText: {
    type: String,
    default: null
  }
};
var avatar = "";
var Avatar = defineComponent({
  name: "DAvatar",
  props: avatarProps,
  setup(props) {
    const {
      name,
      width,
      height,
      customText,
      gender,
      imgSrc,
      isRound
    } = toRefs(props);
    const isNobody = ref(true);
    const isErrorImg = ref(false);
    const fontSize = ref(12);
    const code = ref(1);
    const nameDisplay = ref();
    const ns2 = useNamespace("avatar");
    const styleNS = ns2.e("style");
    const bgNS = computed(() => {
      return ns2.m(`${"background-" + code.value}`);
    });
    const getBackgroundColor = (char) => {
      if (gender.value) {
        if (gender.value.toLowerCase() === "male") {
          code.value = 1;
        } else if (gender.value.toLowerCase() === "female") {
          code.value = 0;
        } else {
          console.warn('gender must be "Male" or "Female"');
        }
        return;
      }
      const unicode = char.charCodeAt(0);
      code.value = unicode % 2;
    };
    const setDisplayName = (nameValue, widthValue) => {
      if (customText.value) {
        nameDisplay.value = customText.value;
        getBackgroundColor(customText.value.substr(0, 1));
        return;
      }
      if (nameValue.length < 2) {
        nameDisplay.value = nameValue;
      } else {
        if (/^[\u4e00-\u9fa5]/.test(nameValue)) {
          nameDisplay.value = nameValue.substr(nameValue.length - 2, 2);
        } else if (/^[A-Za-z]/.test(nameValue)) {
          if (/[_ -]/.test(nameValue)) {
            const str_before = nameValue.split(/_|-|\s+/)[0];
            const str_after = nameValue.split(/_|-|\s+/)[1];
            nameDisplay.value = str_before.substr(0, 1).toUpperCase() + str_after.substr(0, 1).toUpperCase();
          } else {
            nameDisplay.value = nameValue.substr(0, 2).toUpperCase();
          }
        } else {
          nameDisplay.value = nameValue.substr(0, 2);
        }
      }
      if (widthValue < 30) {
        nameDisplay.value = nameValue.substr(0, 1).toUpperCase();
      }
      getBackgroundColor(nameValue.substr(0, 1));
    };
    const showErrorAvatar = () => {
      isErrorImg.value = true;
    };
    const calcValues = (nameInput) => {
      const userName = nameInput;
      const minNum = Math.min(width.value, height.value);
      if (userName) {
        isNobody.value = false;
        setDisplayName(userName, minNum);
      } else if (userName === "") {
        isNobody.value = false;
        nameDisplay.value = "";
      } else {
        isNobody.value = true;
      }
      fontSize.value = minNum / 4 + 3;
    };
    calcValues(customText.value ? customText.value : name.value);
    watch([name, width, height, customText, gender], () => {
      calcValues(customText.value ? customText.value : name.value);
    });
    return () => {
      var _a, _b;
      const imgElement = createVNode("img", {
        "src": imgSrc.value,
        "alt": "",
        "onError": showErrorAvatar,
        "style": {
          height: `${height.value}px`,
          width: `${width.value}px`,
          borderRadius: isRound.value ? "100%" : "0"
        }
      }, null);
      const hasImgSrc = imgSrc.value && !isErrorImg.value ? imgElement : null;
      const nameElement = createVNode("span", {
        "class": [styleNS, bgNS.value],
        "style": {
          height: `${height.value}px`,
          width: `${width.value}px`,
          lineHeight: `${height.value}px`,
          fontSize: `${fontSize.value}px`,
          borderRadius: isRound.value ? "100%" : "0"
        }
      }, [nameDisplay.value]);
      const hasNameDisplay = !imgSrc.value && !isNobody.value && ((_a = nameDisplay.value) == null ? void 0 : _a.length) !== 0 ? nameElement : null;
      const noNameElement = createVNode("span", {
        "class": styleNS,
        "style": {
          borderRadius: isRound.value ? "100%" : "0"
        }
      }, [createVNode(AvatarBodyIcon, {
        "width": width.value,
        "height": height.value
      }, null)]);
      const hasNoDisplayName = !imgSrc.value && !isNobody.value && ((_b = nameDisplay.value) == null ? void 0 : _b.length) === 0 ? noNameElement : null;
      const noBodyElement = createVNode("span", {
        "class": styleNS,
        "style": {
          borderRadius: isRound.value ? "100%" : "0"
        }
      }, [createVNode(AvatarNoBodyIcon, {
        "width": width.value,
        "height": height.value
      }, null)]);
      const noBody = !imgSrc.value && isNobody.value || isErrorImg.value ? noBodyElement : null;
      return createVNode("span", {
        "class": ns2.b()
      }, [hasImgSrc, hasNameDisplay, hasNoDisplayName, noBody]);
    };
  }
});
var AvatarInstall = {
  title: "Avatar \u5934\u50CF",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Avatar.name, Avatar);
  }
};
const backTopProps = {
  bottom: {
    type: String,
    default: "50px"
  },
  right: {
    type: String,
    default: "30px"
  },
  target: {
    type: String,
    default: "window"
  },
  visibleHeight: {
    type: Number,
    default: 300
  }
};
function usePosition(props) {
  const { bottom, right } = props;
  return {
    bottom,
    right
  };
}
function useTarget(props, backTopRef) {
  const target = props.target;
  const getTargetEl = () => {
    const targetEl = document.querySelector(target);
    if (!targetEl) {
      throw new Error(`props ${target} is not existed`);
    }
    if (targetEl.parentElement) {
      targetEl.parentElement.style.position = "relative";
    }
    if (backTopRef.value) {
      backTopRef.value.style.position = "absolute";
    }
    return targetEl;
  };
  const currTarget = target === "window" ? window || document.documentElement || document.body : getTargetEl();
  return currTarget;
}
function useVisibility(props, backTopRef) {
  const visibleHeight = props.visibleHeight;
  const currScrollTop = ref(0);
  let currTarget;
  const ThrottleCBFn = function() {
    currScrollTop.value = currTarget === window ? window.pageYOffset : currTarget.scrollTop;
  };
  onMounted(() => {
    currTarget = useTarget(props, backTopRef);
    useEventListener(currTarget, "scroll", useThrottle(ThrottleCBFn, 150));
  });
  const isVisible = computed(() => currScrollTop.value >= visibleHeight);
  return isVisible;
}
function useEventListener(target, event, cb) {
  if (target) {
    target.addEventListener(event, cb);
  }
}
function useThrottle(fn, delay) {
  let last = 0;
  return (...args) => {
    const now = +Date.now();
    if (now - last > delay) {
      last = now;
      return fn.apply(window, args);
    }
  };
}
var IconTop = "data:image/svg+xml;base64,PHN2ZyB0PSIxNjM2MjU2NTI0MjUxIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM0NTciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTAgMGgxMDI0djEwMjRIMHoiIGZpbGw9IiNmZmZmZmYiIGZpbGwtb3BhY2l0eT0iMCIgcC1pZD0iMzQ1OCI+PC9wYXRoPjxwYXRoIGQ9Ik04NzguOTMzMzMzIDY1OC40MTA2NjdhNDEuNjg1MzMzIDQxLjY4NTMzMyAwIDAgMS01OC45NDQgMC4zMmwtMzA3Ljk2OC0zMDQuNjRMMjA0LjAxMDY2NyA2NTguNzczMzMzYTQxLjY4NTMzMyA0MS42ODUzMzMgMCAwIDEtNTguNTYgMC4wNjQgNDAuNjE4NjY3IDQwLjYxODY2NyAwIDAgMS0wLjA2NC01Ny44MTMzMzNsMzM1LjQyNC0zMzEuNzMzMzMzYTQxLjU3ODY2NyA0MS41Nzg2NjcgMCAwIDEgMzEuMDQtMTIuMDEwNjY3IDQxLjQ5MzMzMyA0MS40OTMzMzMgMCAwIDEgMzEuMzYgMTEuOTg5MzMzbDMzNS40MDI2NjYgMzMxLjczMzMzNGMxNS45MzYgMTUuNzg2NjY3IDE2LjA4NTMzMyA0MS40OTMzMzMgMC4zMiA1Ny40MjkzMzN6IiBmaWxsPSIjZmZmZmZmIiBwLWlkPSIzNDU5Ij48L3BhdGg+PHBhdGggZD0iTTU1NC42NjY2NjcgMzYyLjY2NjY2N3Y1MzMuMzMzMzMzYTQyLjY2NjY2NyA0Mi42NjY2NjcgMCAxIDEtODUuMzMzMzM0IDBWMzYyLjY2NjY2N2E0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMSAxIDg1LjMzMzMzNCAwek0xMjggODUuMzMzMzMzaDc2OGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMSAxIDAgODUuMzMzMzM0SDEyOGE0Mi42NjY2NjcgNDIuNjY2NjY3IDAgMSAxIDAtODUuMzMzMzM0eiIgZmlsbD0iI2ZmZmZmZiIgcC1pZD0iMzQ2MCI+PC9wYXRoPjwvc3ZnPg==";
var backTop = "";
var BackTop = defineComponent({
  name: "DBackTop",
  props: backTopProps,
  setup(props, ctx2) {
    const slots = ctx2.slots;
    const backTopRef = ref(null);
    const ns2 = useNamespace("back-top");
    const position = usePosition(props);
    const isVisible = useVisibility(props, backTopRef);
    const scrollToTop = (e) => {
      const target = props.target === "window" ? window || document.documentElement || document.body : document.querySelector(props.target);
      target && target.scrollTo({
        top: 0,
        left: 0,
        behavior: "smooth"
      });
    };
    return () => createVNode("div", {
      "class": ns2.b(),
      "ref": backTopRef,
      "style": __spreadProps(__spreadValues({}, position), {
        display: isVisible.value ? "block" : "none"
      }),
      "onClick": scrollToTop
    }, [createVNode("div", {
      "class": [ns2.e("base"), slots.default ? ns2.e("custom") : ns2.e("content")]
    }, [slots.default ? slots.default() : createVNode(IconTop, null, null)])]);
  }
});
var BackTopInstall = {
  title: "BackTop \u56DE\u5230\u9876\u90E8",
  category: "\u5BFC\u822A",
  status: "60%",
  install(app) {
    app.component(BackTop.name, BackTop);
  }
};
const badgeStatusType = ["danger", "warning", "waiting", "success", "info", "common"];
const badgePositionType = ["top-left", "top-right", "bottom-left", "bottom-right"];
const badgeProps = {
  count: {
    type: [Number, String]
  },
  maxCount: {
    type: Number,
    default: 99
  },
  showDot: {
    type: Boolean,
    default: false
  },
  status: {
    type: String,
    validator: (val) => badgeStatusType.includes(val),
    default: "info"
  },
  position: {
    type: String,
    default: "top-right",
    validator: (val) => badgePositionType.includes(val)
  },
  offset: {
    type: Array
  },
  bgColor: {
    type: String
  },
  textColor: {
    type: String
  },
  hidden: {
    type: Boolean,
    default: false
  }
};
var badge = "";
var Badge = defineComponent({
  name: "DBadge",
  props: badgeProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("badge");
    const className2 = computed(() => {
      const base = ns2.e("content");
      return [base, props.showDot ? ns2.m("dot") : ns2.m("count"), props.status && ns2.m(props.status), ctx2.slots.default && props.position && ns2.m(props.position), ctx2.slots.default && ns2.m("fixed"), props.hidden ? ns2.m("hidden") : ns2.m("show")].join(" ");
    });
    const style = computed(() => {
      const styleMap = {
        bgColor: "background",
        textColor: "color"
      };
      const ret = Object.keys(styleMap).reduce((result2, key) => {
        if (props[key]) {
          result2[styleMap[key]] = props[key];
        }
        return result2;
      }, {});
      if (ctx2.slots.default && props.offset) {
        const [x, y] = props.offset;
        const [yName, xName] = props.position.split("-");
        ret[yName] = y + "px";
        ret[xName] = x + "px";
      }
      return ret;
    });
    const text = computed(() => {
      if (props.showDot) {
        return;
      }
      if (typeof props.count === "number" && typeof props.maxCount === "number") {
        return props.count > props.maxCount ? `${props.maxCount}+` : props.count;
      }
      return props.count;
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": ns2.b()
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a), createVNode("div", {
        "class": className2.value,
        "style": style.value
      }, [text.value])]);
    };
  }
});
var BadgeInstall = {
  title: "Badge \u5FBD\u6807",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Badge.name, Badge);
  }
};
const breadcrumbProps = {
  source: {
    type: Array,
    default: []
  },
  separatorIcon: {
    type: String
  }
};
const breadcrumbItemProps = {
  showMenu: {
    type: Boolean,
    default: false
  },
  menuList: {
    type: Array
  },
  isSearch: {
    type: Boolean,
    dafault: false
  },
  to: {
    type: [String, Object],
    default: ""
  },
  replace: {
    type: Boolean,
    default: false
  }
};
var breadcrumbItem = "";
const dropdownProps$1 = {
  visible: {
    type: Boolean,
    default: false
  },
  trigger: {
    type: String,
    default: "click"
  },
  closeScope: {
    type: String,
    default: "all"
  },
  position: {
    type: Array,
    default: ["bottom"]
  },
  align: {
    type: String,
    default: null
  },
  offset: {
    type: [Number, Object],
    default: 4
  },
  shiftOffset: {
    type: Number
  },
  closeOnMouseLeaveMenu: {
    type: Boolean,
    default: false
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  overlayClass: {
    type: String,
    default: ""
  },
  destroyOnHide: {
    type: Boolean,
    default: true
  }
};
const dropdownMap = /* @__PURE__ */ new Map();
function subscribeEvent(dom, type4, callback) {
  dom == null ? void 0 : dom.addEventListener(type4, callback);
  return () => {
    dom == null ? void 0 : dom.removeEventListener(type4, callback);
  };
}
const useDropdownEvent = ({ id, isOpen, origin, dropdownRef, props, emit }) => {
  let overlayEnter = false;
  let originEnter = false;
  const { trigger, closeScope, closeOnMouseLeaveMenu } = toRefs(props);
  const toggle = (status2) => {
    isOpen.value = status2;
    emit("toggle", isOpen.value);
  };
  const handleLeave = async (elementType, closeAll) => {
    await new Promise((resolve) => setTimeout(resolve, 50));
    if (elementType === "origin" && overlayEnter || elementType === "dropdown" && originEnter) {
      return;
    }
    if (closeAll) {
      [...dropdownMap.values()].reverse().forEach((item) => {
        setTimeout(() => {
          var _a;
          (_a = item.toggle) == null ? void 0 : _a.call(item);
        }, 0);
      });
    }
    toggle(false);
  };
  watch([trigger, origin, dropdownRef], ([triggerVal, originVal, dropdownEl], ov, onInvalidate) => {
    const originEl = getElement(originVal);
    const subscriptions = [];
    setTimeout(() => {
      subscriptions.push(subscribeEvent(document, "click", (e) => {
        e.stopPropagation();
        const dropdownValues = [...dropdownMap.values()];
        if (!isOpen.value || closeScope.value === "none" || (dropdownEl == null ? void 0 : dropdownEl.contains(e.target)) && closeScope.value === "blank" || dropdownValues.some((item) => {
          var _a;
          return (_a = item.toggleEl) == null ? void 0 : _a.contains(e.target);
        }) && dropdownValues.some((item) => {
          var _a;
          return (_a = item.menuEl) == null ? void 0 : _a.contains(e.target);
        })) {
          return;
        }
        [...dropdownMap.values()].reverse().forEach((item) => {
          setTimeout(() => {
            var _a, _b;
            if (!((_a = item.toggleEl) == null ? void 0 : _a.contains(e.target))) {
              (_b = item.toggle) == null ? void 0 : _b.call(item);
            }
          }, 0);
        });
        overlayEnter = false;
      }));
    }, 0);
    if (triggerVal === "click") {
      subscriptions.push(subscribeEvent(originEl, "click", () => toggle(!isOpen.value)), subscribeEvent(dropdownEl, "mouseleave", (e) => {
        var _a;
        if (closeOnMouseLeaveMenu.value && !((_a = dropdownMap.get(id).child) == null ? void 0 : _a.contains(e.relatedTarget))) {
          handleLeave("dropdown", true);
        }
      }));
    } else if (triggerVal === "hover") {
      subscriptions.push(subscribeEvent(originEl, "mouseenter", () => {
        originEnter = true;
        toggle(true);
      }), subscribeEvent(originEl, "mouseleave", () => {
        originEnter = false;
        handleLeave("origin");
      }), subscribeEvent(dropdownEl, "mouseenter", () => {
        overlayEnter = true;
        isOpen.value = true;
      }), subscribeEvent(dropdownEl, "mouseleave", (e) => {
        var _a;
        overlayEnter = false;
        if (e.relatedTarget && ((originEl == null ? void 0 : originEl.contains(e.relatedTarget)) || ((_a = dropdownMap.get(id).child) == null ? void 0 : _a.contains(e.relatedTarget)))) {
          return;
        }
        handleLeave("dropdown", true);
      }));
    }
    onInvalidate(() => subscriptions.forEach((v) => v()));
  });
};
function useDropdown(id, visible, isOpen, origin, dropdownRef, popDirection, emit) {
  const calcPopDirection = (dropdownEl) => {
    const elementHeight = dropdownEl.offsetHeight;
    const bottomDistance = window.innerHeight - origin.value.getBoundingClientRect().bottom;
    const isBottomEnough = bottomDistance >= elementHeight;
    if (!isBottomEnough) {
      popDirection.value = "top";
    } else {
      popDirection.value = "bottom";
    }
  };
  watch(visible, (newVal, oldVal) => {
    if (oldVal === void 0) {
      return;
    }
    isOpen.value = newVal;
    emit("toggle", isOpen.value);
  }, { immediate: true });
  watch([isOpen, dropdownRef], ([isOpenVal, dropdownEl]) => {
    var _a;
    if (isOpenVal) {
      dropdownMap.set(id, __spreadProps(__spreadValues({}, dropdownMap.get(id)), {
        menuEl: dropdownEl,
        toggle: () => {
          isOpen.value = false;
          emit("toggle", isOpen.value);
        }
      }));
      for (const value of dropdownMap.values()) {
        if ((_a = value.menuEl) == null ? void 0 : _a.contains(origin.value)) {
          value.child = dropdownEl;
        }
      }
    }
    if (dropdownEl) {
      calcPopDirection(dropdownEl);
    }
  });
  onMounted(() => {
    dropdownMap.set(id, { toggleEl: origin.value });
  });
  onUnmounted(() => {
    dropdownMap.delete(id);
  });
}
function useOverlayProps(props, currentPosition, isOpen) {
  const { showAnimation, overlayClass, destroyOnHide } = toRefs(props);
  const overlayModelValue = ref(false);
  const overlayShowValue = ref(false);
  const styles = computed(() => ({
    transformOrigin: currentPosition.value === "top" ? "0% 100%" : "0% 0%",
    zIndex: "var(--b-z-index-dropdown, 1052)"
  }));
  const classes = computed(() => ({
    "fade-in-bottom": showAnimation.value && isOpen.value && currentPosition.value === "bottom",
    "fade-in-top": showAnimation.value && isOpen.value && currentPosition.value === "top",
    [`${overlayClass.value}`]: true
  }));
  const handlePositionChange = (pos) => {
    currentPosition.value = pos.includes("top") || pos.includes("right-end") || pos.includes("left-end") ? "top" : "bottom";
  };
  watch(isOpen, (isOpenVal) => {
    overlayModelValue.value = destroyOnHide.value ? isOpenVal : true;
    overlayShowValue.value = isOpenVal;
  });
  return { overlayModelValue, overlayShowValue, styles, classes, handlePositionChange };
}
var dropdown = "";
let dropdownId = 1;
var Dropdown$1 = defineComponent({
  name: "DDropdown",
  inheritAttrs: false,
  props: dropdownProps$1,
  emits: ["toggle"],
  setup(props, {
    slots,
    attrs,
    emit,
    expose
  }) {
    const {
      visible,
      position,
      align,
      offset: offset2,
      destroyOnHide,
      shiftOffset,
      showAnimation
    } = toRefs(props);
    const origin = ref();
    const dropdownRef = ref();
    const overlayRef = ref();
    const id = `dropdown_${dropdownId++}`;
    const isOpen = ref(false);
    const currentPosition = ref("bottom");
    const ns2 = useNamespace("dropdown");
    provide(POPPER_TRIGGER_TOKEN, origin);
    useDropdownEvent({
      id,
      isOpen,
      origin,
      dropdownRef,
      props,
      emit
    });
    useDropdown(id, visible, isOpen, origin, dropdownRef, currentPosition, emit);
    const {
      overlayModelValue,
      overlayShowValue,
      styles,
      classes,
      handlePositionChange
    } = useOverlayProps(props, currentPosition, isOpen);
    watch(overlayShowValue, (overlayShowValueVal) => {
      nextTick(() => {
        if (!destroyOnHide.value && overlayShowValueVal) {
          overlayRef.value.updatePosition();
        }
      });
    });
    expose({
      updatePosition: () => overlayRef.value.updatePosition()
    });
    return () => createVNode(Fragment, null, [createVNode(PopperTrigger, null, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    }), createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode(Transition, {
        "name": showAnimation.value ? ns2.m(`fade-${currentPosition.value}`) : ""
      }, {
        default: () => [withDirectives(createVNode(FlexibleOverlay, {
          "modelValue": overlayModelValue.value,
          "onUpdate:modelValue": ($event) => overlayModelValue.value = $event,
          "ref": overlayRef,
          "origin": origin.value,
          "position": position.value,
          "align": align.value,
          "offset": offset2.value,
          "shiftOffset": shiftOffset == null ? void 0 : shiftOffset.value,
          "onPositionChange": handlePositionChange,
          "click-event-bubble": true,
          "class": classes.value,
          "style": styles.value
        }, {
          default: () => {
            var _a;
            return [createVNode("div", mergeProps({
              "ref": dropdownRef,
              "class": ns2.e("menu-wrap")
            }, attrs), [(_a = slots.menu) == null ? void 0 : _a.call(slots)])];
          }
        }), [[vShow, overlayShowValue.value]])]
      })]
    })]);
  }
});
var BreadcrumbItem = defineComponent({
  name: "DBreadcrumbItem",
  components: {
    DDropdown: Dropdown$1
  },
  props: breadcrumbItemProps,
  setup(props, {
    slots
  }) {
    var _a;
    const separatorIcon = inject("separatorIcon");
    const ns2 = useNamespace("breadcrumb");
    const linkClass = props.to ? "is-link" : "";
    const dropdownTitleClass = props.showMenu && ((_a = props.menuList) == null ? void 0 : _a.length) ? ns2.e("dropdown-title") : "";
    const link = ref(null);
    const instance = getCurrentInstance();
    const router = instance == null ? void 0 : instance.appContext.config.globalProperties.$router;
    const showMenu = ref(props.showMenu);
    const menuList = ref(props.menuList || []);
    const handleClickLink = () => {
      if (!props.to || !router) {
        return;
      }
      props.replace ? router.replace(props.to) : router.push(props.to);
    };
    onMounted(() => {
      var _a2;
      (_a2 = link.value) == null ? void 0 : _a2.addEventListener("click", handleClickLink);
    });
    onBeforeUnmount(() => {
      var _a2;
      (_a2 = link.value) == null ? void 0 : _a2.removeEventListener("click", handleClickLink);
    });
    const renderBreadcrumbSperator = () => {
      return createVNode("span", {
        "class": ns2.e("separator")
      }, [separatorIcon]);
    };
    const renderBreadcrumbNode = () => {
      var _a2;
      if (showMenu.value) {
        return createVNode("div", {
          "class": ns2.e("item")
        }, [createVNode(resolveComponent("d-dropdown"), {
          "trigger": "hover",
          "close-scope": "blank"
        }, {
          default: () => {
            var _a3;
            return [createVNode("span", {
              "class": [linkClass, dropdownTitleClass]
            }, [(_a3 = slots == null ? void 0 : slots.default) == null ? void 0 : _a3.call(slots), createVNode("span", {
              "class": "icon icon-chevron-down"
            }, null)])];
          },
          menu: () => createVNode("ul", {
            "class": ns2.e("item-dropdown")
          }, [menuList.value.map((item) => {
            return item.link ? createVNode("a", {
              "href": item.link,
              "target": item.target ? item.target : "_self"
            }, [createVNode("li", {
              "class": ns2.e("item-dropdown-item")
            }, [item.title])]) : createVNode("li", {
              "class": ns2.e("item-dropdown-item")
            }, [createVNode("span", {
              "class": linkClass
            }, [item.title])]);
          })])
        })]);
      }
      return createVNode("div", {
        "class": ns2.e("item")
      }, [createVNode("span", {
        "ref": link,
        "class": linkClass
      }, [(_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)]), renderBreadcrumbSperator()]);
    };
    return () => {
      return renderBreadcrumbNode();
    };
  }
});
var breadcrumb = "";
var Breadcrumb = defineComponent({
  name: "DBreadcrumb",
  components: {
    DBreadcrumbItem: BreadcrumbItem
  },
  props: breadcrumbProps,
  setup(props, {
    slots
  }) {
    var _a;
    const separatorIcon = (_a = getPropsSlot(slots, props, "separatorIcon")) != null ? _a : "/";
    provide("separatorIcon", separatorIcon);
    const ns2 = useNamespace("breadcrumb");
    const renderBreadcrumbItemRouted = (item) => {
      return createVNode(resolveComponent("d-breadcrumb-item"), {
        "to": `path: ${item.link}`,
        "replace": item.replace
      }, {
        default: () => [item.title]
      });
    };
    const renderBreadcrumbItemDropdown = (item) => {
      return createVNode(resolveComponent("d-breadcrumb-item"), {
        "menuList": item.children,
        "showMenu": item.showMenu,
        "to": `path: ${item.link}`,
        "replace": item.replace
      }, {
        default: () => [!item.noNavigation && (!item.linkType || item.linkType === "hrefLink") ? createVNode("a", {
          "href": item.link,
          "target": item.target ? item.target : "_self"
        }, [item.title]) : null, item.noNavigation ? createVNode("span", null, [item.title]) : null]
      });
    };
    const renderBreadItemList = (source) => {
      return source.map((item) => {
        if (!item.noNavigation && item.linkType === "routerLink") {
          return renderBreadcrumbItemRouted(item);
        }
        if (item.children && item.children.length > 0) {
          return renderBreadcrumbItemDropdown(item);
        }
        return createVNode(resolveComponent("d-breadcrumb-item"), null, {
          default: () => [!item.noNavigation && (!item.linkType || item.linkType === "hrefLink") ? createVNode("a", {
            "href": item.link,
            "target": item.target ? item.target : "_self"
          }, [item.title]) : null, item.noNavigation ? createVNode("span", null, [item.title]) : null]
        });
      });
    };
    return () => {
      var _a2;
      return createVNode("div", {
        "class": ns2.b()
      }, [props.source && props.source.length ? renderBreadItemList(props.source) : (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)]);
    };
  }
});
var BreadcrumbInstall = {
  title: "Breadcrumb \u9762\u5305\u5C51",
  category: "\u5BFC\u822A",
  status: "50%",
  install(app) {
    app.component(Breadcrumb.name, Breadcrumb);
    app.component(BreadcrumbItem.name, BreadcrumbItem);
  }
};
const buttonProps = {
  variant: {
    type: String,
    default: "outline"
  },
  size: {
    type: String,
    default: "md"
  },
  color: {
    type: String
  },
  icon: {
    type: String,
    default: ""
  },
  loading: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  shape: {
    type: String
  }
};
const buttonGroupProps = {
  size: {
    type: String,
    default: "md"
  }
};
const buttonGroupInjectionKey = Symbol("d-button-group");
function useButton(props, ctx2) {
  const ns2 = useNamespace("button");
  const hasContent = computed(() => ctx2.slots.default);
  const colorMap = {
    solid: "primary",
    outline: "secondary",
    text: "secondary"
  };
  const defaultColor = colorMap[props.variant];
  const buttonGroupConf = inject(buttonGroupInjectionKey, null);
  const buttonSize = computed(() => {
    return (buttonGroupConf == null ? void 0 : buttonGroupConf.size.value) || props.size;
  });
  const classes = computed(() => ({
    [ns2.b()]: true,
    [ns2.m(props.variant)]: true,
    [`${ns2.m(props.variant)}--${props.color || defaultColor}`]: true,
    [ns2.m(buttonSize.value)]: true,
    [ns2.e("icon-wrap")]: props.icon,
    [ns2.e("icon")]: props.icon && !hasContent.value,
    [ns2.m("is-loading")]: props.loading,
    [ns2.m(props.shape || "")]: props.shape && lodash.exports.isString(props.shape) ? true : false
  }));
  const iconClass = computed(() => {
    if (!props.icon) {
      return "";
    }
    const origin = `${ns2.e("icon-fix")} icon`;
    if (hasContent.value) {
      return `${origin} clear-right-5`;
    } else {
      return origin;
    }
  });
  return { classes, iconClass };
}
var button = "";
var DButton = defineComponent({
  name: "DButton",
  directives: {
    Loading: LoadingDirective
  },
  props: buttonProps,
  emits: ["click"],
  setup(props, ctx2) {
    const {
      icon: icon2,
      disabled,
      loading: loading2
    } = toRefs(props);
    const {
      classes,
      iconClass
    } = useButton(props, ctx2);
    const onClick = (e) => {
      if (loading2.value) {
        return;
      }
      ctx2.emit("click", e);
    };
    return () => {
      var _a, _b;
      return createVNode("button", {
        "class": classes.value,
        "disabled": disabled.value,
        "onClick": onClick
      }, [icon2.value && createVNode(DIcon, {
        "name": icon2.value,
        "size": "var(--b-font-size, 12px)",
        "color": "",
        "class": iconClass.value
      }, null), withDirectives(createVNode("div", {
        "class": "loading-icon__container"
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "icon-loading",
        "class": "button-icon-loading",
        "color": "#BBDEFB"
      }, null)]), [[vShow, loading2.value]]), createVNode("span", {
        "class": "button-content"
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])]);
    };
  }
});
var buttonGroup = "";
var ButtonGroup = defineComponent({
  name: "DButtonGroup",
  props: buttonGroupProps,
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("button-group");
    provide(buttonGroupInjectionKey, {
      size: toRef(props, "size")
    });
    return () => {
      return createVNode("div", {
        "class": ns2.b()
      }, [slots.default && slots.default()]);
    };
  }
});
var ButtonInstall = {
  title: "Button \u6309\u94AE",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.component(DButton.name, DButton);
    app.component(ButtonGroup.name, ButtonGroup);
  }
};
const cardProps = {
  align: {
    type: String,
    default: "start"
  },
  src: {
    type: String,
    default: ""
  },
  shadow: {
    type: String,
    default: "hover"
  }
};
var card = "";
var Card = defineComponent({
  name: "DCard",
  props: cardProps,
  setup(props, {
    slots
  }) {
    const {
      align,
      src
    } = toRefs(props);
    const ns2 = useNamespace("card");
    const alignClass = computed(() => {
      return {
        [ns2.e("actions")]: true,
        [ns2.em("actions", `align-${align.value}`)]: align.value !== "start"
      };
    });
    return () => {
      var _a, _b, _c, _d, _e, _f, _g;
      return createVNode("div", {
        "class": ["card-container", ns2.b(), ns2.em("shadow", props.shadow)]
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots), createVNode("div", {
        "class": ns2.e("header")
      }, [((_b = slots.avatar) == null ? void 0 : _b.call(slots)) ? createVNode("div", {
        "class": ns2.e("avatar")
      }, [(_c = slots.avatar) == null ? void 0 : _c.call(slots)]) : "", createVNode("div", null, [createVNode("div", {
        "class": ns2.e("title")
      }, [(_d = slots.title) == null ? void 0 : _d.call(slots)]), createVNode("div", {
        "class": ns2.e("subtitle")
      }, [(_e = slots.subtitle) == null ? void 0 : _e.call(slots)])])]), src.value !== "" ? createVNode("img", {
        "src": src.value,
        "alt": "",
        "class": ns2.e("meta")
      }, null) : "", createVNode("div", {
        "class": ns2.e("content")
      }, [(_f = slots.content) == null ? void 0 : _f.call(slots)]), createVNode("div", {
        "class": alignClass.value
      }, [slots.actions ? (_g = slots.actions) == null ? void 0 : _g.call(slots) : ""])]);
    };
  }
});
var CardInstall = {
  title: "Card \u5361\u7247",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Card.name, Card);
  }
};
const carouselProps = {
  arrowTrigger: {
    type: String,
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: false
  },
  autoplaySpeed: {
    type: Number,
    default: 3e3
  },
  height: {
    type: String,
    default: "100%"
  },
  showDots: {
    type: Boolean,
    default: true
  },
  dotTrigger: {
    type: String,
    default: "click"
  },
  dotPosition: {
    type: String,
    default: "bottom"
  },
  activeIndex: {
    type: Number,
    default: 0
  },
  transitionSpeed: {
    type: Number,
    default: 500
  }
};
var carousel = "";
var Carousel = defineComponent({
  name: "DCarousel",
  props: carouselProps,
  emits: ["update:activeIndex", "activeIndexChange"],
  setup(props, {
    emit,
    slots,
    expose
  }) {
    const ns2 = useNamespace("carousel");
    const {
      height,
      showDots,
      dotPosition,
      arrowTrigger,
      autoplay,
      autoplaySpeed,
      dotTrigger,
      activeIndex,
      transitionSpeed
    } = toRefs(props);
    const itemCount = ref(0);
    const showArrow = ref(false);
    const currentIndex = ref(0);
    const wrapperRef = ref(null);
    const containerRef = ref(null);
    const scheduledId = ref(null);
    watch(() => arrowTrigger, () => {
      showArrow.value = arrowTrigger.value === "always";
    }, {
      immediate: true
    });
    watch(() => activeIndex, () => {
      currentIndex.value = activeIndex.value;
    }, {
      immediate: true
    });
    const translatePosition = (size) => {
      if (containerRef.value) {
        containerRef.value.style.left = `${-size * 100}%`;
      }
    };
    const adjustTransition = (targetEl) => {
      setTimeout(() => {
        if (containerRef.value) {
          containerRef.value.style.transition = "";
        }
        targetEl.style.transform = "";
        translatePosition(currentIndex.value);
      }, transitionSpeed.value);
    };
    const adjustPosition = (targetEl, firstToLast) => {
      if (wrapperRef.value) {
        const wrapperRect = wrapperRef.value.getBoundingClientRect();
        targetEl.style.transform = `translateX(${(firstToLast ? -itemCount.value : itemCount.value) * wrapperRect.width}px)`;
      }
    };
    const clearScheduledTransition = () => {
      if (scheduledId.value) {
        clearTimeout(scheduledId.value);
        scheduledId.value = null;
      }
    };
    const autoScheduleTransition = (callback) => {
      clearScheduledTransition();
      if (autoplay.value && autoplaySpeed.value) {
        scheduledId.value = setTimeout(() => {
          callback == null ? void 0 : callback();
        }, autoplaySpeed.value);
      }
    };
    const goto = (index2) => {
      if (index2 === currentIndex.value || !wrapperRef.value || !containerRef.value) {
        return;
      }
      containerRef.value.style.transition = `left ${transitionSpeed.value}ms ease`;
      let latestIndex = currentIndex.value;
      if (index2 < 0 && currentIndex.value === 0) {
        latestIndex = itemCount.value - 1;
        const targetEl = containerRef.value.children[latestIndex];
        adjustPosition(targetEl, true);
        translatePosition(-1);
        adjustTransition(targetEl);
      } else if (index2 >= itemCount.value && currentIndex.value === itemCount.value - 1) {
        latestIndex = 0;
        const targetEl = containerRef.value.children[latestIndex];
        adjustPosition(targetEl, false);
        translatePosition(itemCount.value);
        adjustTransition(targetEl);
      } else {
        latestIndex = index2 < 0 ? 0 : index2 > itemCount.value - 1 ? itemCount.value - 1 : index2;
        translatePosition(latestIndex);
      }
      currentIndex.value = latestIndex;
      emit("update:activeIndex", latestIndex);
      emit("activeIndexChange", latestIndex);
      autoScheduleTransition(() => {
        goto(currentIndex.value + 1);
      });
    };
    const prev = () => {
      goto(currentIndex.value - 1);
    };
    const next = () => {
      goto(currentIndex.value + 1);
    };
    const arrowMouseEvent = (type4) => {
      if (arrowTrigger.value !== "hover") {
        return;
      }
      showArrow.value = type4 === "enter";
    };
    const switchStep = (index2, type4) => {
      if (type4 === dotTrigger.value) {
        goto(index2);
      }
    };
    const changeItemCount = (val) => {
      itemCount.value = val;
      autoScheduleTransition(next);
    };
    onMounted(() => {
      if (containerRef.value) {
        containerRef.value.style.transition = `left ${transitionSpeed.value}ms ease`;
        containerRef.value.style.left = "0%";
      }
      autoScheduleTransition(next);
    });
    onBeforeUnmount(() => {
      clearScheduledTransition();
    });
    expose({
      prev,
      next,
      goto
    });
    return () => {
      var _a, _b;
      const slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
      let children = slot;
      if (children.length === 1 && children[0].type === Fragment) {
        children = (children[0].children || []).filter((item) => (item == null ? void 0 : item.type) !== Comment$1);
      }
      if (children.length !== itemCount.value) {
        changeItemCount(children.length);
      }
      return createVNode("div", {
        "class": ns2.b(),
        "style": {
          height: height.value
        },
        "onMouseenter": () => arrowMouseEvent("enter"),
        "onMouseleave": () => arrowMouseEvent("leave")
      }, [arrowTrigger.value !== "never" && showArrow.value ? createVNode("div", {
        "class": ns2.e("arrow")
      }, [createVNode("button", {
        "class": "arrow-left",
        "onClick": () => prev()
      }, [createVNode(DIcon, {
        "name": "arrow-left"
      }, null)]), createVNode("button", {
        "class": "arrow-right",
        "onClick": () => next()
      }, [createVNode(DIcon, {
        "name": "arrow-right"
      }, null)])]) : null, createVNode("div", {
        "class": ns2.e("item-wrapper"),
        "ref": wrapperRef
      }, [createVNode("div", {
        "class": ns2.e("item-container"),
        "style": {
          width: `${itemCount.value * 100}%`
        },
        "ref": containerRef
      }, [slot])]), itemCount.value > 0 && showDots.value ? createVNode("ul", {
        "class": [ns2.e("dots"), dotPosition.value]
      }, [children.map((_, index2) => createVNode("li", {
        "class": {
          "dot-item": true,
          active: currentIndex.value === index2
        },
        "onClick": () => switchStep(index2, "click"),
        "onMouseenter": () => switchStep(index2, "hover"),
        "style": {
          transition: `all ${transitionSpeed.value}ms ease`
        }
      }, null))]) : null]);
    };
  }
});
var CarouselItem = defineComponent({
  name: "DCarouselItem",
  setup(props, {
    slots
  }) {
    var _a;
    const ns2 = useNamespace("carousel");
    const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
    return () => createVNode("div", {
      "class": ns2.e("item")
    }, [children]);
  }
});
var CarouselInstall = {
  title: "Carousel \u8D70\u9A6C\u706F",
  category: "\u6570\u636E\u5C55\u793A",
  status: "80%",
  install(app) {
    app.component(Carousel.name, Carousel);
    app.component(CarouselItem.name, CarouselItem);
  }
};
const ns$h = useNamespace("cascader");
const useRootClassName = (props, menuShow) => {
  return computed(() => ({
    [`${ns$h.b()} ${ns$h.e("dropdown")} ${ns$h.em("dropdown", "animation")}`]: true,
    [ns$h.em("dropdown", "open")]: menuShow.value,
    [ns$h.e("disbaled")]: props.disabled
  }));
};
const useListClassName = (props) => {
  var _a, _b, _c;
  const itemProps = props == null ? void 0 : props.cascaderItemNeedProps;
  const isActive = ((_a = itemProps == null ? void 0 : itemProps.valueCache) == null ? void 0 : _a[props.ulIndex]) === ((_b = props.cascaderItem) == null ? void 0 : _b.value);
  const isDisabled = (_c = props.cascaderItem) == null ? void 0 : _c.disabled;
  return computed(() => ({
    [`${ns$h.e("li")} dropdown-item`]: true,
    "leaf-active": isActive,
    disabled: isDisabled
  }));
};
const useUlClassName = (props) => {
  return computed(() => {
    var _a;
    return {
      [ns$h.e("ul")]: true,
      [ns$h.e("drop-no-data")]: ((_a = props == null ? void 0 : props.cascaderItems) == null ? void 0 : _a.length) === 0
    };
  });
};
const dropdownOpenClass = (status2) => {
  return status2 ? `${ns$h.e("drop-menu-wrapper")}` : "";
};
const useRootStyle = (props) => {
  return {
    inputWidth: `width: ${props.width}${typeof props.width === "number" ? "px" : ""}`
  };
};
const useDropdownStyle = (props) => {
  return {
    dropdownWidth: `width: ${props.dropdownWidth}${typeof props.dropdownWidth === "number" ? "px" : ""}`
  };
};
const cascaderProps = {
  trigger: {
    type: String,
    default: "hover"
  },
  width: {
    type: [Number, String],
    default: 200
  },
  dropdownWidth: {
    type: [Number, String],
    default: 200
  },
  options: {
    type: Array,
    default: [],
    required: true
  },
  multiple: {
    type: Boolean,
    default: false
  },
  showPath: {
    type: Boolean,
    default: false
  },
  modelValue: {
    type: Array,
    default: []
  },
  "onUpdate:modelValue": {
    type: Function
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  change: {
    type: Function,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: true
  },
  filterable: {
    type: Boolean,
    default: false
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Function,
    default: () => true
  },
  size: {
    type: String
  }
};
const cascaderulProps = {
  cascaderItems: {
    type: Array,
    default: () => [
      {
        label: "",
        value: ""
      }
    ]
  },
  dropdownWidth: {
    type: [Number, String],
    default: 200
  },
  ulIndex: {
    type: Number,
    default: 0
  },
  cascaderItemNeedProps: {
    type: Object,
    default: () => ({})
  },
  stopDefault: {
    type: Boolean,
    default: false
  },
  cascaderOptions: {
    type: Array,
    default: () => [
      [
        {
          label: "",
          value: ""
        }
      ]
    ]
  }
};
const initTagList = (tagList) => {
  tagList.splice(0, tagList.length);
};
const multipleAddTag = (tagList, singleItem) => {
  if (singleItem) {
    tagList.push(singleItem);
  }
};
const multipleDeleteTag = (tagList, singleItem) => {
  const i = tagList.findIndex((item) => item.value === singleItem.value);
  tagList.splice(i, 1);
};
const findChildrenCheckedStatusToUpdateParent = (node) => {
  var _a, _b, _c;
  const checkedChild = (_a = node == null ? void 0 : node.children) == null ? void 0 : _a.find((t) => t["checked"]);
  const halfcheckedChild = (_b = node == null ? void 0 : node.children) == null ? void 0 : _b.find((t) => t["halfChecked"]);
  const uncheckedChild = (_c = node == null ? void 0 : node.children) == null ? void 0 : _c.find((t) => !t["halfChecked"] && !t["checked"]);
  if (halfcheckedChild || checkedChild && uncheckedChild) {
    node["checked"] = false;
    node["halfChecked"] = true;
  } else if (!checkedChild && !halfcheckedChild) {
    node["checked"] = false;
    node["halfChecked"] = false;
  } else {
    node["checked"] = true;
    node["halfChecked"] = false;
  }
};
const setChildrenParent = (parentNode) => {
  var _a;
  (_a = parentNode == null ? void 0 : parentNode.children) == null ? void 0 : _a.forEach((child) => {
    child.parent = parentNode;
  });
  return parentNode;
};
const findNextColumn = (targetValues, options, index2, tagList) => {
  var _a, _b;
  let targetNode = options.find((t) => t.value === targetValues[index2]);
  if (((_a = targetNode == null ? void 0 : targetNode.children) == null ? void 0 : _a.length) && ((_b = targetNode == null ? void 0 : targetNode.children) == null ? void 0 : _b.length) > 0) {
    index2 += 1;
    targetNode = setChildrenParent(targetNode);
    findNextColumn(targetValues, (targetNode == null ? void 0 : targetNode.children) || [], index2, tagList);
  } else {
    multipleAddTag(tagList, targetNode);
    if (targetNode) {
      targetNode["checked"] = true;
    }
    (targetNode == null ? void 0 : targetNode.parent) && findChildrenCheckedStatusToUpdateParent(targetNode == null ? void 0 : targetNode.parent);
  }
};
const initMultipleCascaderItem = (targetValues, rootColumn, tagList) => {
  findNextColumn(targetValues, rootColumn, 0, tagList);
};
const findParentValues = (item, values = []) => {
  values.push(item.value);
  if (item.parent) {
    findParentValues(item.parent, values);
  }
  return values;
};
const getMultiModelValues = (tagList) => {
  const modelValues = [];
  tagList.forEach((item) => {
    modelValues.push(findParentValues(item, []).reverse());
  });
  return modelValues;
};
const updateParentNodeStatus = (node, options, ulIndex) => {
  if (ulIndex < 0) {
    return;
  }
  findChildrenCheckedStatusToUpdateParent(node);
  ulIndex -= 1;
  const parentNode = node == null ? void 0 : node.parent;
  updateParentNodeStatus(parentNode, options, ulIndex);
};
const updateCheckOptionStatus = (tagList) => {
  const updateCheckStatusLoop = (node, type4, ulIndex, status2) => {
    var _a, _b;
    if (((_a = node == null ? void 0 : node.children) == null ? void 0 : _a.length) && ((_b = node == null ? void 0 : node.children) == null ? void 0 : _b.length) > 0) {
      node.children.forEach((item) => {
        if (item.disabled) {
          return;
        }
        if (type4 === "checked") {
          item[type4] = status2;
          item["halfChecked"] = false;
          updateCheckStatusLoop(item, type4, ulIndex, status2);
        } else if (type4 === "halfChecked") {
          item["halfChecked"] = false;
          item["checked"] = false;
          !status2 && updateCheckStatusLoop(item, type4, ulIndex);
        }
      });
    } else {
      !node.checked ? multipleDeleteTag(tagList, node) : multipleAddTag(tagList, node);
    }
  };
  const updateCurNodeStatus = (node, ulIndex) => {
    if (node == null ? void 0 : node.halfChecked) {
      node["halfChecked"] = false;
      node["checked"] = false;
      updateCheckStatusLoop(node, "halfChecked", ulIndex);
    } else {
      node["checked"] = !node.checked;
      updateCheckStatusLoop(node, "checked", ulIndex, node.checked);
    }
  };
  const updateStatus = (node, options, ulIndex) => {
    updateCurNodeStatus(node, ulIndex);
    ulIndex -= 1;
    const parentNode = node == null ? void 0 : node.parent;
    updateParentNodeStatus(parentNode, options, ulIndex);
  };
  return {
    updateStatus
  };
};
const initActiveIndexs = (values, curColumn, index2, activeIndexs) => {
  var _a, _b;
  let nextOption = null;
  for (let i = 0; i < curColumn.length; i++) {
    if (((_a = curColumn[i]) == null ? void 0 : _a.value) === values[index2]) {
      nextOption = (_b = curColumn[i]) == null ? void 0 : _b.children;
      activeIndexs[index2] = i;
      break;
    }
  }
  if (index2 < values.length - 1 && nextOption) {
    index2 += 1;
    initActiveIndexs(values, nextOption, index2, activeIndexs);
  }
};
const initSingleIptValue = (inputValueCache) => {
  if (inputValueCache) {
    inputValueCache.value = "";
  }
};
const singleChoose = (ulIndex, valueCache, cascaderItem) => {
  valueCache.splice(ulIndex, valueCache.length - ulIndex);
  valueCache[ulIndex] = cascaderItem == null ? void 0 : cascaderItem.value;
};
var index$d = "";
const commonProps$1 = {
  name: {
    type: String,
    default: void 0
  },
  halfChecked: {
    type: Boolean,
    default: false
  },
  isShowTitle: {
    type: Boolean,
    default: true
  },
  title: {
    type: String
  },
  color: {
    type: String,
    default: void 0
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  beforeChange: {
    type: Function,
    default: void 0
  },
  size: {
    type: String
  }
};
const checkboxProps = __spreadProps(__spreadValues({}, commonProps$1), {
  checked: {
    type: Boolean,
    default: false
  },
  value: {
    type: [Number, String]
  },
  label: {
    type: String,
    default: ""
  },
  "onUpdate:checked": {
    type: Function,
    default: void 0
  },
  onChange: {
    type: Function,
    default: void 0
  },
  modelValue: {
    type: Boolean
  },
  "onUpdate:modelValue": {
    type: Function
  },
  border: {
    type: Boolean,
    default: false
  }
});
const checkboxGroupProps = __spreadProps(__spreadValues({}, commonProps$1), {
  modelValue: {
    type: Array,
    required: true
  },
  direction: {
    type: String,
    default: "column"
  },
  itemWidth: {
    type: Number,
    default: void 0
  },
  options: {
    type: Array,
    default: () => []
  },
  onChange: {
    type: Function,
    default: void 0
  },
  "onUpdate:modelValue": {
    type: Function,
    default: void 0
  },
  border: {
    type: Boolean,
    default: false
  },
  max: {
    type: Number,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  }
});
const checkboxGroupInjectionKey = Symbol("d-checkbox-group");
function useCheckbox(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const checkboxGroupConf = inject(checkboxGroupInjectionKey, null);
  const isChecked = computed(() => props.checked || props.modelValue);
  const mergedChecked = computed(() => {
    var _a, _b;
    return (_b = (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.isItemChecked) == null ? void 0 : _a.call(checkboxGroupConf, props.value)) != null ? _b : isChecked.value;
  });
  const isLimitDisabled = computed(() => {
    const max = checkboxGroupConf == null ? void 0 : checkboxGroupConf.max.value;
    return !!max && (checkboxGroupConf == null ? void 0 : checkboxGroupConf.modelValue.value.length) >= max && !mergedChecked.value;
  });
  const mergedDisabled = computed(() => {
    return (checkboxGroupConf == null ? void 0 : checkboxGroupConf.disabled.value) || props.disabled || (formContext == null ? void 0 : formContext.disabled) || isLimitDisabled.value;
  });
  const mergedIsShowTitle = computed(() => {
    var _a;
    return (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.isShowTitle.value) != null ? _a : props.isShowTitle;
  });
  const mergedShowAnimation = computed(() => {
    var _a;
    return (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.showAnimation.value) != null ? _a : props.showAnimation;
  });
  const mergedColor = computed(() => {
    var _a;
    return (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.color.value) != null ? _a : props.color;
  });
  const itemWidth = checkboxGroupConf == null ? void 0 : checkboxGroupConf.itemWidth.value;
  const direction = checkboxGroupConf == null ? void 0 : checkboxGroupConf.direction.value;
  const canChange = (checked, val) => {
    var _a;
    if (mergedDisabled.value) {
      return Promise.resolve(false);
    }
    const beforeChange = (_a = props.beforeChange) != null ? _a : checkboxGroupConf == null ? void 0 : checkboxGroupConf.beforeChange;
    if (beforeChange) {
      const res = beforeChange(checked, val);
      if (typeof res === "boolean") {
        return Promise.resolve(res);
      }
      return res;
    }
    return Promise.resolve(true);
  };
  const toggle = () => {
    const current = !isChecked.value;
    checkboxGroupConf == null ? void 0 : checkboxGroupConf.toggleGroupVal(props.value);
    ctx2.emit("update:checked", current);
    ctx2.emit("update:modelValue", current);
    ctx2.emit("change", current);
  };
  const handleClick = ($event) => {
    $event.stopPropagation();
    canChange(!isChecked.value, props.label).then((res) => res && toggle());
  };
  const size = computed(() => props.size || (checkboxGroupConf == null ? void 0 : checkboxGroupConf.size.value) || (formContext == null ? void 0 : formContext.size) || "md");
  const border = computed(() => {
    var _a;
    return (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.border.value) != null ? _a : props.border;
  });
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  });
  return {
    mergedChecked,
    mergedDisabled,
    mergedIsShowTitle,
    mergedShowAnimation,
    mergedColor,
    itemWidth,
    direction,
    handleClick,
    size,
    border
  };
}
function useCheckboxGroup(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const valList = toRef(props, "modelValue");
  const defaultOpt = {
    checked: false,
    isShowTitle: true,
    halfChecked: false,
    showAnimation: true,
    disabled: false
  };
  const toggleGroupVal = (val) => {
    let index2 = -1;
    if (["string", "number"].includes(typeof valList.value[0])) {
      index2 = valList.value.findIndex((item) => item === val);
    } else if (typeof valList.value[0] === "object") {
      index2 = valList.value.findIndex((item) => item.value === val);
    }
    if (index2 === -1) {
      if (typeof props.options[0] === "object") {
        const newOne = props.options.find((item) => item.value === val);
        const res2 = [...valList.value, newOne];
        ctx2.emit("update:modelValue", res2);
        ctx2.emit("change", res2);
        return;
      }
      const res = [...valList.value, val];
      ctx2.emit("update:modelValue", res);
      ctx2.emit("change", res);
      return;
    }
    valList.value.splice(index2, 1);
    ctx2.emit("update:modelValue", valList.value);
    ctx2.emit("change", valList.value);
  };
  const isItemChecked = (itemVal) => {
    if (["string", "number"].includes(typeof valList.value[0])) {
      return valList.value.includes(itemVal);
    } else if (typeof valList.value[0] === "object") {
      return valList.value.some((item) => item.value === itemVal);
    }
  };
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  }, { deep: true });
  const checkboxGroupSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "");
  provide(checkboxGroupInjectionKey, {
    disabled: toRef(props, "disabled"),
    isShowTitle: toRef(props, "isShowTitle"),
    color: toRef(props, "color"),
    showAnimation: toRef(props, "showAnimation"),
    beforeChange: props.beforeChange,
    isItemChecked,
    toggleGroupVal,
    itemWidth: toRef(props, "itemWidth"),
    direction: toRef(props, "direction"),
    size: checkboxGroupSize,
    border: toRef(props, "border"),
    max: toRef(props, "max"),
    modelValue: toRef(props, "modelValue"),
    textColor: toRef(props, "textColor")
  });
  return { defaultOpt };
}
function useCheckboxButton() {
  const checkboxGroupConf = inject(checkboxGroupInjectionKey, null);
  const mergedTextColor = computed(() => {
    var _a;
    return (_a = checkboxGroupConf == null ? void 0 : checkboxGroupConf.textColor.value) != null ? _a : void 0;
  });
  return {
    mergedTextColor
  };
}
var checkbox = "";
var Checkbox = defineComponent({
  name: "DCheckbox",
  props: checkboxProps,
  emits: ["change", "update:checked", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("checkbox");
    const {
      mergedChecked,
      mergedDisabled,
      mergedIsShowTitle,
      mergedShowAnimation,
      mergedColor,
      itemWidth,
      direction,
      handleClick,
      size,
      border
    } = useCheckbox(props, ctx2);
    return () => {
      var _a, _b;
      const wrapperCls = {
        [ns2.e("column-margin")]: direction === "column",
        [ns2.e("wrap")]: typeof itemWidth !== "undefined"
      };
      const wrapperStyle = itemWidth ? [`width: ${itemWidth}px`] : [];
      const checkboxCls = {
        [ns2.b()]: true,
        active: mergedChecked.value,
        "half-checked": props.halfChecked,
        disabled: mergedDisabled.value,
        unchecked: !mergedChecked.value
      };
      const labelTitle = mergedIsShowTitle.value ? props.title || props.label : "";
      const bgImgStyle = mergedColor.value && props.halfChecked || mergedColor.value ? `linear-gradient(${mergedColor.value}, ${mergedColor.value})` : "";
      const spanStyle = [`border-color:${(mergedChecked.value || props.halfChecked) && mergedColor.value ? mergedColor.value : ""}`, `background-image:${bgImgStyle}`, `background-color:${mergedColor.value && props.halfChecked ? mergedColor.value : ""}`];
      const spanCls = {
        [ns2.e("material")]: true,
        "custom-color": mergedColor.value,
        [ns2.m("no-label")]: !props.label && !ctx2.slots.default,
        [ns2.m("no-animation")]: !mergedShowAnimation.value,
        [ns2.e("default-background")]: !props.halfChecked
      };
      const polygonCls = {
        [ns2.e("tick")]: true,
        [ns2.m("no-animation")]: !mergedShowAnimation.value
      };
      const labelCls = {
        [ns2.m(size.value)]: size.value,
        [ns2.m("bordered")]: border.value
      };
      const stopPropagation = ($event) => $event.stopPropagation();
      const inputProps2 = {
        indeterminate: props.halfChecked
      };
      return createVNode("div", {
        "class": wrapperCls,
        "style": wrapperStyle
      }, [createVNode("div", {
        "class": checkboxCls
      }, [createVNode("label", {
        "title": labelTitle,
        "onClick": handleClick,
        "class": labelCls,
        "style": {
          width: itemWidth ? "100%" : "auto"
        }
      }, [createVNode("input", mergeProps({
        "name": props.name || props.value,
        "class": ns2.e("input"),
        "type": "checkbox"
      }, inputProps2, {
        "checked": mergedChecked.value,
        "disabled": mergedDisabled.value,
        "onClick": stopPropagation,
        "onChange": stopPropagation
      }), null), createVNode("span", {
        "style": spanStyle,
        "class": spanCls
      }, [createVNode("span", {
        "class": ns2.e("halfchecked-bg")
      }, null), createVNode("svg", {
        "viewBox": "0 0 16 16",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg",
        "class": ns2.e("tick-wrap")
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill-rule": "nonzero",
        "points": "5.17391304 6.56521739 7.7173913 9.10869565 11.826087 5 13 6.17391304 7.7173913 11.4565217 4 7.73913043",
        "class": polygonCls
      }, null)])])]), createVNode("span", {
        "class": ns2.e("label-text")
      }, [props.label || ((_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a))])])])]);
    };
  }
});
var checkboxGroup = "";
var DCheckboxGroup = defineComponent({
  name: "DCheckboxGroup",
  props: checkboxGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("checkbox");
    const {
      defaultOpt
    } = useCheckboxGroup(props, ctx2);
    return () => {
      var _a, _b;
      let children = (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a);
      const getContent = () => {
        var _a2;
        if (children) {
          return children;
        } else {
          if (((_a2 = props.options) == null ? void 0 : _a2.length) > 0) {
            children = props.options.map((opt) => {
              let mergedOpt = null;
              if (typeof opt === "string") {
                mergedOpt = Object.assign({}, defaultOpt, {
                  label: opt,
                  value: opt
                });
              } else if (typeof opt === "object") {
                mergedOpt = Object.assign({}, defaultOpt, __spreadProps(__spreadValues({}, opt), {
                  label: opt.name
                }));
              }
              return createVNode(Checkbox, mergedOpt, null);
            });
          }
          return children;
        }
      };
      return createVNode("div", {
        "class": [ns2.e("group"), {
          "is-row": props.direction === "row",
          "is-column": props.direction === "column"
        }]
      }, [getContent()]);
    };
  }
});
var checkboxButton = "";
var CheckboxButton = defineComponent({
  name: "DCheckboxButton",
  props: checkboxProps,
  emits: ["change", "update:checked", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("checkbox-button");
    const {
      mergedChecked,
      mergedDisabled,
      mergedIsShowTitle,
      mergedColor,
      handleClick,
      size
    } = useCheckbox(props, ctx2);
    const {
      mergedTextColor
    } = useCheckboxButton();
    return () => {
      var _a, _b;
      const labelTitle = mergedIsShowTitle.value ? props.title || props.label : "";
      const spanStyle = [`border-color:${mergedChecked.value && mergedColor.value ? mergedColor.value : ""}`, `background-color:${mergedChecked.value && mergedColor.value ? mergedColor.value : ""}`, `color:${mergedChecked.value && mergedTextColor.value ? mergedTextColor.value : ""}`];
      const labelCls = {
        [ns2.b()]: true,
        active: mergedChecked.value,
        disabled: mergedDisabled.value,
        unchecked: !mergedChecked.value
      };
      const spanCls = {
        [ns2.e("content")]: true,
        [ns2.m(size.value)]: true
      };
      const stopPropagation = ($event) => $event.stopPropagation();
      return createVNode("label", {
        "title": labelTitle,
        "onClick": handleClick,
        "class": labelCls
      }, [createVNode("input", {
        "name": props.name || props.value,
        "class": ns2.e("input"),
        "type": "checkbox",
        "checked": mergedChecked.value,
        "disabled": mergedDisabled.value,
        "onClick": stopPropagation,
        "onChange": stopPropagation
      }, null), createVNode("span", {
        "style": spanStyle,
        "class": spanCls
      }, [props.label || ((_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a))])]);
    };
  }
});
var CheckboxInstall = {
  title: "Checkbox \u590D\u9009\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Checkbox.name, Checkbox);
    app.component(DCheckboxGroup.name, DCheckboxGroup);
    app.component(CheckboxButton.name, CheckboxButton);
  }
};
const DCascaderItem = (props) => {
  var _a;
  const {
    cascaderItem,
    ulIndex,
    liIndex,
    cascaderItemNeedProps,
    cascaderOptions
  } = props;
  const {
    multiple,
    stopDefault,
    valueCache,
    activeIndexs,
    trigger,
    confirmInputValueFlg,
    tagList
  } = cascaderItemNeedProps;
  const isTriggerHover = trigger === "hover";
  const rootClasses = useListClassName(props);
  const {
    updateStatus
  } = updateCheckOptionStatus(tagList);
  const disbaled = computed(() => cascaderItem == null ? void 0 : cascaderItem.disabled);
  const updateValues = () => {
    if (stopDefault == null ? void 0 : stopDefault.value) {
      return;
    }
    activeIndexs == null ? void 0 : activeIndexs.splice(ulIndex, activeIndexs.length - ulIndex);
    if (activeIndexs) {
      activeIndexs[ulIndex] = liIndex;
    }
    if (!multiple) {
      valueCache && singleChoose(ulIndex, valueCache, cascaderItem);
    }
  };
  const mouseEnter = () => {
    if (disbaled.value || multiple) {
      return;
    }
    updateValues();
  };
  const mouseenter = isTriggerHover ? {
    onMouseenter: mouseEnter
  } : {};
  const mouseClick = () => {
    var _a2;
    if (disbaled.value) {
      return;
    }
    updateValues();
    if (!multiple && (!cascaderItem.children || ((_a2 = cascaderItem == null ? void 0 : cascaderItem.children) == null ? void 0 : _a2.length) === 0)) {
      if (confirmInputValueFlg) {
        confirmInputValueFlg.value = !confirmInputValueFlg.value;
      }
    }
  };
  const checkboxChange = () => {
    updateStatus(cascaderItem, cascaderOptions, ulIndex);
  };
  return createVNode("li", {
    "class": rootClasses.value
  }, [multiple && createVNode("div", {
    "class": "cascader-li__checkbox"
  }, [createVNode(Checkbox, {
    "checked": cascaderItem == null ? void 0 : cascaderItem.checked,
    "disabled": cascaderItem.disabled,
    "halfChecked": cascaderItem == null ? void 0 : cascaderItem.halfChecked,
    "onChange": checkboxChange
  }, null)]), createVNode("div", mergeProps({
    "class": "cascader-li__wraper"
  }, mouseenter, {
    "onClick": mouseClick
  }), [cascaderItem.icon && createVNode("div", {
    "class": "cascader-li__icon" + (cascaderItem.disabled ? " disabled" : "")
  }, [createVNode(DIcon, {
    "name": cascaderItem.icon,
    "size": "inherit"
  }, null)]), createVNode("div", {
    "class": "dropdown-item-label"
  }, [createVNode("span", null, [cascaderItem.label])]), Boolean((_a = cascaderItem == null ? void 0 : cascaderItem.children) == null ? void 0 : _a.length) && createVNode(DIcon, {
    "name": "chevron-right",
    "size": "16px",
    "color": "inherit"
  }, null)])]);
};
var index$c = "";
var DCascaderList = defineComponent({
  name: "DCascaderList",
  props: cascaderulProps,
  setup(props) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DCascaderList", app);
    const ulClass = useUlClassName(props);
    const ulStyle = useDropdownStyle(props);
    return () => {
      var _a;
      return createVNode("ul", {
        "class": ulClass.value,
        "style": ulStyle.dropdownWidth
      }, [((_a = props == null ? void 0 : props.cascaderItems) == null ? void 0 : _a.length) > 0 ? props.cascaderItems.map((item, index2) => {
        return createVNode(DCascaderItem, mergeProps({
          "cascaderItem": item,
          "liIndex": index2
        }, props), null);
      }) : createVNode("span", null, [t("noData")])]);
    };
  }
});
var index$b = "";
var DTag = (props) => {
  const {
    tagList,
    tag: tag2
  } = props;
  const deleteCurrentTag = (e) => {
    e.stopPropagation();
    multipleDeleteTag(tagList, tag2);
  };
  return createVNode("div", {
    "class": "devui-cascader-tag"
  }, [createVNode("span", null, [tag2 == null ? void 0 : tag2.label]), createVNode("div", {
    "class": "devui-cascader-tag__close",
    "onClick": deleteCurrentTag
  }, [createVNode(resolveComponent("d-icon"), {
    "name": "close"
  }, null)])]);
};
var index$a = "";
var DMultipleBox = (props) => {
  return createVNode("div", {
    "class": "devui-tags-input"
  }, [createVNode("div", {
    "class": "devui-tags-box"
  }, [props.activeOptions.length > 0 ? props.activeOptions.map((item) => {
    return createVNode(DTag, {
      "tag": item,
      "tagList": props.activeOptions
    }, null);
  }) : createVNode("div", {
    "class": "devui-tags-placeholder"
  }, [props.placeholder])])]);
};
const popupHandles = (props, overlayRef, origin) => {
  const menuShow = ref(false);
  const menuOpenClass = ref("");
  const disabled = computed(() => props.disabled);
  const stopDefault = ref(false);
  const updateStopDefaultType = () => {
    stopDefault.value = !menuShow.value;
  };
  const openPopup = () => {
    if (disabled.value) {
      return;
    }
    menuShow.value = !menuShow.value;
    updateStopDefaultType();
  };
  watch(menuShow, (status2) => {
    menuOpenClass.value = dropdownOpenClass(status2);
  });
  onClickOutside(overlayRef, () => {
    menuShow.value = false;
  }, { ignore: [origin] });
  return {
    menuShow,
    stopDefault,
    menuOpenClass,
    updateStopDefaultType,
    openPopup
  };
};
const useCascaderItem = (props, stopDefault, tagList) => {
  const cascaderItemNeedProps = {
    trigger: props.trigger,
    inputValueCache: ref(""),
    confirmInputValueFlg: ref(false),
    valueCache: reactive(lodash.exports.cloneDeep(props.modelValue)),
    value: reactive(lodash.exports.cloneDeep(props.modelValue)),
    multiple: props.multiple,
    activeIndexs: reactive([]),
    tagList,
    stopDefault
  };
  return {
    cascaderItemNeedProps
  };
};
const useFilter$1 = (props, ctx2, menuShow, cascaderItemNeedProps, updateCascaderView, inputValue, cascaderOptions) => {
  const suggestions = ref([]);
  const suggestionsList = ref([]);
  const isSearching = ref(false);
  const searchText = ref("");
  watch(menuShow, (val) => {
    if (!val) {
      isSearching.value = false;
    }
  });
  const isPromise2 = (obj) => {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  };
  const setChildrenParent2 = (parentNode) => {
    if (parentNode.children && parentNode.children.length) {
      parentNode.children.forEach((child) => {
        child.parent = parentNode;
        if (parentNode.disabled) {
          child.disabled = true;
        }
      });
    }
    return parentNode;
  };
  const addParent = (data) => {
    data.forEach((item) => {
      if (item.children && item.children.length) {
        setChildrenParent2(item);
        addParent(item.children);
      } else {
        item.isLeaf = true;
      }
    });
    return data;
  };
  const allNodes = addParent(lodash.exports.cloneDeep(props.options));
  const flatNodes = (data = []) => {
    return data.reduce((res, node) => {
      if (node.children) {
        res.push(node);
        res = res.concat(flatNodes(node.children));
      } else {
        res.push(node);
      }
      return res;
    }, []);
  };
  const flatAllNodes = flatNodes(allNodes);
  const filterLeafs = () => {
    const leafs = flatAllNodes.filter((item) => {
      return item.isLeaf && !item.disabled;
    });
    return leafs;
  };
  const findParentValues2 = (item, values = []) => {
    values.push(item.value);
    if (item.parent) {
      findParentValues2(item.parent, values);
    }
    return values;
  };
  const findParentLabels = (item, values = []) => {
    values.push(item.label);
    if (item.parent) {
      findParentLabels(item.parent, values);
    }
    return values;
  };
  const leafsData = filterLeafs();
  const labelsAndValues = () => {
    const suggestionList = [];
    leafsData.forEach((item) => {
      suggestionList.push({ values: findParentValues2(item, []).reverse(), labels: findParentLabels(item, []).reverse() });
    });
    suggestionList.forEach((value) => {
      value.labelsString = value.labels.join(" / ");
    });
    return suggestionList;
  };
  suggestions.value = labelsAndValues();
  const caclSuggestions = () => {
    suggestionsList.value = suggestions.value.filter((item) => {
      var _a;
      return ((_a = item.labelsString) == null ? void 0 : _a.toLowerCase().includes(searchText.value.toString().toLowerCase())) && !item.disabled;
    });
    isSearching.value = true;
  };
  const hideSuggestion = () => {
    isSearching.value = false;
  };
  const handleFilter = lodash.exports.debounce((val) => {
    searchText.value = val;
    const pass = props.beforeFilter(val);
    if (isPromise2(pass)) {
      pass.then(caclSuggestions).catch(() => {
      });
    } else if (pass !== false) {
      caclSuggestions();
    } else {
      hideSuggestion();
    }
    menuShow.value = true;
  }, props.debounce);
  const handleInput = (val) => {
    if (!props.filterable) {
      return;
    }
    val ? handleFilter(val) : hideSuggestion();
  };
  const chooseSuggestion = (item) => {
    var _a, _b;
    if (props.showPath) {
      inputValue.value = item.labelsString;
    } else {
      const labels = item.labelsString.split(" / ");
      inputValue.value = labels[labels.length - 1];
    }
    ctx2.emit("update:modelValue", item.values);
    (_a = cascaderItemNeedProps.valueCache) == null ? void 0 : _a.splice(0);
    (_b = cascaderItemNeedProps.valueCache) == null ? void 0 : _b.splice(0, 0, ...item.values);
    initActiveIndexs(item.values, cascaderOptions[0], 0, cascaderItemNeedProps.activeIndexs);
    updateCascaderView(cascaderItemNeedProps.activeIndexs, cascaderOptions[0], 0);
    menuShow.value = false;
  };
  return {
    handleInput,
    suggestionsList,
    isSearching,
    chooseSuggestion
  };
};
const useCascader = (props, ctx2) => {
  const origin = ref();
  const overlayRef = ref();
  const cascaderOptions = reactive(lodash.exports.cloneDeep([props == null ? void 0 : props.options]));
  const multiple = toRef(props, "multiple");
  const inputValue = ref("");
  const tagList = ref([]);
  const rootStyle = useRootStyle(props);
  const showClearable = ref(false);
  const position = ref(["bottom-start", "top-start"]);
  let initIptValue = props.modelValue.length > 0 ? true : false;
  const { menuShow, menuOpenClass, openPopup, stopDefault, updateStopDefaultType } = popupHandles(props, overlayRef, origin);
  const rootClasses = useRootClassName(props, menuShow);
  const { cascaderItemNeedProps } = useCascaderItem(props, stopDefault, tagList.value);
  const getInputValue = (label, arr, inputValueCache, showPath) => {
    if (inputValueCache !== void 0) {
      if (!showPath) {
        inputValueCache.value = label;
      } else {
        inputValueCache.value += label + ((arr == null ? void 0 : arr.length) > 0 ? " / " : "");
      }
    }
  };
  const updateCascaderView = (value, currentOption, index2) => {
    if (index2 === value.length) {
      return;
    }
    const i = value[index2];
    const current = currentOption[i];
    const children = (current == null ? void 0 : current.children) || [];
    if ((children == null ? void 0 : children.length) > 0) {
      cascaderOptions[index2 + 1] = children;
      updateCascaderView(value, children, index2 + 1);
    } else {
      cascaderOptions.splice(index2 + 1, cascaderOptions.length - 1);
    }
  };
  const getCurrentOption = (currentOption, i) => {
    return currentOption.filter((item) => (item == null ? void 0 : item.value) === i)[0];
  };
  const updateCascaderValue = (value, currentOption, index2) => {
    if (!multiple.value) {
      if (index2 === value.length) {
        return;
      }
      const i = value[index2];
      const current = getCurrentOption(currentOption, i);
      const children = (current == null ? void 0 : current.children) || [];
      getInputValue(current.label, children, cascaderItemNeedProps.inputValueCache, props.showPath);
      if ((children == null ? void 0 : children.length) > 0) {
        updateCascaderValue(value, children, index2 + 1);
      }
    } else {
      const rootColumn = cascaderOptions[0] || [];
      value.forEach((targetValue) => {
        initMultipleCascaderItem(targetValue, rootColumn, tagList.value);
      });
    }
  };
  watch(cascaderItemNeedProps.activeIndexs, (val) => {
    cascaderOptions.splice((val == null ? void 0 : val.length) || 0, cascaderOptions.length - 1);
    updateCascaderView(val, cascaderOptions[0], 0);
  });
  watch(() => {
    var _a;
    return (_a = cascaderItemNeedProps.confirmInputValueFlg) == null ? void 0 : _a.value;
  }, () => {
    var _a;
    multiple.value ? initTagList(tagList.value) : initSingleIptValue(cascaderItemNeedProps.inputValueCache);
    cascaderItemNeedProps.value = reactive(lodash.exports.cloneDeep(cascaderItemNeedProps.valueCache));
    menuShow.value = false;
    updateStopDefaultType();
    updateCascaderValue(cascaderItemNeedProps.value, cascaderOptions[0], 0);
    inputValue.value = (_a = cascaderItemNeedProps.inputValueCache) == null ? void 0 : _a.value;
    if (initIptValue && !multiple.value) {
      initActiveIndexs(props.modelValue, cascaderOptions[0], 0, cascaderItemNeedProps.activeIndexs);
      initIptValue = false;
    }
    ctx2.emit("update:modelValue", cascaderItemNeedProps.value);
  }, {
    immediate: true
  });
  watch(() => tagList, () => {
    if (multiple.value) {
      ctx2.emit("update:modelValue", getMultiModelValues(tagList.value));
    }
  }, {
    immediate: true,
    deep: true
  });
  const showClear = () => {
    if (props.disabled) {
      return;
    }
    showClearable.value = true;
  };
  const hideClear = () => {
    showClearable.value = false;
  };
  const clearData = (e) => {
    var _a;
    e.stopPropagation();
    menuShow.value = false;
    inputValue.value = "";
    ctx2.emit("update:modelValue", []);
    menuShow.value = false;
    cascaderOptions.splice(1, cascaderOptions.length - 1);
    if (cascaderItemNeedProps.inputValueCache) {
      cascaderItemNeedProps.inputValueCache.value = "";
    }
    (_a = cascaderItemNeedProps.valueCache) == null ? void 0 : _a.splice(0);
  };
  watch(() => props.modelValue, (newVal) => {
    ctx2.emit("change", newVal);
  }, { immediate: true, deep: true });
  watch(() => props.options, () => {
    const len = cascaderOptions.length;
    cascaderOptions.splice(0, len, ...lodash.exports.cloneDeep([props.options]));
  }, { deep: true });
  const onFocus = (e) => {
    ctx2.emit("focus", e);
  };
  const onBlur = (e) => {
    ctx2.emit("blur", e);
  };
  const { handleInput, suggestionsList, isSearching, chooseSuggestion } = useFilter$1(props, ctx2, menuShow, cascaderItemNeedProps, updateCascaderView, inputValue, cascaderOptions);
  onMounted(() => {
    var _a;
    (_a = origin.value) == null ? void 0 : _a.addEventListener("click", openPopup);
  });
  return {
    origin,
    overlayRef,
    menuShow,
    cascaderItemNeedProps,
    rootClasses,
    menuOpenClass,
    inputValue,
    openPopup,
    rootStyle,
    showClearable,
    position,
    cascaderOptions,
    tagList,
    showClear,
    hideClear,
    clearData,
    handleInput,
    multiple,
    suggestionsList,
    isSearching,
    chooseSuggestion,
    onFocus,
    onBlur
  };
};
const inputProps = {
  modelValue: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  error: {
    type: Boolean,
    default: false
  },
  size: {
    type: String
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  prefix: {
    type: String,
    default: ""
  },
  suffix: {
    type: String,
    default: ""
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  }
};
function useInputRender$1(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const isValidateError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const ns2 = useNamespace("input");
  const slotNs = useNamespace("input-slot");
  const isFocus = ref(false);
  const { error: error2, size, disabled } = toRefs(props);
  const slots = ctx2.slots;
  const inputDisabled = computed(() => disabled.value || (formContext == null ? void 0 : formContext.disabled));
  const inputSize = computed(() => (size == null ? void 0 : size.value) || (formContext == null ? void 0 : formContext.size) || "");
  const _a = ctx2.attrs, { style, class: customClass } = _a, otherAttrs = __objRest(_a, ["style", "class"]);
  const customStyle = { style };
  const wrapClasses = computed(() => ({
    [ns2.e("wrapper")]: true,
    [ns2.m("focus")]: isFocus.value,
    [ns2.m("disabled")]: inputDisabled.value,
    [ns2.m("error")]: error2.value || isValidateError.value,
    [ns2.m("feedback")]: Boolean(formItemContext == null ? void 0 : formItemContext.validateState) && (formItemContext == null ? void 0 : formItemContext.showFeedback)
  }));
  const inputClasses = computed(() => [
    {
      [ns2.b()]: true,
      [ns2.m(inputSize.value)]: Boolean(inputSize.value),
      [slotNs.b()]: slots.prepend || slots.append,
      [ns2.m("append")]: slots.append,
      [ns2.m("prepend")]: slots.prepend
    },
    customClass
  ]);
  return { inputDisabled, inputSize, isFocus, wrapClasses, inputClasses, customStyle, otherAttrs };
}
function useInputEvent$1(isFocus, props, ctx2, focus) {
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const onFocus = (e) => {
    isFocus.value = true;
    ctx2.emit("focus", e);
  };
  const onBlur = (e) => {
    isFocus.value = false;
    ctx2.emit("blur", e);
    if (props.validateEvent) {
      formItemContext == null ? void 0 : formItemContext.validate("blur").catch((err) => console.warn(err));
    }
  };
  const onInput = (e) => {
    ctx2.emit("input", e.target.value);
    ctx2.emit("update:modelValue", e.target.value);
  };
  const onChange = (e) => {
    ctx2.emit("change", e.target.value);
  };
  const onKeydown = (e) => {
    ctx2.emit("keydown", e);
  };
  const onClear = () => {
    ctx2.emit("update:modelValue", "");
    ctx2.emit("clear");
    focus();
  };
  return { onFocus, onBlur, onInput, onChange, onKeydown, onClear };
}
function useInputFunction(input2) {
  const refInput = computed(() => input2.value);
  const select2 = () => {
    var _a;
    (_a = refInput.value) == null ? void 0 : _a.select();
  };
  const focus = () => {
    var _a;
    (_a = refInput.value) == null ? void 0 : _a.focus();
  };
  const blur2 = () => {
    var _a;
    (_a = refInput.value) == null ? void 0 : _a.blur();
  };
  return { select: select2, focus, blur: blur2 };
}
var input = "";
var DInput = defineComponent({
  name: "DInput",
  inheritAttrs: false,
  props: inputProps,
  emits: ["update:modelValue", "focus", "blur", "input", "change", "keydown", "clear"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DInput", app);
    const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
    const {
      modelValue
    } = toRefs(props);
    const ns2 = useNamespace("input");
    const slotNs = useNamespace("input-slot");
    const {
      inputDisabled,
      inputSize,
      isFocus,
      wrapClasses,
      inputClasses,
      customStyle,
      otherAttrs
    } = useInputRender$1(props, ctx2);
    const input2 = shallowRef();
    const {
      select: select2,
      focus,
      blur: blur2
    } = useInputFunction(input2);
    const {
      onFocus,
      onBlur,
      onInput,
      onChange,
      onKeydown,
      onClear
    } = useInputEvent$1(isFocus, props, ctx2, focus);
    const passwordVisible = ref(false);
    const clickPasswordIcon = () => {
      passwordVisible.value = !passwordVisible.value;
      blur2();
    };
    const prefixVisible = ctx2.slots.prefix || props.prefix;
    const suffixVisible = ctx2.slots.suffix || props.suffix || props.showPassword || props.clearable;
    const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value);
    const showClearable = computed(() => {
      var _a;
      return props.clearable && !inputDisabled.value && ((_a = modelValue.value) == null ? void 0 : _a.length) > 0;
    });
    watch(() => props.modelValue, () => {
      if (props.validateEvent) {
        formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
      }
    });
    ctx2.expose({
      select: select2,
      focus,
      blur: blur2
    });
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return createVNode("div", mergeProps({
        "class": inputClasses.value
      }, customStyle), [ctx2.slots.prepend && createVNode("div", {
        "class": slotNs.e("prepend")
      }, [(_b = (_a = ctx2.slots).prepend) == null ? void 0 : _b.call(_a)]), createVNode("div", {
        "class": wrapClasses.value
      }, [prefixVisible && createVNode("span", {
        "class": slotNs.e("prefix")
      }, [ctx2.slots.prefix && ((_d = (_c = ctx2.slots).prefix) == null ? void 0 : _d.call(_c)), props.prefix && createVNode(DIcon, {
        "size": inputSize.value,
        "name": props.prefix
      }, null)]), createVNode("input", mergeProps({
        "ref": input2,
        "value": modelValue.value,
        "disabled": inputDisabled.value,
        "class": ns2.e("inner"),
        "placeholder": props.placeholder || t("placeholder")
      }, otherAttrs, {
        "type": props.showPassword ? passwordVisible.value ? "text" : "password" : "text",
        "onInput": onInput,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "onChange": onChange,
        "onKeydown": onKeydown
      }), null), suffixVisible && createVNode("span", {
        "class": slotNs.e("suffix")
      }, [props.suffix && createVNode(DIcon, {
        "size": inputSize.value,
        "name": props.suffix
      }, null), ctx2.slots.suffix && ((_f = (_e = ctx2.slots).suffix) == null ? void 0 : _f.call(_e)), showPwdVisible.value && createVNode(DIcon, {
        "size": inputSize.value,
        "class": ns2.em("password", "icon"),
        "name": passwordVisible.value ? "preview" : "preview-forbidden",
        "onClick": clickPasswordIcon
      }, null), showClearable.value && createVNode(DIcon, {
        "size": inputSize.value,
        "class": ns2.em("clear", "icon"),
        "name": "close",
        "onClick": onClear
      }, null)])]), ctx2.slots.append && createVNode("div", {
        "class": slotNs.e("append")
      }, [(_h = (_g = ctx2.slots).append) == null ? void 0 : _h.call(_g)])]);
    };
  }
});
var cascader = "";
var Cascader = defineComponent({
  name: "DCascader",
  components: {
    DInput
  },
  props: cascaderProps,
  emits: ["update:modelValue", "change", "focus", "blur"],
  setup(props, ctx2) {
    const ns2 = useNamespace("cascader");
    const {
      origin,
      overlayRef,
      menuShow,
      cascaderItemNeedProps,
      rootClasses,
      menuOpenClass,
      inputValue,
      rootStyle,
      showClearable,
      position,
      cascaderOptions,
      tagList,
      showClear,
      hideClear,
      clearData,
      handleInput,
      multiple,
      suggestionsList,
      isSearching,
      chooseSuggestion,
      onFocus,
      onBlur
    } = useCascader(props, ctx2);
    provide(POPPER_TRIGGER_TOKEN, origin);
    return () => createVNode("div", {
      "style": rootStyle.inputWidth
    }, [createVNode(PopperTrigger, null, {
      default: () => [ctx2.slots.host ? ctx2.slots.host() : createVNode("div", mergeProps({
        "class": rootClasses.value
      }, ctx2.attrs, {
        "onMouseenter": showClear,
        "onMouseleave": hideClear
      }), [multiple.value ? createVNode(DMultipleBox, {
        "placeholder": props.placeholder,
        "activeOptions": tagList.value
      }, null) : createVNode(DInput, {
        "disabled": props.disabled,
        "placeholder": props.placeholder,
        "modelValue": inputValue.value,
        "size": props.size,
        "onInput": handleInput,
        "onFocus": onFocus,
        "onBlur": onBlur
      }, null), !showClearable.value && createVNode("div", {
        "class": `${ns2.e("icon")} ${ns2.m("drop-icon-animation")}`
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "select-arrow",
        "size": "12px"
      }, null)]), showClearable.value && props.clearable && createVNode("div", {
        "class": `${ns2.e("icon")} ${ns2.e("close")}`,
        "onClick": clearData
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "close",
        "size": "12px"
      }, null)])])]
    }), createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => [createVNode(FlexibleOverlay, {
          "origin": origin.value,
          "ref": overlayRef,
          "modelValue": menuShow.value,
          "onUpdate:modelValue": ($event) => menuShow.value = $event,
          "position": position.value,
          "align": "start",
          "style": {
            zIndex: "var(--b-z-index-dropdown, 1052)"
          }
        }, {
          default: () => [createVNode("div", {
            "class": ns2.e("drop-menu-animation")
          }, [!isSearching.value && createVNode("div", {
            "class": `${menuOpenClass.value} ${ns2.e("dropdown-menu")}`
          }, [cascaderOptions.map((item, index2) => {
            return createVNode(DCascaderList, mergeProps({
              "cascaderItems": item,
              "ul-index": index2,
              "cascaderItemNeedProps": cascaderItemNeedProps,
              "cascaderOptions": cascaderOptions
            }, props), null);
          })]), props.filterable && isSearching.value && createVNode("div", {
            "class": ns2.e("panel")
          }, [suggestionsList.value.length === 0 ? createVNode("label", {
            "style": "font-weight: bold;"
          }, [createTextVNode("\u6CA1\u6709\u6570\u636E")]) : suggestionsList.value.map((item) => {
            return createVNode("div", {
              "class": ns2.e("suggest-list"),
              "onClick": () => chooseSuggestion(lodash.exports.cloneDeep(item))
            }, [item.labelsString]);
          })])])]
        })]
      })]
    })]);
  }
});
var CascaderInstall = {
  title: "Cascader \u7EA7\u8054\u83DC\u5355",
  category: "\u6570\u636E\u5F55\u5165",
  status: "30%",
  install(app) {
    app.component(Cascader.name, Cascader);
  }
};
const SELECT_TOKEN$1 = Symbol("dCollapse");
const collapseProps = {
  modelValue: {
    type: [String, Number, Array],
    default: "",
    required: true
  },
  accordion: {
    type: Boolean,
    default: false
  }
};
const collapseItemProps = {
  name: {
    type: [String, Number],
    default: "",
    required: true
  },
  title: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
var collapse = "";
var Collapse = defineComponent({
  name: "DCollapse",
  props: collapseProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("collapse");
    const scrollbarNs = useNamespace("scrollbar");
    const getLists = (data) => {
      if (!data && data !== 0) {
        return [];
      }
      return Array.isArray(data) ? data : [data];
    };
    const collapseItemClick = (name) => {
      const activeLists = [...getLists(props.modelValue)];
      const itemIndex = activeLists.indexOf(name);
      if (props.accordion) {
        let activeName = name;
        if ((activeLists[0] || activeLists[0] === 0) && activeLists[0] === name) {
          activeName = "";
        }
        ctx2.emit("update:modelValue", activeName);
        ctx2.emit("change", activeName);
      } else {
        if (itemIndex > -1) {
          activeLists.splice(itemIndex, 1);
        } else {
          activeLists.push(name);
        }
        ctx2.emit("update:modelValue", activeLists);
        ctx2.emit("change", activeLists);
      }
    };
    provide(SELECT_TOKEN$1, reactive(__spreadProps(__spreadValues({}, toRefs(props)), {
      collapseItemClick
    })));
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": [ns2.b(), scrollbarNs.b()]
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var CollapseItem = defineComponent({
  name: "DCollapseItem",
  props: collapseItemProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("collapse");
    const transitionNs = useNamespace("collapse-transition");
    const collapseContent = shallowRef();
    const collapse2 = inject(SELECT_TOKEN$1, null);
    const isOpen = computed(() => {
      if (props.disabled) {
        return false;
      }
      if (Array.isArray(collapse2 == null ? void 0 : collapse2.modelValue)) {
        return Boolean(collapse2 == null ? void 0 : collapse2.modelValue.length) && (collapse2 == null ? void 0 : collapse2.modelValue.includes(props.name));
      } else {
        return Boolean(collapse2 == null ? void 0 : collapse2.modelValue) && (collapse2 == null ? void 0 : collapse2.modelValue) === props.name;
      }
    });
    const handlerTitleClick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!props.disabled) {
        collapse2 == null ? void 0 : collapse2.collapseItemClick(props.name);
      }
    };
    onMounted(() => {
      if (collapseContent.value) {
        const dom = collapseContent.value;
        if (isOpen.value) {
          dom.style.height = `${dom.offsetHeight}px`;
        }
      }
    });
    const enter = (element) => {
      const el = element;
      el.style.height = "";
      const height = el.offsetHeight;
      el.style.height = "0px";
      el.offsetHeight;
      el.style.height = `${height}px`;
    };
    const leave = (element) => {
      const el = element;
      el.style.height = "0px";
    };
    return () => {
      return createVNode("div", {
        "class": ns2.e("item")
      }, [createVNode("div", {
        "class": [ns2.e("item-title"), ns2.m("overflow-ellipsis"), isOpen.value && ns2.m("open"), props.disabled && ns2.em("item", "disabled")],
        "onClick": handlerTitleClick
      }, [ctx2.slots.title ? ctx2.slots.title() : props.title, createVNode("span", {
        "class": ns2.e("open-icon")
      }, [createVNode(OpenIcon, null, null)])]), createVNode(Transition, {
        "name": transitionNs.b(),
        "onEnter": enter,
        "onLeave": leave
      }, {
        default: () => {
          var _a, _b;
          return [isOpen.value && createVNode("div", {
            "ref": collapseContent,
            "class": ns2.e("item-content")
          }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])];
        }
      })]);
    };
  }
});
var CollapseInstall = {
  title: "Collapse \u6298\u53E0\u9762\u677F",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Collapse.name, Collapse);
    app.component(CollapseItem.name, CollapseItem);
  }
};
function colorPickerResize(colorCubeRef, top, left) {
  if (colorCubeRef.value) {
    const rect = colorCubeRef.value.getBoundingClientRect();
    left.value = rect.left;
    top.value = rect.top + window.scrollY + rect.height;
  }
}
function isExhibitionColorPicker(event, colorCubeRef, pickerRef, showColorPicker) {
  var _a, _b, _c;
  if (((_b = (_a = colorCubeRef.value) == null ? void 0 : _a.contains) == null ? void 0 : _b.call(_a, event.target)) && !showColorPicker.value) {
    showColorPicker.value = true;
  }
  if (!!pickerRef.value && !((_c = pickerRef.value) == null ? void 0 : _c.contains(event.target))) {
    showColorPicker.value = !showColorPicker.value;
  }
}
function useReactive(source) {
  const model = ref();
  model.value = source();
  watch(source, (newValue) => {
    model.value = newValue;
  });
  return model;
}
function changeColorValue(value, maxValue) {
  if (value.alpha > maxValue) {
    return value.hsva.v > maxValue && value.hsva.s < maxValue ? { color: "#000" } : { color: "#fff" };
  } else {
    return { color: "#000" };
  }
}
const colorPickerProps$1 = {
  modelValue: {
    type: [Object, String],
    default: {}
  },
  mode: {
    type: String
  },
  showAlpha: {
    type: Boolean,
    default: true
  },
  dotSize: {
    type: Number,
    default: 15
  },
  swatches: {
    type: Array
  },
  showHistory: {
    type: Boolean,
    default: true
  }
};
const colorPickerProps = {
  colorMap: {
    type: Object
  },
  modelValue: {
    type: Object
  },
  showAlpha: {
    type: Boolean,
    default: true
  },
  mode: {
    type: String
  }
};
const tabsProps = {
  modelValue: {
    type: [String, Number],
    default: null
  },
  type: {
    type: String,
    default: "tabs"
  },
  showContent: {
    type: Boolean,
    default: true
  },
  reactivable: {
    type: Boolean,
    default: true
  },
  customWidth: {
    type: String,
    default: ""
  },
  cssClass: {
    type: String,
    default: ""
  },
  beforeChange: {
    type: Function,
    default: null
  },
  closeable: {
    type: Boolean,
    default: false
  },
  addable: {
    type: Boolean,
    default: false
  },
  tabPosition: {
    type: String,
    default: "top"
  }
};
const ns$g = useNamespace("tabs");
function useTabNavRender(props, data) {
  const { cssClass, tabPosition, customWidth } = toRefs(props);
  const ulClasses = computed(() => ({
    [ns$g.e("nav")]: true,
    [ns$g.em("nav", props.type)]: true,
    [cssClass.value]: Boolean(cssClass.value),
    [ns$g.em("nav", "top")]: tabPosition.value === "top",
    [ns$g.em("nav", "right")]: tabPosition.value === "right",
    [ns$g.em("nav", "bottom")]: tabPosition.value === "bottom",
    [ns$g.em("nav", "left")]: tabPosition.value === "left"
  }));
  const aClasses = computed(() => ({
    ["custom-width"]: Boolean(customWidth.value)
  }));
  const customStyle = {
    width: props.customWidth ? props.customWidth : ""
  };
  const sliderAnimationStyle = computed(() => {
    if (["top", "bottom"].includes(props.tabPosition)) {
      return {
        left: data.offsetLeft + "px",
        width: data.offsetWidth + "px"
      };
    } else {
      return {
        top: data.offsetTop + "px",
        height: data.offsetHeight + "px",
        width: data.offsetWidth + "px"
      };
    }
  });
  return { ulClasses, aClasses, customStyle, sliderAnimationStyle };
}
function useTabNavFunction(props, tabs, tabsList, data, ctx2, tabsEle) {
  const update = () => {
    if (props.type === "slider") {
      setTimeout(() => {
        var _a;
        const tabEle = (_a = tabsEle.value) == null ? void 0 : _a.querySelector("#" + props.modelValue + ".active");
        if (tabEle && tabsEle.value) {
          if (["top", "bottom"].includes(props.tabPosition)) {
            data.offsetLeft = tabEle.getBoundingClientRect().left - tabsEle.value.getBoundingClientRect().left;
          } else {
            data.offsetTop = tabEle.getBoundingClientRect().top - tabsEle.value.getBoundingClientRect().top;
            data.offsetHeight = tabEle.getBoundingClientRect().height;
          }
          data.offsetWidth = tabEle.getBoundingClientRect().width;
        }
      });
    }
  };
  const canChange = (currentTab) => {
    let changeResult = Promise.resolve(true);
    if (typeof props.beforeChange === "function") {
      const result2 = props.beforeChange(currentTab);
      if (typeof result2 !== "undefined") {
        if (result2.then) {
          changeResult = result2;
        } else {
          changeResult = Promise.resolve(result2);
        }
      }
    }
    return changeResult;
  };
  const activeClick = (item, tabEl) => {
    const id = item.props.id;
    if (!props.reactivable && props.modelValue === id) {
      return;
    }
    canChange(id).then((change) => {
      if (!change) {
        return;
      }
      const tab2 = tabsList.value.find((itemOption) => itemOption.props.id === id);
      if (tabs && tab2 && !tab2.props.disabled) {
        tabs.state.active = id;
        if (props.type === "slider" && tabEl && tabsEle && tabsEle.value) {
          if (["left", "right"].includes(props.tabPosition)) {
            data.offsetLeft = tabEl.getBoundingClientRect().left - tabsEle.value.nativeElement.getBoundingClientRect().left;
          } else {
            data.offsetTop = tabEl.getBoundingClientRect().top - tabsEle.value.nativeElement.getBoundingClientRect().top;
            data.offsetHeight = tabEl.getBoundingClientRect().height;
          }
          data.offsetWidth = tabEl.getBoundingClientRect().width;
        }
        ctx2.emit("active-tab-change", tab2.props.id);
      }
    });
  };
  const beforeMount = () => {
    if (props.type !== "slider" && props.modelValue === void 0 && tabsList.value && tabsList.value.length > 0) {
      activeClick(tabsList.value[0]);
    }
  };
  const mounted = () => {
    var _a;
    if (props.type === "slider" && props.modelValue === void 0 && tabsList.value && tabsList.value.length > 0 && tabsList.value[0]) {
      const tabsStateData = tabsList.value[0];
      const dom = (_a = tabsStateData.tabsEle) == null ? void 0 : _a.value;
      const ele = dom == null ? void 0 : dom.getElementById(tabsStateData.tabId);
      activeClick(ele);
    }
  };
  const tabCanClose = (item) => {
    return (props.closeable || item.closeable) && !item.disabled;
  };
  return { update, activeClick, beforeMount, mounted, tabCanClose };
}
function useTabNavEvent(ctx2) {
  const onTabRemove = (item, ev) => {
    ev.stopPropagation();
    ctx2.emit("tab-remove", item.props, ev);
    ctx2.emit("tab-change", item.props.id, "delete");
  };
  const onTabAdd = () => {
    ctx2.emit("tab-add");
    ctx2.emit("tab-change", void 0, "add");
  };
  return { onTabRemove, onTabAdd };
}
var tabNav = "";
var TabNav = defineComponent({
  name: "DTabNav",
  props: tabsProps,
  emits: ["active-tab-change", "tab-remove", "tab-add", "tab-change"],
  setup(props, ctx2) {
    const ns2 = useNamespace("tabs");
    const tabsEle = shallowRef();
    const data = reactive({
      offsetLeft: 0,
      offsetWidth: 0,
      offsetTop: 0,
      offsetHeight: 0,
      id: null
    });
    const tabs = inject("tabs");
    const tabsList = computed(() => Object.values((tabs == null ? void 0 : tabs.state.data) || {}));
    const {
      ulClasses,
      aClasses,
      customStyle,
      sliderAnimationStyle
    } = useTabNavRender(props, data);
    const {
      update,
      beforeMount,
      mounted,
      activeClick,
      tabCanClose
    } = useTabNavFunction(props, tabs, tabsList, data, ctx2, tabsEle);
    const {
      onTabRemove,
      onTabAdd
    } = useTabNavEvent(ctx2);
    const handleTabAdd = () => {
      onTabAdd();
      nextTick(() => {
        if (tabsEle.value) {
          tabsEle.value.scrollLeft = tabsEle.value.scrollWidth;
        }
      });
    };
    let isSlide = false;
    const handleSlideTab = (mousedownEvent) => {
      if (tabsEle.value) {
        const mousedownX = mousedownEvent.clientX;
        const scrollLeft = tabsEle.value.scrollLeft;
        isSlide = true;
        tabsEle.value.addEventListener("mousemove", (mousemoveEvent) => {
          if (isSlide && tabsEle.value) {
            const mousemoveX = mousemoveEvent.clientX;
            const scrollWidth = mousemoveX - mousedownX;
            tabsEle.value.scrollLeft = scrollLeft - scrollWidth;
          }
        });
        tabsEle.value.addEventListener("mouseup", () => {
          isSlide = false;
        });
        tabsEle.value.addEventListener("mouseleave", () => {
          isSlide = false;
        });
      }
    };
    onUpdated(() => update());
    onBeforeMount(() => beforeMount());
    onMounted(() => {
      mounted();
      if (tabsEle.value) {
        tabsEle.value.addEventListener("mousedown", handleSlideTab);
      }
    });
    onUnmounted(() => {
      if (tabsEle.value) {
        tabsEle.value.removeEventListener("mousedown", handleSlideTab);
      }
    });
    watch(() => props.modelValue, () => {
      nextTick(() => {
        const tab2 = tabsList.value.find((item) => item.props.id === props.modelValue);
        if (tab2) {
          activeClick(tab2);
        }
      });
    });
    return () => {
      const closeIconEl = (item) => {
        return tabCanClose(item) ? createVNode("span", {
          "class": ns2.e("close-btn"),
          "onClick": (ev) => onTabRemove(item, ev)
        }, [createVNode(resolveComponent("d-icon"), {
          "size": "12px",
          "name": "error-o"
        }, null)]) : null;
      };
      const newButton = props.addable ? createVNode("li", {
        "class": ns2.e("new-tab"),
        "onClick": handleTabAdd
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "add"
      }, null)]) : null;
      return createVNode("ul", {
        "ref": tabsEle,
        "role": "tablist",
        "class": ulClasses.value
      }, [(tabsList.value || []).map((item) => {
        return createVNode("li", {
          "role": "presentation",
          "onClick": () => {
            activeClick(item);
          },
          "class": (props.modelValue === item.props.id ? "active" : "") + (item.props.disabled ? " disabled" : ""),
          "id": item.props.id
        }, [createVNode("span", {
          "class": ns2.e("nav-content")
        }, [createVNode("a", {
          "role": "tab",
          "data-toggle": item.props.id,
          "aria-expanded": props.modelValue === item.props.id,
          "class": aClasses.value,
          "style": customStyle
        }, [item.slots.title ? item.slots.title() : createVNode("span", null, [item.props.title])]), closeIconEl(item)])]);
      }), newButton, createVNode("div", {
        "class": ns2.e(`nav-${props.type}-animation`),
        "style": sliderAnimationStyle.value
      }, null)]);
    };
  }
});
const ns$f = useNamespace("tabs");
function useTabsEvent(ctx2) {
  const onUpdateModelValue = (value) => {
    ctx2.emit("update:modelValue", value);
  };
  const onActiveTabChange = (value) => {
    ctx2.emit("active-tab-change", value);
  };
  const onTabRemove = (item, ev) => {
    ctx2.emit("tab-remove", item, ev);
  };
  const onTabAdd = () => {
    ctx2.emit("tab-add");
  };
  const onTabChange = (id, type4) => {
    ctx2.emit("tab-change", id, type4);
  };
  return { onUpdateModelValue, onActiveTabChange, onTabRemove, onTabAdd, onTabChange };
}
function useTabsRender(props) {
  const tabsClasses = computed(() => ({
    [ns$f.b()]: true,
    [ns$f.m(props.tabPosition)]: true
  }));
  return { tabsClasses };
}
var Tabs = defineComponent({
  name: "DTabs",
  props: tabsProps,
  emits: ["update:modelValue", "active-tab-change", "tab-remove", "tab-add", "tab-change"],
  setup(props, ctx2) {
    const state = reactive({
      data: {},
      active: props.modelValue,
      showContent: props.showContent
    });
    const addTab = (tabCtx) => {
      if (tabCtx.uid) {
        state.data[tabCtx.uid] = tabCtx;
      }
    };
    const deleteTab = (uid) => {
      if (uid) {
        delete state.data[uid];
      }
    };
    provide("tabs", {
      state,
      addTab,
      deleteTab
    });
    const {
      onUpdateModelValue,
      onActiveTabChange,
      onTabRemove,
      onTabAdd,
      onTabChange
    } = useTabsEvent(ctx2);
    const {
      tabsClasses
    } = useTabsRender(props);
    watch(() => state.active, () => {
      onUpdateModelValue(state.active);
    });
    return () => {
      var _a, _b;
      const tabNav2 = createVNode(TabNav, mergeProps(props, {
        "onActiveTabChange": onActiveTabChange,
        "onTabRemove": onTabRemove,
        "onTabAdd": onTabAdd,
        "onTabChange": onTabChange
      }), null);
      const content2 = (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a);
      return createVNode("div", {
        "class": tabsClasses.value
      }, [props.tabPosition === "bottom" ? [content2, tabNav2] : [tabNav2, content2], createVNode("div", {
        "style": "clear: both"
      }, null)]);
    };
  }
});
const tabProps = {
  title: {
    type: [String, Number],
    default: null
  },
  id: {
    type: String,
    default: null
  },
  disabled: {
    type: Boolean,
    default: false
  },
  closeable: {
    type: Boolean,
    default: false
  }
};
var tab = "";
var Tab = defineComponent({
  name: "DTab",
  props: tabProps,
  setup(props, {
    slots
  }) {
    const tabs = inject("tabs");
    const ns2 = useNamespace("tab");
    const instance = getCurrentInstance();
    const tabContext = reactive({
      uid: instance == null ? void 0 : instance.uid,
      slots,
      props
    });
    onMounted(() => {
      tabs == null ? void 0 : tabs.addTab(tabContext);
    });
    onUnmounted(() => {
      tabs == null ? void 0 : tabs.deleteTab(tabContext.uid);
    });
    return () => {
      var _a;
      const {
        id
      } = props;
      const content2 = (tabs == null ? void 0 : tabs.state.showContent) && tabs.state.active === id ? createVNode("div", {
        "class": ns2.e("content")
      }, [createVNode("div", {
        "role": "tabpanel"
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]) : null;
      return content2;
    };
  }
});
var TabsInstall = {
  title: "Tabs \u9009\u9879\u5361",
  category: "\u5BFC\u822A",
  status: "100%",
  install(app) {
    app.component(Tabs.name, Tabs);
    app.component(Tab.name, Tab);
  }
};
const isObject$6 = (val) => val !== null && typeof val === "object";
const isString = (val) => typeof val === "string";
class DOMUtils {
  static isWindow(val) {
    return val === window;
  }
  static addEventListener(element, event, handler, options = false) {
    if (element && event && handler) {
      element.addEventListener(event, handler, options);
    }
  }
  static removeEventListener(element, event, handler, options = false) {
    if (element && event && handler) {
      element.removeEventListener(event, handler, options);
    }
  }
  static triggerDragEvent(element, options) {
    let isDragging = false;
    const moveFn = function(event) {
      var _a;
      (_a = options.drag) == null ? void 0 : _a.call(options, event);
    };
    const upFn = (event) => {
      var _a;
      DOMUtils.removeEventListener(document, "mousemove", moveFn);
      DOMUtils.removeEventListener(document, "mouseup", upFn);
      DOMUtils.removeEventListener(document, "touchmove", moveFn);
      DOMUtils.removeEventListener(document, "touchend", upFn);
      document.onselectstart = null;
      document.ondragstart = null;
      isDragging = false;
      (_a = options.end) == null ? void 0 : _a.call(options, event);
    };
    const downFn = (event) => {
      var _a;
      if (isDragging) {
        return;
      }
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      DOMUtils.addEventListener(document, "mousemove", moveFn);
      DOMUtils.addEventListener(document, "mouseup", upFn);
      DOMUtils.addEventListener(document, "touchmove", moveFn);
      DOMUtils.addEventListener(document, "touchend", upFn);
      isDragging = true;
      (_a = options.start) == null ? void 0 : _a.call(options, event);
    };
    DOMUtils.addEventListener(element, "mousedown", downFn);
    DOMUtils.addEventListener(element, "touchstart", downFn);
    return;
  }
  static getBoundingClientRect(element) {
    if (element && isObject$6(element) && element.nodeType === 1) {
      return element.getBoundingClientRect();
    }
    return null;
  }
  static hasClass(element, className2) {
    if (element && isObject$6(element) && isString(className2) && element.nodeType === 1) {
      return element.classList.contains(className2.trim());
    }
    return false;
  }
  static addClass(element, className2) {
    if (element && isObject$6(element) && isString(className2) && element.nodeType === 1) {
      className2 = className2.trim();
      if (!DOMUtils.hasClass(element, className2)) {
        const cl = element.className;
        element.className = cl ? cl + " " + className2 : className2;
      }
    }
  }
  static removeClass(element, className2) {
    if (element && isObject$6(element) && isString(className2) && element.nodeType === 1 && typeof element.className === "string") {
      className2 = className2.trim();
      const classes = element.className.trim().split(" ");
      for (let i = classes.length - 1; i >= 0; i--) {
        classes[i] = classes[i].trim();
        if (!classes[i] || classes[i] === className2) {
          classes.splice(i, 1);
        }
      }
      element.className = classes.join(" ");
    }
  }
  static toggleClass(element, className2, force) {
    if (element && isObject$6(element) && isString(className2) && element.nodeType === 1) {
      element.classList.toggle(className2, force);
    }
  }
  static replaceClass(element, oldClassName, newClassName) {
    if (element && isObject$6(element) && isString(oldClassName) && isString(newClassName) && element.nodeType === 1) {
      oldClassName = oldClassName.trim();
      newClassName = newClassName.trim();
      DOMUtils.removeClass(element, oldClassName);
      DOMUtils.addClass(element, newClassName);
    }
  }
  static getScrollTop(el) {
    const top = "scrollTop" in el ? el.scrollTop : el.pageYOffset;
    return Math.max(top, 0);
  }
  static setScrollTop(el, value) {
    if ("scrollTop" in el) {
      el.scrollTop = value;
    } else {
      el.scrollTo(el.scrollX, value);
    }
  }
  static getRootScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  static setRootScrollTop(value) {
    DOMUtils.setScrollTop(window, value);
    DOMUtils.setScrollTop(document.body, value);
  }
  static getElementTop(el, scroller) {
    if (DOMUtils.isWindow(el)) {
      return 0;
    }
    const scrollTop = scroller ? DOMUtils.getScrollTop(scroller) : DOMUtils.getRootScrollTop();
    return el.getBoundingClientRect().top + scrollTop;
  }
  static getVisibleHeight(el) {
    if (DOMUtils.isWindow(el)) {
      return el.innerHeight;
    }
    return el.getBoundingClientRect().height;
  }
  static isHidden(el) {
    if (!el) {
      return false;
    }
    const style = window.getComputedStyle(el);
    const hidden = style.display === "none";
    const parentHidden = el.offsetParent === null && style.position !== "fixed";
    return hidden || parentHidden;
  }
  static triggerEvent(el, type4) {
    if ("createEvent" in document) {
      const e = document.createEvent("HTMLEvents");
      e.initEvent(type4, false, true);
      el.dispatchEvent(e);
    }
  }
  static calcAngle(element, event) {
    const rect = element.getBoundingClientRect();
    const originX = rect.left + rect.width / 2;
    const originY = rect.top + rect.height / 2;
    const x = Math.abs(originX - event.clientX);
    const y = Math.abs(originY - event.clientY);
    const z = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    const cos = y / z;
    const rad = Math.acos(cos);
    let angle = Math.floor(180 / (Math.PI / rad));
    if (event.clientX > originX && event.clientY > originY) {
      angle = 180 - angle;
    }
    if (event.clientX === originX && event.clientY > originY) {
      angle = 180;
    }
    if (event.clientX > originX && event.clientY === originY) {
      angle = 90;
    }
    if (event.clientX < originX && event.clientY > originY) {
      angle = 180 + angle;
    }
    if (event.clientX < originX && event.clientY === originY) {
      angle = 270;
    }
    if (event.clientX < originX && event.clientY < originY) {
      angle = 360 - angle;
    }
    return angle;
  }
  static querySelector(selectors, parentElement) {
    if (parentElement) {
      return parentElement.querySelector(selectors);
    }
    return document.querySelector(selectors);
  }
}
function padEnd(str, length, char = "0") {
  return str + char.repeat(Math.max(0, length - str.length));
}
function chunk(str, size = 1) {
  const chunked = [];
  let index2 = 0;
  while (index2 < str.length) {
    chunked.push(str.substr(index2, size));
    index2 += size;
  }
  return chunked;
}
const clamp = (value, min, max) => {
  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
};
function keepDecimal(value, digits = 0) {
  const COUNT_VALUE = 10 ** digits;
  return Math.round(value * COUNT_VALUE) / COUNT_VALUE;
}
function has(obj, key) {
  return key.every((k) => obj.hasOwnProperty(k));
}
function HSVAtoRGBA(hsva) {
  const { h: h2, s, v, a } = hsva;
  const f = (n) => {
    const k = (n + h2 / 60) % 6;
    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  };
  const rgb = [f(5), f(3), f(1)].map((cv) => Math.round(cv * 255));
  return { r: rgb[0], g: rgb[1], b: rgb[2], a };
}
function RGBAtoHSVA(rgba) {
  if (!rgba) {
    return { h: 0, s: 1, v: 1, a: 1 };
  }
  const r = rgba.r / 255;
  const g = rgba.g / 255;
  const b = rgba.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h2 = 0;
  if (max !== min) {
    if (max === r) {
      h2 = 60 * (0 + (g - b) / (max - min));
    } else if (max === g) {
      h2 = 60 * (2 + (b - r) / (max - min));
    } else if (max === b) {
      h2 = 60 * (4 + (r - g) / (max - min));
    }
  }
  if (h2 < 0) {
    h2 = h2 + 360;
  }
  const s = max === 0 ? 0 : (max - min) / max;
  const hsv = [h2, s, max];
  return { h: Math.round(hsv[0]), s: hsv[1], v: hsv[2], a: rgba.a };
}
function HSVAtoHSLA(hsva) {
  const { h: h2, s, v, a } = hsva;
  const l = v - v * s / 2;
  const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
  return { h: Math.round(h2), s: sprime, l, a };
}
function HSLAtoHSVA(hsl) {
  const { h: h2, s, l, a } = hsl;
  const v = l + s * Math.min(l, 1 - l);
  const sprime = v === 0 ? 0 : 2 - 2 * l / v;
  return { h: Math.round(h2), s: sprime, v, a };
}
function RGBAtoCSS(rgba) {
  return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
}
function RGBtoCSS(rgba) {
  return RGBAtoCSS(__spreadProps(__spreadValues({}, rgba), { a: 1 }));
}
function RGBAtoHex(rgba) {
  const toHex = (v) => {
    const h2 = Math.round(v).toString(16);
    return ("00".substring(0, 2 - h2.length) + h2).toUpperCase();
  };
  return `#${[toHex(rgba.r), toHex(rgba.g), toHex(rgba.b), toHex(Math.round(rgba.a * 255))].join("")}`;
}
function HexToRGBA(hex2) {
  const rgba = chunk(hex2.slice(1), 2).map((c) => parseInt(c, 16));
  return {
    r: rgba[0],
    g: rgba[1],
    b: rgba[2],
    a: Math.round(rgba[3] / 255 * 100) / 100
  };
}
function HexToHSVA(hex2) {
  const rgb = HexToRGBA(hex2);
  return RGBAtoHSVA(rgb);
}
function HSVAtoHex(hsva) {
  return RGBAtoHex(HSVAtoRGBA(hsva));
}
function parseHex(hex2) {
  if (hex2.startsWith("#")) {
    hex2 = hex2.slice(1);
  }
  hex2 = hex2.replace(/([^0-9a-f])/gi, "F");
  if (hex2.length === 3 || hex2.length === 4) {
    hex2 = hex2.split("").map((x) => x + x).join("");
  }
  if (hex2.length === 6) {
    hex2 = padEnd(hex2, 8, "F");
  } else {
    hex2 = padEnd(padEnd(hex2, 6), 8, "F");
  }
  return `#${hex2}`.toUpperCase().substring(0, 9);
}
function fromHSVA(hsva) {
  hsva = __spreadValues({}, hsva);
  const hexa = HSVAtoHex(hsva);
  const hsla = HSVAtoHSLA(hsva);
  const rgba = HSVAtoRGBA(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substring(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromRGBA(rgba) {
  const hsva = RGBAtoHSVA(rgba);
  const hexa = RGBAtoHex(rgba);
  const hsla = HSVAtoHSLA(hsva);
  const hsv = { h: hsva.h, s: hsva.s, v: hsva.v };
  const hsl = { h: hsla.h, s: hsla.s, l: hsla.l };
  return {
    alpha: hsva.a,
    hex: hexa.substring(0, 7),
    hexa,
    hsla,
    hsva,
    hsv,
    hsl,
    hue: hsva.h,
    rgba
  };
}
function fromHexa(hexa) {
  const hsva = HexToHSVA(hexa);
  const hsla = HSVAtoHSLA(hsva);
  const rgba = HSVAtoRGBA(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substring(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromHSLA(hsla) {
  const hsva = HSLAtoHSVA(hsla);
  const hexa = HSVAtoHex(hsva);
  const rgba = HSVAtoRGBA(hsva);
  return {
    alpha: hsva.a,
    hex: hexa.substring(0, 7),
    hexa,
    hsla,
    hsva,
    hue: hsva.h,
    rgba
  };
}
function fromHex(hex2) {
  return fromHexa(parseHex(hex2));
}
function parseColor(color2, oldColor) {
  if (!color2) {
    return fromRGBA({ r: 0, g: 0, b: 0, a: 1 });
  }
  if (typeof color2 === "string") {
    if (color2.indexOf("#") !== -1)
      ;
    else if (color2.indexOf("hsl") !== -1) {
      let alpha = 0;
      const parts = color2.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val) => parseFloat(val));
      if (parts.length === 4) {
        alpha = parts[3];
      } else if (parts.length === 3) {
        alpha = 1;
      }
      return fromHSLA({ h: parts[0], s: parts[1], l: parts[2], a: alpha });
    } else if (color2.indexOf("rgb") !== -1) {
      let alpha = 0;
      const parts = color2.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val) => parseFloat(val));
      if (parts.length === 4) {
        alpha = parts[3];
      } else if (parts.length === 3) {
        alpha = 1;
      }
      return fromRGBA({ r: parts[0], g: parts[1], b: parts[2], a: alpha });
    } else if (color2.indexOf("hsv") !== -1) {
      let alpha = 0;
      const parts = color2.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val) => parseFloat(val));
      if (parts.length === 4) {
        alpha = parts[3];
      } else if (parts.length === 3) {
        alpha = 1;
      }
      return fromHSVA({ h: parts[0], s: parts[1], v: parts[2], a: alpha });
    }
    if (color2 === "transparent") {
      return fromHexa("#00000000");
    }
    const hex2 = parseHex(color2);
    if (oldColor && hex2 === oldColor.hexa) {
      return oldColor;
    } else {
      return fromHexa(hex2);
    }
  }
  if (typeof color2 === "object") {
    if (color2.hasOwnProperty("alpha")) {
      return color2;
    }
    const a = color2.hasOwnProperty("a") ? parseFloat(color2.a) : 1;
    if (has(color2, ["r", "g", "b"])) {
      if (oldColor && color2 === oldColor.rgba) {
        return oldColor;
      } else {
        return fromRGBA(__spreadProps(__spreadValues({}, color2), { a }));
      }
    } else if (has(color2, ["h", "s", "l"])) {
      if (oldColor && color2 === oldColor.hsla) {
        return oldColor;
      } else {
        return fromHSLA(__spreadProps(__spreadValues({}, color2), { a }));
      }
    } else if (has(color2, ["h", "s", "v"])) {
      if (oldColor && color2 === oldColor.hsva) {
        return oldColor;
      } else {
        return fromHSVA(__spreadProps(__spreadValues({}, color2), { a }));
      }
    }
  }
  return fromRGBA({ r: 255, g: 0, b: 0, a: 1 });
}
function stripAlpha(color2, curStripAlpha) {
  if (curStripAlpha) {
    return omit(color2, ["a"]);
  }
  return color2;
}
function extractColor(color2, input2, mode, showAlpha) {
  const hue = keepDecimal(color2.hsla.h, 2);
  const hslSaturation = keepDecimal(color2.hsla.s, 2);
  const lightness = keepDecimal(color2.hsla.l, 2);
  const red = keepDecimal(color2.rgba.r);
  const green = keepDecimal(color2.rgba.g);
  const blue = keepDecimal(color2.rgba.b);
  const hsvSaturation = keepDecimal(color2.hsva.s, 2);
  const value = keepDecimal(color2.hsva.v, 2);
  if (input2 == null) {
    return color2;
  }
  function isShowAlpha(curMode) {
    return showAlpha ? curMode + "a" : curMode;
  }
  if (typeof input2 === "string") {
    if (mode === "hex") {
      return showAlpha ? color2.hexa : color2.hex;
    } else if (mode === "hsl") {
      return `${isShowAlpha(mode)}(${hue}, ${hslSaturation}, ${lightness}${showAlpha ? ", " + color2.alpha : ""})`;
    } else if (mode === "rgb") {
      return `${isShowAlpha(mode)}(${red}, ${green}, ${blue}${showAlpha ? ", " + color2.alpha : ""})`;
    } else if (mode === "hsv") {
      return `${isShowAlpha(mode)}(${hue}, ${hsvSaturation}, ${value}${showAlpha ? ", " + color2.alpha : ""})`;
    }
    return input2.length === 7 ? color2.hex : color2.hexa;
  }
  if (typeof input2 === "object") {
    const shouldStrip = typeof input2.a === "number" && input2.a === 0 ? !!input2.a : !input2.a;
    if (has(input2, ["r", "g", "b"])) {
      return stripAlpha(color2.rgba, shouldStrip);
    } else if (has(input2, ["h", "s", "l"])) {
      return stripAlpha(color2.hsla, shouldStrip);
    } else if (has(input2, ["h", "s", "v"])) {
      return stripAlpha(color2.hsva, shouldStrip);
    }
  }
}
const colorPickerPaletteProps = {
  modelValue: {
    type: Object,
    default: () => fromRGBA({ r: 255, g: 0, b: 0, a: 1 })
  },
  height: {
    type: Number,
    default: 200
  }
};
var colorPalette$1 = "";
var colorPalette = defineComponent({
  name: "ColorPalette",
  props: colorPickerPaletteProps,
  emits: ["update:modelValue", "changeTextColor"],
  setup(props, ctx2) {
    const DEFAULT_TRANSITION = {
      transition: "all 0.3s ease"
    };
    const dotSizeInject = inject("provideData");
    const clickTransform = ref(DEFAULT_TRANSITION);
    const paletteElement = ref(null);
    const canvasElement = ref(null);
    const handlerElement = ref(null);
    const paletteInstance = getCurrentInstance();
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const getDotStyle = computed(() => {
      return {
        width: `${dotSizeInject.dotSize}px`,
        height: `${dotSizeInject.dotSize}px`,
        transform: `translate(-${(dotSizeInject == null ? void 0 : dotSizeInject.dotSize) || 0 / 2}px,  -${(dotSizeInject == null ? void 0 : dotSizeInject.dotSize) || 0 / 2}px)`
      };
    });
    const getCursorStyle = computed(() => {
      return __spreadValues({
        top: cursorTop.value + "px",
        left: cursorLeft.value + "px"
      }, clickTransform.value);
    });
    function renderCanvas() {
      var _a;
      if (canvasElement.value) {
        const canvas = canvasElement.value.getContext("2d");
        if (canvas) {
          const parentWidth = ((_a = paletteElement.value) == null ? void 0 : _a.offsetWidth) || 0;
          canvasElement.value.width = parentWidth;
          canvasElement.value.height = props.height;
          const saturationGradient = canvas.createLinearGradient(0, 0, parentWidth, 0);
          saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)");
          saturationGradient.addColorStop(1, `hsla(${props.modelValue.hue}, 100%, 50%, 1)`);
          canvas.fillStyle = saturationGradient;
          canvas.fillRect(0, 0, parentWidth, props.height);
          const valueGradient = canvas.createLinearGradient(0, 0, 0, props.height);
          valueGradient.addColorStop(0, "hsla(0, 0%, 100%, 0)");
          valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)");
          canvas.fillStyle = valueGradient;
          canvas.fillRect(0, 0, parentWidth, props.height);
        }
      }
    }
    function handleDrag(event) {
      var _a;
      const parentWidth = ((_a = paletteElement.value) == null ? void 0 : _a.offsetWidth) || 0;
      if (paletteInstance) {
        const el = canvasElement.value;
        const rect = el == null ? void 0 : el.getBoundingClientRect();
        let left = event.clientX - rect.left;
        let top = event.clientY - rect.top;
        left = clamp(left, 0, parentWidth);
        top = clamp(top, 0, props.height);
        cursorLeft.value = left;
        cursorTop.value = top;
        const isChangeTextColor = computed(() => {
          if (left > rect.width / 2 || top > rect.height / 2) {
            return true;
          } else {
            return false;
          }
        });
        ctx2.emit("update:modelValue", fromHSVA({
          h: props.modelValue.hue,
          s: clamp(event.clientX - rect.left, 0, rect.width) / rect.width,
          v: 1 - clamp(event.clientY - rect.top, 0, rect.height) / rect.height,
          a: props.modelValue.alpha
        }));
        ctx2.emit("changeTextColor", isChangeTextColor.value);
      }
    }
    function clickPalette(event) {
      const target = event.target;
      if (target !== paletteElement.value) {
        handleDrag(event);
      }
    }
    function updatePosition() {
      var _a, _b, _c;
      if (paletteInstance) {
        const parentWidth = ((_a = paletteElement.value) == null ? void 0 : _a.offsetWidth) || 0;
        cursorLeft.value = Number((_b = props.modelValue) == null ? void 0 : _b.hsva.s) * parentWidth;
        cursorTop.value = (1 - Number((_c = props.modelValue) == null ? void 0 : _c.hsva.v)) * props.height;
      }
    }
    onMounted(() => {
      renderCanvas();
      if (paletteInstance && paletteInstance.vnode.el && handlerElement.value) {
        DOMUtils.triggerDragEvent(paletteInstance.vnode.el, {
          drag: (event) => {
            clickTransform.value = null;
            handleDrag(event);
          },
          end: (event) => {
            clickTransform.value = DEFAULT_TRANSITION;
            handleDrag(event);
          }
        });
        updatePosition();
      }
    });
    watch(() => props.modelValue, () => {
      updatePosition();
    });
    ctx2.expose({
      renderCanvas
    });
    return () => {
      return createVNode("div", {
        "class": "devui-color-picker-palette",
        "ref": paletteElement,
        "onClick": clickPalette
      }, [createVNode("canvas", {
        "ref": canvasElement
      }, null), createVNode("div", {
        "class": "devui-color-picker-palette-handler",
        "style": getCursorStyle.value
      }, [createVNode("div", {
        "ref": handlerElement,
        "style": getDotStyle.value
      }, null)])]);
    };
  }
});
const colorPickerHueSliderProps = {
  color: {
    type: Object
  },
  modelValue: {
    type: Object
  },
  width: {
    type: Number,
    default: 300
  },
  height: {
    type: Number,
    default: 15
  }
};
var colorHueSlider$1 = "";
var colorHueSlider = defineComponent({
  name: "ColorHueSlider",
  props: colorPickerHueSliderProps,
  emits: ["update:modelValue"],
  setup(props, ctx2) {
    const DEFAULT_TRANSITION = {
      transition: "all 0.3s ease"
    };
    const barElement = ref(null);
    const cursorElement = ref(null);
    const clickTransform = ref(DEFAULT_TRANSITION);
    const getCursorLeft = () => {
      var _a;
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        if (((_a = props.modelValue) == null ? void 0 : _a.hue) === 360) {
          return rect.width - offsetWidth / 2;
        }
        return props.modelValue.hue % 360 * (rect.width - offsetWidth) / 360 + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left = getCursorLeft();
      return __spreadValues({
        left: left + "px",
        top: 0
      }, clickTransform.value);
    });
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left = event.clientX - rect.left;
        left = Math.min(left, rect.width - offsetWidth / 2);
        left = Math.max(offsetWidth / 2, left);
        const hue = Math.round((left - offsetWidth / 2) / (rect.width - offsetWidth) * 360);
        ctx2.emit("update:modelValue", fromHSVA({
          h: hue,
          s: props.modelValue.hsva.s,
          v: props.modelValue.hsva.v,
          a: props.modelValue.hsva.a
        }));
      }
    };
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          clickTransform.value = null;
          onMoveBar(event);
        },
        end: (event) => {
          clickTransform.value = DEFAULT_TRANSITION;
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        DOMUtils.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return () => {
      return createVNode("div", {
        "class": "devui-color-picker-hue-slider"
      }, [createVNode("div", {
        "ref": barElement,
        "class": "devui-color-picker-hue-slider__bar",
        "onClick": onClickSider
      }, [createVNode("div", {
        "class": "devui-color-picker-hue-slider__bar-pointer",
        "ref": cursorElement,
        "style": getCursorStyle.value
      }, [createVNode("div", {
        "class": "devui-color-picker-hue-slider__bar-handle"
      }, null)])])]);
    };
  }
});
const colorPickerAlphaSliderProps = {
  color: {
    type: Object
  },
  modelValue: {
    type: Object,
    default: {}
  },
  rgba: {
    type: Object,
    default: null
  },
  height: {
    type: Number,
    default: 15
  },
  width: {
    type: Number,
    default: 300
  }
};
var colorAlphaSlider$1 = "";
var colorAlphaSlider = defineComponent({
  name: "ColorAlphaSlider",
  props: colorPickerAlphaSliderProps,
  emits: ["update:modelValue"],
  setup(props, ctx2) {
    const DEFAULT_TRANSITION = {
      transition: "all 0.3s ease"
    };
    const clickTransform = ref(DEFAULT_TRANSITION);
    const barElement = ref(null);
    const cursorElement = ref(null);
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left = event.clientX - rect.left;
        left = Math.max(offsetWidth / 2, left);
        left = Math.min(left, rect.width - offsetWidth / 2);
        const alpha = Math.round((left - offsetWidth / 2) / (rect.width - offsetWidth) * 100);
        ctx2.emit("update:modelValue", fromHSVA(__spreadProps(__spreadValues({}, props.modelValue.hsva), {
          a: alpha / 100
        })));
      }
    };
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const getBackgroundStyle = computed(() => {
      return {
        background: `linear-gradient(to right, transparent , ${RGBtoCSS(props.modelValue.rgba)})`
      };
    });
    const getCursorLeft = computed(() => {
      if (barElement.value && cursorElement.value) {
        const alpha = props.modelValue.rgba.a;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const getCursorStyle = computed(() => {
      const left = getCursorLeft.value;
      return __spreadValues({
        left: left + "px",
        top: 0
      }, clickTransform.value);
    });
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          clickTransform.value = null;
          onMoveBar(event);
        },
        end: (event) => {
          clickTransform.value = DEFAULT_TRANSITION;
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        DOMUtils.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    const alphaClass = computed(() => {
      return ["devui-color-picker-alpha-slider", "transparent"];
    });
    return () => {
      return createVNode("div", {
        "class": alphaClass.value
      }, [createVNode("div", {
        "ref": barElement,
        "class": "devui-color-picker-alpha-slider__bar",
        "style": getBackgroundStyle.value,
        "onClick": onClickSider
      }, [createVNode("div", {
        "class": ["devui-color-picker-alpha-slider__bar-pointer"],
        "ref": cursorElement,
        "style": getCursorStyle.value
      }, [createVNode("div", {
        "class": "devui-color-picker-alpha-slider__bar-handle"
      }, null)])])]);
    };
  }
});
const colorPickerEditProps = {
  showAlpha: {
    type: Boolean,
    default: false
  },
  mode: {
    type: String
  },
  color: {
    type: Object
  }
};
var colorEdit$1 = "";
const DEFAULT_MODE = "rgb";
const MODE_SUPPORT = ["rgb", "hex", "hsl", "hsv"];
const colorRules = {
  alpha: [{
    type: "number",
    required: true,
    min: 0,
    max: 1
  }],
  hex: [{
    type: "string",
    pattern: /^#[0-9a-fA-F]{6}/
  }],
  hexa: [{
    type: "string",
    pattern: /^#[0-9a-fA-F]{6,8}/
  }],
  rgba: {
    type: "object",
    required: true,
    fields: {
      r: {
        type: "number",
        required: true,
        min: 0,
        max: 255
      },
      g: {
        type: "number",
        required: true,
        min: 0,
        max: 255
      },
      b: {
        type: "number",
        required: true,
        min: 0,
        max: 255
      },
      a: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      }
    }
  },
  hsla: {
    type: "object",
    required: true,
    fields: {
      h: {
        type: "number",
        required: true,
        min: 0,
        max: 360
      },
      s: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      },
      l: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      },
      a: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      }
    }
  },
  hsva: {
    type: "object",
    required: true,
    fields: {
      h: {
        type: "number",
        required: true,
        min: 0,
        max: 360
      },
      s: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      },
      v: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      },
      a: {
        type: "number",
        required: true,
        min: 0,
        max: 1
      }
    }
  }
};
var colorEdit = defineComponent({
  name: "ColorEdit",
  props: colorPickerEditProps,
  emits: ["changeTextModeColor", "update:modelValue"],
  setup(props, {
    emit
  }) {
    const isShowAlpha = inject("provideData");
    const modelValue = computed(() => {
      var _a;
      return `${(_a = props.mode) != null ? _a : DEFAULT_MODE}${isShowAlpha.showAlpha ? "a" : ""}`;
    });
    const colorValue = ref(props.color);
    const modelValueType = computed(() => {
      var _a;
      return ((_a = props.mode) != null ? _a : DEFAULT_MODE) === "hex" ? "string" : "number";
    });
    function getValidColor(color2) {
      const validator = new Schema(colorRules);
      return new Promise((resolve, reject) => {
        validator.validate(color2, (errors) => {
          errors && console.warn("\u8272\u503C\u6821\u9A8C\u5F02\u5E38:", errors);
          errors ? reject() : resolve(color2);
        });
      });
    }
    function onChangeModel() {
      const currentIndex = MODE_SUPPORT.findIndex((x) => x === props.mode);
      const mode = MODE_SUPPORT[(currentIndex + 1) % MODE_SUPPORT.length];
      emit("changeTextModeColor", mode);
    }
    function renderStringValue() {
      var _a;
      const key = modelValue.value;
      const value = (_a = colorValue.value) == null ? void 0 : _a[key];
      const getConvertColor = (v) => {
        const from = isShowAlpha.showAlpha ? fromHexa : fromHex;
        const color2 = from(v);
        return getValidColor(color2);
      };
      const updateValue = async (event) => {
        const target = event.target;
        getConvertColor(target.value).then((color2) => colorValue.value = color2).catch(() => target.value = value);
      };
      return createVNode("div", {
        "class": "devui-color-picker-edit-input string-input flex"
      }, [createVNode("div", {
        "class": "devui-color-picker-edit-input-wrapper"
      }, [createVNode("input", {
        "value": value,
        "onChange": updateValue,
        "class": "devui-color-picker-edit-input-value"
      }, null)])]);
    }
    function renderNumberValue() {
      var _a;
      const scaleKeys = ["s", "v", "l"];
      const percentKeys = ["a"];
      const key = modelValue.value;
      const value = (_a = colorValue.value) == null ? void 0 : _a[key.replace(/a?$/, "a")];
      const getConvertColor = (model) => {
        const {
          from
        } = [{
          mode: ["rgb", "rgba"],
          from: fromRGBA
        }, {
          mode: ["hsv", "hsva"],
          from: fromHSVA
        }, {
          mode: ["hsl", "hsla"],
          from: fromHSLA
        }].find((x) => x.mode.includes(key));
        const color2 = from(isShowAlpha.showAlpha ? model : __spreadProps(__spreadValues({}, model), {
          a: 1
        }));
        return getValidColor(color2);
      };
      function formatValue2(k, v) {
        switch (true) {
          case scaleKeys.includes(k):
            return (v * 100).toFixed();
          case percentKeys.includes(k):
            return `${Math.round(v * 100)}%`;
          default:
            return v.toString();
        }
      }
      function parseValue(k, v) {
        switch (true) {
          case scaleKeys.includes(k):
            return parseFloat((parseInt(v) / 100).toFixed(2));
          case percentKeys.includes(k):
            return parseFloat((parseInt(v.replace(/%$/, "")) / 100).toFixed(2));
          default:
            return Number(v);
        }
      }
      const updateValue = (k) => async (event) => {
        const target = event.target;
        getConvertColor(__spreadProps(__spreadValues({}, value), {
          [k]: parseValue(k, target.value)
        })).then((color2) => colorValue.value = color2).catch(() => target.value = formatValue2(k, value ? value[k] : 0));
      };
      function onKeyChangeValue() {
        return (e) => {
          const target = e.target;
          const changeValue = {
            ArrowUp: 1,
            ArrowDown: -1
          }[e.code];
          if (changeValue !== void 0) {
            e.preventDefault();
            const [v] = target.value.match(/\d+/g) || [];
            const newValue = (parseInt(v) + changeValue).toString();
            target.value = target.value.replace(/\d+/g, newValue);
            target.dispatchEvent(new CustomEvent("change"));
          }
        };
      }
      return createVNode("div", {
        "class": "devui-color-picker-edit-input number-input flex"
      }, [key.split("").map((k) => createVNode("div", {
        "class": "devui-color-picker-edit-input-wrapper"
      }, [createVNode("input", {
        "onKeydown": onKeyChangeValue(),
        "class": "devui-color-picker-edit-input-value",
        "value": formatValue2(k, value[k]),
        "onChange": updateValue(k)
      }, null)]))]);
    }
    function renderValueInput() {
      switch (modelValueType.value) {
        case "string":
          return renderStringValue();
        case "number":
          return renderNumberValue();
      }
    }
    return () => createVNode("div", {
      "class": "devui-color-picker-edit flex"
    }, [createVNode("div", {
      "class": "devui-color-picker-edit-name",
      "onClick": onChangeModel
    }, [modelValue.value.toUpperCase()]), renderValueInput()]);
  }
});
const colorPickerBasicColorProps = {
  color: {
    type: Object
  }
};
var colorBasic$1 = "";
const color = [
  "#ffffff",
  "#ffd7d5",
  "#ffdaa9",
  "#fffed5",
  "#d4fa00",
  "#73fcd6",
  "#a5c8ff",
  "#ffacd5",
  "#ff7faa",
  "#d6d6d6",
  "#ffacaa",
  "#ffb995",
  "#fffb00",
  "#73fa79",
  "#00fcff",
  "#78acfe",
  "#d84fa9",
  "#ff4f79",
  "#b2b2b2",
  "#d7aba9",
  "#ff6827",
  "#ffda51",
  "#00d100",
  "#00d5ff",
  "#0080ff",
  "#ac39ff",
  "#ff2941",
  "#888888",
  "#7a4442",
  "#ff4c00",
  "#ffa900",
  "#3da742",
  "#3daad6",
  "#0052ff",
  "#7a4fd6",
  "#d92142",
  "#000000",
  "#7b0c00",
  "#ff4c41",
  "#d6a841",
  "#407600",
  "#007aaa",
  "#021eaa",
  "#797baa",
  "#ab1942"
];
var colorBasic = defineComponent({
  name: "ColorBasic",
  props: colorPickerBasicColorProps,
  setup(props) {
    var _a;
    const swatchesInject = inject("provideData");
    const currentColor = ref(props.color);
    function changeBasicColor(hex2) {
      if (currentColor.value) {
        currentColor.value = fromHex(hex2);
      }
    }
    const swatches = ref(Object.values((_a = swatchesInject == null ? void 0 : swatchesInject.swatches) != null ? _a : []));
    return () => {
      return createVNode("div", {
        "class": "devui-color-picker-basic flex"
      }, [(swatches.value.length !== 0 ? swatches.value : color).map((hex2) => createVNode("div", {
        "onClick": () => changeBasicColor(hex2),
        "class": ["devui-color-picker-basic-div"],
        "style": {
          backgroundColor: hex2
        }
      }, null))]);
    };
  }
});
var colorPickerPanel = "";
const colorPickerHistoryProps = {
  color: {
    type: Object
  }
};
var colorHistory$1 = "";
const STORAGE_KEY = "STORAGE_COLOR_PICKER_HISTORY_KEY";
const MAX_HISTORY_COUNT = 8;
function useStore$1(v, {
  storage
} = {}) {
  const getDefaultValue = () => {
    if (storage) {
      const storageValue = localStorage.getItem(STORAGE_KEY);
      return JSON.parse(storageValue + "") || v;
    } else {
      return v;
    }
  };
  const store = ref(getDefaultValue());
  watch(store, (value) => {
    if (storage) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(value));
    }
  });
  return store;
}
var colorHistory = defineComponent({
  name: "ColorEdit",
  components: {
    Icon: DIcon
  },
  props: colorPickerHistoryProps,
  emits: ["update:color"],
  setup(props) {
    const alphaInject = inject("provideData");
    const history2 = useStore$1([], {
      storage: true
    });
    const color2 = ref(props.color);
    const updateHistory = lodash.exports.debounce((value) => {
      const index2 = history2.value.findIndex((x) => x === value.hexa || x.endsWith("00") && value.alpha === 0);
      if (index2 >= 0) {
        history2.value.splice(index2, 1);
      }
      history2.value = [alphaInject.showAlpha ? value.hexa : value.hex, ...history2.value].slice(0, MAX_HISTORY_COUNT);
    }, 100);
    watch(props.color, (value) => {
      updateHistory(value);
    });
    function onChangeColor(value) {
      color2.value = fromHexa(value);
    }
    return () => createVNode("div", {
      "class": "devui-color-picker-history flex flex-wrap"
    }, [history2.value.map((hexa) => createVNode("div", {
      "onClick": () => onChangeColor(hexa),
      "class": ["devui-color-picker-history_color-box", hexa.endsWith("00") ? "transparent" : ""],
      "style": {
        backgroundColor: hexa
      }
    }, null))]);
  }
});
var colorPanel = defineComponent({
  name: "ColorPanel",
  components: {
    colorPalette,
    colorHueSlider,
    colorAlphaSlider,
    colorEdit,
    colorBasic,
    Tabs,
    colorHistory
  },
  props: colorPickerProps,
  emits: ["update:modelValue", "changeTextColor", "changeTriggerColor", "changePaletteColor", "changeTextModeType"],
  setup(props, {
    emit
  }) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DColorPicker", app);
    const injectData = inject("provideData");
    const paletteElement = ref(null);
    const showAlpha = injectData.showAlpha;
    const tab2 = ref("basic");
    function changeTextColor(isChange) {
      emit("changeTextColor", isChange);
    }
    function changeTextModeColor(currentType) {
      emit("changeTextModeType", currentType);
    }
    const paletteColorMap = ref(props.modelValue);
    watch(() => paletteColorMap.value, (newValue) => {
      emit("update:modelValue", newValue);
      emit("changePaletteColor", newValue);
      nextTick(() => {
        paletteElement.value && paletteElement.value.renderCanvas();
      });
    });
    return () => {
      return createVNode("div", {
        "class": "devui-color-picker-panel"
      }, [createVNode(resolveComponent("d-tabs"), {
        "type": "tabs",
        "modelValue": tab2.value,
        "onUpdate:modelValue": ($event) => tab2.value = $event
      }, {
        default: () => [createVNode(resolveComponent("d-tab"), {
          "id": "basic",
          "title": t("foundationPanel"),
          "tabId": "basic"
        }, {
          default: () => [createVNode(resolveComponent("color-basic"), {
            "color": paletteColorMap
          }, null)]
        }), createVNode(resolveComponent("d-tab"), {
          "id": "palette",
          "title": t("advancedPanel"),
          "tabId": "palette"
        }, {
          default: () => [createVNode(resolveComponent("color-palette"), {
            "ref": paletteElement,
            "modelValue": paletteColorMap.value,
            "onUpdate:modelValue": ($event) => paletteColorMap.value = $event,
            "onChangeTextColor": changeTextColor
          }, null)]
        })]
      }), createVNode(resolveComponent("color-hue-slider"), {
        "modelValue": paletteColorMap.value,
        "onUpdate:modelValue": ($event) => paletteColorMap.value = $event
      }, null), showAlpha ? createVNode(resolveComponent("color-alpha-slider"), {
        "modelValue": paletteColorMap.value,
        "onUpdate:modelValue": ($event) => paletteColorMap.value = $event
      }, null) : null, createVNode(colorEdit, {
        "show-alpha": props.showAlpha,
        "mode": props.mode,
        "color": paletteColorMap,
        "onChangeTextModeColor": changeTextModeColor
      }, null), injectData.showHistory ? createVNode(colorHistory, {
        "color": paletteColorMap
      }, null) : null]);
    };
  }
});
var colorPicker = "";
var ColorPicker = defineComponent({
  name: "DColorPicker",
  components: {
    colorPanel
  },
  props: colorPickerProps$1,
  emits: ["update:modelValue"],
  setup(props, {
    emit
  }) {
    var _a;
    const DEFAULT_MODE2 = "rgb";
    const provideData = {
      showAlpha: useReactive(() => props.showAlpha),
      swatches: useReactive(() => props.swatches),
      dotSize: useReactive(() => props.dotSize),
      showHistory: useReactive(() => props.showHistory)
    };
    provide("provideData", readonly(provideData));
    const initialColor = ref();
    const colorCubeRef = ref(null);
    const pickerRef = ref(null);
    const containerRef = ref(null);
    const left = ref(0);
    const top = ref(0);
    const isChangeTextColor = ref(true);
    const showColorPicker = ref(false);
    const formItemText = ref(`${(_a = props.mode) != null ? _a : DEFAULT_MODE2}`);
    const mode = ref(unref(props.mode));
    function updateUserColor(color2) {
      initialColor.value = color2;
      const value = extractColor(initialColor.value, props.modelValue, mode.value, props.showAlpha);
      emit("update:modelValue", value);
    }
    function resize2() {
      return colorPickerResize(colorCubeRef, top, left);
    }
    function isExhibition(event) {
      return isExhibitionColorPicker(event, colorCubeRef, pickerRef, showColorPicker);
    }
    onMounted(() => {
      window.addEventListener("resize", resize2);
      window.addEventListener("click", isExhibition, true);
    });
    const triggerColor = computed(() => {
      const currentColor = initialColor.value.rgba;
      const trigger = __spreadProps(__spreadValues({}, currentColor), {
        a: props.showAlpha ? currentColor.a : 1
      });
      return {
        backgroundColor: `${RGBAtoCSS(trigger)}`
      };
    });
    const formItemValue = computed(() => {
      return extractColor(initialColor.value, "", formItemText.value, props.showAlpha);
    });
    const textColor = computed(() => {
      return changeColorValue(initialColor.value, 0.5);
    });
    function changeTextColor(value) {
      isChangeTextColor.value = value;
    }
    function changePaletteColor(colorMap) {
      updateUserColor(colorMap);
    }
    function changeTextModeType(type4) {
      mode.value = type4;
      formItemText.value = type4;
    }
    function handleWindowScroll() {
      computePosition(colorCubeRef.value, pickerRef.value, {
        middleware: [flip()]
      }).then(({
        y
      }) => {
        var _a2;
        Object.assign((_a2 = pickerRef.value) == null ? void 0 : _a2.style, {
          top: `${y}px`
        });
      });
    }
    const scroll = lodash.exports.throttle(handleWindowScroll, 200);
    watch(() => showColorPicker.value, (newValue) => {
      if (!newValue) {
        window.removeEventListener("scroll", scroll);
      }
      newValue && nextTick(() => {
        if (pickerRef.value) {
          window.addEventListener("scroll", scroll);
        }
      });
    });
    watch(() => props.modelValue, (newValue) => {
      updateUserColor(parseColor(newValue, initialColor.value));
    }, {
      immediate: true
    });
    return () => {
      return createVNode("div", {
        "class": "devui-color-picker",
        "ref": colorCubeRef
      }, [createVNode("div", {
        "class": "devui-color-picker-container"
      }, [createVNode("div", {
        "class": "devui-color-picker-container-wrap"
      }, [createVNode("div", {
        "class": "devui-color-picker-container-wrap-current-color",
        "style": triggerColor.value
      }, null), createVNode("div", {
        "class": ["devui-color-picker-container-wrap-transparent", "devui-color-picker-container-wrap-current-color-transparent"]
      }, null), createVNode("div", {
        "class": "devui-color-picker-color-value"
      }, [createVNode("p", {
        "style": textColor.value
      }, [formItemValue.value])])])]), createVNode(Transition, {
        "name": "color-picker-transition"
      }, {
        default: () => [showColorPicker.value ? createVNode("div", {
          "ref": pickerRef,
          "class": ["devui-color-picker-position"]
        }, [createVNode(resolveComponent("color-panel"), {
          "modelValue": initialColor.value,
          "onUpdate:modelValue": ($event) => initialColor.value = $event,
          "ref": containerRef,
          "mode": mode.value,
          "onChangeTextColor": changeTextColor,
          "onChangePaletteColor": changePaletteColor,
          "onChangeTextModeType": changeTextModeType
        }, null)]) : null]
      })]);
    };
  }
});
var ColorPickerInstall = {
  title: "ColorPicker \u989C\u8272\u9009\u62E9\u5668",
  category: "\u6570\u636E\u5F55\u5165",
  status: "80%",
  install(app) {
    app.component(ColorPicker.name, ColorPicker);
  }
};
const commentProps = {
  author: {
    type: String,
    default: ""
  },
  avatar: {
    type: String,
    default: ""
  },
  datetime: {
    type: String,
    default: ""
  }
};
var comment = "";
var Comment = defineComponent({
  name: "DComment",
  components: {
    Avatar
  },
  props: commentProps,
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("comment");
    const {
      avatar: avatar2,
      author,
      datetime
    } = toRefs(props);
    return () => {
      var _a, _b, _c, _d, _e, _f;
      return createVNode("div", {
        "class": ns2.b()
      }, [slots.avatar ? (_a = slots.avatar) == null ? void 0 : _a.call(slots) : createVNode("div", {
        "class": ns2.e("avatar")
      }, [createVNode(Avatar, {
        "name": avatar2.value,
        "imgSrc": isUrl(avatar2.value) || isBase64(avatar2.value) ? avatar2.value : ""
      }, null)]), createVNode("div", {
        "class": ns2.e("main")
      }, [slots.head ? (_b = slots.head) == null ? void 0 : _b.call(slots) : createVNode("div", {
        "class": ns2.e("head")
      }, [slots.author ? (_c = slots.author) == null ? void 0 : _c.call(slots) : createVNode("div", {
        "class": ns2.e("author")
      }, [author.value]), slots.datetime ? (_d = slots.datetime) == null ? void 0 : _d.call(slots) : createVNode("div", {
        "class": ns2.e("datetime")
      }, [datetime.value])]), createVNode("div", {
        "class": ns2.e("content")
      }, [(_e = slots.default) == null ? void 0 : _e.call(slots)]), (_f = slots.actions) == null ? void 0 : _f.call(slots)])]);
    };
  }
});
var CommentInstall = {
  title: "Comment \u8BC4\u8BBA",
  category: "\u6570\u636E\u5C55\u793A",
  status: "10%",
  install(app) {
    app.component(Comment.name, Comment);
  }
};
const countdownProps = {
  value: {
    type: Number,
    required: true
  },
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: {
    type: String,
    default: ""
  },
  suffix: {
    type: String,
    default: ""
  },
  valueStyle: {
    type: Object,
    default: () => {
      return {};
    }
  }
};
const getFormatTime = (leftTime) => {
  const timeformat = /* @__PURE__ */ new Map([
    ["Y", 0],
    ["M", 0],
    ["D", 0],
    ["H", 0],
    ["m", 0],
    ["s", 0],
    ["S", 0]
  ]);
  const year = Math.floor(leftTime / (365 * 24 * 60 * 60 * 1e3));
  const month = Math.floor(leftTime / (30 * 24 * 60 * 60 * 1e3) % 12);
  const day = Math.floor(leftTime / (24 * 60 * 60 * 1e3) % 30);
  const hour = Math.floor(leftTime / (60 * 60 * 1e3) % 24);
  const minute = Math.floor(leftTime / (60 * 1e3) % 60);
  const second = Math.floor(leftTime / 1e3 % 60);
  const millsecond = leftTime % 1e3;
  timeformat.set("Y", year);
  timeformat.set("M", month);
  timeformat.set("D", day);
  timeformat.set("H", hour);
  timeformat.set("m", minute);
  timeformat.set("s", second);
  timeformat.set("S", millsecond);
  return timeformat;
};
const getLegalTime = (s, timeformat) => {
  const dateValue = /* @__PURE__ */ new Map([
    ["Y", 0],
    ["M", 0],
    ["D", 0],
    ["H", 0],
    ["m", 0],
    ["s", 0],
    ["S", 0]
  ]);
  const m = /* @__PURE__ */ new Map([
    ["Y", 12],
    ["M", 30],
    ["D", 24],
    ["H", 60],
    ["m", 60],
    ["s", 1e3],
    ["S", 1]
  ]);
  let storage = 0;
  for (const k of dateValue.keys()) {
    if (s.has(k)) {
      dateValue.set(k, (timeformat.get(k) || 0) + storage);
      storage = 0;
    } else {
      storage += (timeformat.get(k) || 0) * (m.get(k) || 0);
    }
  }
  if (!s.has("S") && (timeformat.get("S") || 0) > 500) {
    dateValue.set("s", (dateValue.get("s") || 0) + 1);
  }
  return dateValue;
};
const getTimeSplit = (format2) => {
  const fomatMap = /* @__PURE__ */ new Set(["Y", "M", "D", "H", "m", "s", "S"]);
  const m = [];
  for (let i = 0; i < format2.length; i++) {
    const k = format2[i];
    if (m.length === 0 || m[m.length - 1].k !== k || !fomatMap.has(k)) {
      m.push({ k, n: 1 });
    } else {
      m[m.length - 1].n++;
    }
  }
  return m;
};
const getDeduplication = (format2) => {
  const fomatMap = /* @__PURE__ */ new Set(["Y", "M", "D", "H", "m", "s", "S"]);
  const s = /* @__PURE__ */ new Set();
  for (let i = 0; i < format2.length; i++) {
    const k = format2[i];
    if (fomatMap.has(k)) {
      s.add(k);
    }
  }
  return s;
};
const numFormat = (n, len) => {
  const maxNum = 10 ** len - 1;
  if (n >= maxNum) {
    return n;
  } else {
    const carryLen = len - n.toString().length;
    let str = "";
    for (let i = 0; i < carryLen; i++) {
      str += "0";
    }
    return str + n;
  }
};
const intervalTimer = (callback, interval = 0) => {
  let counter = 1;
  let timeoutId;
  const startTime = Date.now();
  function main() {
    const nowTime = Date.now();
    const nextTime = startTime + counter * interval;
    timeoutId = setTimeout(main, interval - (nowTime - nextTime));
    counter += 1;
    callback();
  }
  timeoutId = setTimeout(main, interval);
  return () => {
    clearTimeout(timeoutId);
  };
};
var countdown = "";
var Countdown = defineComponent({
  name: "DCountdown",
  props: countdownProps,
  emits: ["onChange", "onFinish"],
  setup(props, ctx2) {
    const timerCleaner = ref();
    const s = getDeduplication(props.format);
    const timeFormat = getTimeSplit(props.format);
    const timeStr = ref("");
    const getTimeStr = (legalTime) => {
      const fomatMap = /* @__PURE__ */ new Set(["Y", "M", "D", "H", "m", "s", "S"]);
      const t = timeFormat.reduce((pre, cur) => {
        if (fomatMap.has(cur.k)) {
          return pre + numFormat(legalTime.get(cur.k) || 0, cur.n);
        }
        return pre + cur.k;
      }, "");
      timeStr.value = t;
    };
    const getTime = () => {
      const value = new Date(props.value).getTime();
      const leftTime = value > new Date().getTime() ? value - new Date().getTime() : 0;
      const formatTime = getFormatTime(leftTime);
      const legalTime = getLegalTime(s, formatTime);
      !ctx2.slots.default && getTimeStr(legalTime);
      ctx2.emit("onChange", {
        leftTime,
        formatTime,
        legalTime
      });
      return leftTime;
    };
    const startTime = () => {
      getTime();
      if (timerCleaner.value) {
        return;
      }
      timerCleaner.value = intervalTimer(() => {
        var _a;
        const t = getTime();
        if (t === 0) {
          ctx2.emit("onFinish");
          (_a = timerCleaner.value) == null ? void 0 : _a.call(timerCleaner);
          timerCleaner.value = null;
        }
      }, s.has("S") ? 100 : 1e3);
    };
    onMounted(() => {
      startTime();
    });
    onUnmounted(() => {
      var _a;
      (_a = timerCleaner.value) == null ? void 0 : _a.call(timerCleaner);
    });
    return () => {
      return createVNode("div", {
        "class": "devui-countdown"
      }, [ctx2.slots.default ? ctx2.slots.default() : createVNode("div", {
        "class": "countdown-content",
        "style": props.valueStyle
      }, [createVNode("span", {
        "class": "countdown-prefix"
      }, [props.prefix]), createVNode("span", {
        "class": "countdown-value"
      }, [timeStr.value]), createVNode("span", {
        "class": "countdown-suffix"
      }, [props.suffix])])]);
    };
  }
});
var CountdownInstall = {
  title: "Countdown \u5012\u8BA1\u65F6",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Countdown.name, Countdown);
  }
};
const getDateTime = (d) => {
  const year = d.getFullYear();
  const month = d.getMonth() + 1;
  const date4 = d.getDate();
  const day = d.getDay();
  const hour = d.getHours();
  const minute = d.getMinutes();
  const second = d.getSeconds();
  const ms = d.getMilliseconds();
  return [year, month, date4, day, hour, minute, second, ms];
};
const fixStart = (n, m, max = 2, ch = "0") => {
  return (n + "").padStart(Math.min(m.length, max), ch);
};
const formatDate = (fmt, d) => {
  const usage = getDateTime(d);
  let res = fmt;
  res = res.replace(/y+/g, (m) => {
    const year = usage[0] + "";
    if (m.length === 2) {
      return year.substring(2);
    }
    return year;
  });
  res = res.replace(/M+/g, (m) => fixStart(usage[1], m));
  res = res.replace(/d+/g, (m) => fixStart(usage[2], m));
  res = res.replace(/h+/g, (m) => fixStart(usage[4], m));
  res = res.replace(/m+/g, (m) => fixStart(usage[5], m));
  res = res.replace(/s+/g, (m) => fixStart(usage[6], m));
  return res;
};
const formatRange$1 = (fmt, a, b, conn = "-") => {
  const ab = [a, b];
  if (a.getTime() > b.getTime()) {
    ab.reverse();
  }
  return `${formatDate(fmt, ab[0])} ${conn} ${formatDate(fmt, ab[1])}`;
};
const isIn = (a, b) => {
  if (!b) {
    return false;
  }
  while (a) {
    if (a === b) {
      return true;
    }
    a = a.parentNode;
  }
  return false;
};
const invokeFunction = (fn, ...args) => {
  if (typeof fn === "function") {
    fn(...args);
  }
};
const getHumanDate = (d) => {
  const year = d.getFullYear();
  const month = d.getMonth() + 1;
  const date4 = d.getDate();
  const day = d.getDay();
  const hour = d.getHours();
  const minute = d.getMinutes();
  const second = d.getSeconds();
  const ms = d.getMilliseconds();
  return {
    year,
    y: year,
    month,
    M: month,
    date: date4,
    d: date4,
    day,
    hour,
    H: hour,
    h: hour,
    minute,
    m: minute,
    second,
    s: second,
    ms
  };
};
const getMonthDays = (year, month) => {
  const first = new Date(year, month - 1, 1);
  const last = new Date(year, month, 0);
  const dates = [];
  let day = first.getDay();
  while (day > 0) {
    day -= 1;
    dates.push({ date: new Date(year, month - 1, -day), current: -1 });
  }
  day = last.getDate() - first.getDate();
  for (let i = 0; i <= day; i++) {
    const date4 = new Date(first);
    date4.setDate(i + 1);
    dates.push({ date: date4, current: 0 });
  }
  day = last.getDay();
  let tail = last;
  for (let i = day; i < 6; i++) {
    tail = new Date(year, month, i - day + 1);
    dates.push({ date: tail, current: 1 });
  }
  if (dates.length < 42) {
    day = tail.getDate();
    for (let i = 1; i <= 7; i++) {
      tail = new Date(year, month, day + i);
      dates.push({ date: tail, current: 1 });
    }
  }
  return dates;
};
const getMonthWeeklyDays = (date4 = new Date()) => {
  if (!(date4 instanceof Date)) {
    date4 = new Date();
  }
  const { year, month } = getHumanDate(date4);
  const days = getMonthDays(year, month);
  const dayRows = [];
  while (days.length > 0) {
    dayRows.push(days.splice(0, 7));
  }
  return dayRows;
};
const WEEK_DAYS = ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"];
const invokeCallback = (cb, ...args) => {
  typeof cb === "function" && cb(...args);
};
const subDateMonth = (a, b) => {
  const am = a.getFullYear() * 12 + a.getMonth();
  const bm = b.getFullYear() * 12 + b.getMonth();
  return am - bm;
};
const ONE_DAY = 1e3 * 60 * 60 * 24;
const subDateDay = (a, b) => {
  const ad = new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime();
  const bd = new Date(b.getFullYear(), b.getMonth(), b.getDate()).getTime();
  return (ad - bd) / ONE_DAY;
};
const compareDate = (small, big, mode, min) => {
  if (!small || !big) {
    return true;
  }
  if (mode === "year") {
    return big.getFullYear() - small.getFullYear() > min;
  } else {
    return subDateMonth(big, small) > min;
  }
};
const _parseInt = (str, dftVal) => {
  if (!str || typeof str !== "string") {
    return dftVal;
  }
  const n = parseInt(str);
  if (isNaN(n)) {
    return dftVal;
  }
  return n;
};
const parseTime = (str) => {
  const [h2, m, s, ms] = (str == null ? void 0 : str.split(/[\:\.]+/)) || [];
  return [_parseInt(h2, 0) || 0, _parseInt(m, 0) || 0, _parseInt(s, 0) || 0, _parseInt(ms, 0) || 0];
};
const dateCounter = (date4, type4) => {
  switch (type4) {
    case "y":
      return date4.getFullYear();
    case "m":
      return date4.getFullYear() * 12 + date4.getMonth();
  }
  return date4.getTime() / ONE_DAY >> 0;
};
const compareDateSort = (d1, d2, type4 = "d") => {
  const t1 = dateCounter(d1, type4), t2 = dateCounter(d2, type4);
  return t1 < t2 ? -1 : t1 > t2 ? 1 : 0;
};
const betweenDate = (date4, left, right) => {
  if (left instanceof Date && compareDateSort(left, date4, "d") > 0) {
    return false;
  }
  if (right instanceof Date && compareDateSort(date4, right, "d") > 0) {
    return false;
  }
  return true;
};
const parseDate = (str) => {
  if (!str || typeof str !== "string") {
    return;
  }
  const [dateStr = "", timeStr = ""] = str.split(/([ ]|T)+/);
  if (!dateStr) {
    return;
  }
  const [y, m, d] = dateStr.split(/[^\d]+/);
  const year = _parseInt(y), month = _parseInt(m), date4 = _parseInt(d) || 1;
  if (!year || !month) {
    return;
  }
  const time = parseTime(timeStr);
  return new Date(year, month - 1, date4, ...time);
};
var InputInstall = {
  title: "Input \u8F93\u5165\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(DInput.name, DInput);
  }
};
const datePickerProps = {
  selectedDateChange: {
    type: Function
  },
  autoClose: {
    type: Boolean,
    default: false
  },
  range: {
    type: Boolean,
    default: false
  },
  showTime: {
    type: Boolean,
    default: false
  },
  format: {
    type: String,
    default: "y/MM/dd"
  },
  rangeSpliter: {
    type: String,
    default: "-"
  },
  attachInputDom: {
    type: String
  },
  dateMin: {
    type: String
  },
  dateMax: {
    type: String
  }
};
const timePickerProps$1 = {
  time: {
    type: Date
  }
};
const verticalSliderProps = {
  size: {
    type: Number,
    default: 26
  },
  items: {
    type: Array
  },
  selectedIndex: {
    type: Number
  },
  className: {
    type: String
  },
  itemClassNormal: {
    type: String
  },
  itemClassSelected: {
    type: String
  },
  onChange: {
    type: Function
  }
};
const handleCalendarSwitchState = (state, index2, pos, date4) => {
  switch (index2) {
    case 0:
      const preYear = new Date(date4);
      preYear.setFullYear(preYear.getFullYear() - 1);
      pos === 0 ? state.current = preYear : state.next = preYear;
      break;
    case 1:
      const preMonth = new Date(date4);
      preMonth.setMonth(preMonth.getMonth() - 1);
      pos === 0 ? state.current = preMonth : state.next = preMonth;
      break;
    case 2:
      const nextMonth = new Date(date4);
      nextMonth.setMonth(nextMonth.getMonth() + 1);
      pos === 0 ? state.current = nextMonth : state.next = nextMonth;
      break;
    case 3:
      const nextYear = new Date(date4);
      nextYear.setFullYear(nextYear.getFullYear() + 1);
      pos === 0 ? state.current = nextYear : state.next = nextYear;
      break;
  }
};
const formatValue = (state, props) => {
  const { format: format2 = "y/MM/dd", range: range3, rangeSpliter = "-" } = props || {};
  if (range3) {
    if (!state.start) {
      return "";
    } else if (!state.end) {
      return formatDate(format2, state.start);
    }
    if (state.end < state.start) {
      const end = state.end;
      state.end = state.start;
      state.start = end;
    }
    return formatRange$1(format2, state.start, state.end, rangeSpliter);
  } else {
    if (!state.start) {
      return "";
    }
    return formatDate(format2, state.start);
  }
};
const formatPlaceholder = (props) => {
  if (!props) {
    return "";
  }
  const format2 = props.format || `y/MM/dd`;
  const sp = props.rangeSpliter || "-";
  return props.range ? `${format2} ${sp} ${format2}` : format2;
};
const getDateKey = (date4) => {
  return date4.toDateString();
};
const cellClassName = (props, day, base = "cell") => {
  if (!betweenDate(day.date, props.dateMin, props.dateMax)) {
    return `${base} disabled`;
  } else if (day.current !== 0) {
    return `${base} not-current`;
  }
  const key = getDateKey(day.date);
  if (props.type === "range") {
    if (props.dateStart) {
      if (getDateKey(props.dateStart) === key) {
        return `${base} selected`;
      }
      if (props.dateEnd && getDateKey(props.dateEnd) === key) {
        return `${base} selected`;
      }
      const innerEnd = props.dateEnd || props.dateHover;
      if (innerEnd) {
        const range3 = innerEnd > props.dateStart ? [props.dateStart, innerEnd] : [innerEnd, props.dateStart];
        if (day.date > range3[0] && day.date < range3[1]) {
          return `${base} innerday`;
        }
      }
    }
    return base;
  } else {
    return props.dateStart && getDateKey(props.dateStart) === key ? `${base} selected` : base;
  }
};
const trigEvent = (props, day) => {
  if (!betweenDate(day.date, props.dateMin, props.dateMax)) {
    return;
  }
  if (props.type === "range") {
    if (!props.dateStart) {
      invokeCallback(props.onSelectStart, day.date);
    } else if (!props.dateEnd) {
      if (subDateDay(props.dateStart, day.date) !== 0) {
        invokeCallback(props.onSelectEnd, day.date);
        typeof props.onChange === "function" && props.onChange(props.type, props);
      }
    } else {
      invokeCallback(props.onReset, day.date);
    }
  } else {
    invokeCallback(props.onSelected, day.date);
    typeof props.onChange === "function" && props.onChange(props.type, props);
  }
};
const handleDateEnter = (props, day) => {
  if (day.current !== 0) {
    return;
  }
  const { dateMin, dateMax } = props;
  if (dateMin && subDateDay(day.date, dateMin) < 0) {
    return;
  }
  if (dateMax && subDateDay(dateMax, day.date) < 0) {
    return;
  }
  if (props.type === "range") {
    const key = getDateKey(day.date);
    if (!props.dateStart || getDateKey(props.dateStart) === key || props.dateEnd) {
      return;
    }
    invokeCallback(props.onSelecting, day.date);
  }
};
const Year = (props) => {
  const {
    color: color2 = "#585d6b",
    rotate = 0
  } = props;
  return createVNode("svg", {
    "style": {
      transform: `rotate(${rotate}deg)`
    },
    "width": "10px",
    "height": "10px",
    "viewBox": "0 0 10 10",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "fill": color2,
    "transform": "translate(-1.000000, -1.000000)"
  }, [createVNode("path", {
    "d": "M11,1.83333333 L11,10.1666667 L7,7.38833333 L7,10.1666667 L1,6 L7,1.83333333 L7,4.61033333 L11,1.83333333 Z"
  }, null)])]);
};
const Month = (props) => {
  const {
    color: color2 = "#585d6b",
    rotate = 0
  } = props;
  return createVNode("svg", {
    "style": {
      transform: `rotate(${rotate}deg)`
    },
    "width": "6px",
    "height": "10px",
    "viewBox": "0 0 6 10",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "fill": color2,
    "transform": "translate(-3.000000, -1.000000)"
  }, [createVNode("polygon", {
    "points": "6 3 10.1666667 9 1.83333333 9"
  }, null)])]);
};
var index$9 = "";
const Item$1 = (props) => {
  const {
    button: Btn,
    disabled = false,
    rotate = 0,
    date: date4,
    pos
  } = props;
  const color2 = disabled ? "#cfd0d3" : "#585d6b";
  const className2 = `${disabled ? "disabled" : ""}`;
  const handleClick = disabled ? void 0 : () => invokeCallback(props.cb, date4, pos);
  return createVNode("a", {
    "class": className2,
    "onClick": handleClick
  }, [createVNode(Btn, {
    "color": color2,
    "rotate": rotate
  }, null)]);
};
const Title = (props) => {
  const {
    date: date4
  } = props;
  return createVNode("a", {
    "class": "title"
  }, [`${date4.getFullYear()}\u5E74${(date4.getMonth() + 1 + "").padStart(2, "0")}\u6708`]);
};
const CalendarToolbar = (props) => {
  const {
    type: type4,
    current,
    compare,
    pos,
    dateMax,
    dateMin,
    onPreviousYear,
    onPreviousMonth,
    onNextMonth,
    onNextYear
  } = props;
  const dis = [false, false, false, false];
  if (type4 === "range") {
    if (pos === 1) {
      dis[0] = !compareDate(compare, current, "year", 1);
      dis[1] = !compareDate(compare, current, "month", 1);
      dis[2] = !compareDate(current, dateMax, "month", 0);
      dis[3] = !compareDate(current, dateMax, "year", 0);
    } else {
      dis[0] = !compareDate(dateMin, current, "year", 0);
      dis[1] = !compareDate(dateMin, current, "month", 0);
      dis[2] = !compareDate(current, compare, "month", 1);
      dis[3] = !compareDate(current, compare, "year", 1);
    }
  } else {
    dis[0] = !compareDate(dateMin, current, "year", 0);
    dis[1] = !compareDate(dateMin, current, "month", 0);
    dis[2] = !compareDate(current, dateMax, "month", 0);
    dis[3] = !compareDate(current, dateMax, "year", 0);
  }
  return createVNode("div", {
    "class": "devui-calendar-toolbar"
  }, [createVNode(Item$1, {
    "disabled": dis[0],
    "date": current,
    "pos": pos,
    "button": Year,
    "cb": onPreviousYear
  }, null), createVNode(Item$1, {
    "disabled": dis[1],
    "date": current,
    "pos": pos,
    "button": Month,
    "rotate": -90,
    "cb": onPreviousMonth
  }, null), createVNode(Title, {
    "date": current
  }, null), createVNode(Item$1, {
    "disabled": dis[2],
    "date": current,
    "pos": pos,
    "button": Month,
    "rotate": 90,
    "cb": onNextMonth
  }, null), createVNode(Item$1, {
    "disabled": dis[3],
    "date": current,
    "pos": pos,
    "button": Year,
    "rotate": 180,
    "cb": onNextYear
  }, null)]);
};
const TodayDefault = (props) => {
  const {
    onSelected = () => 0,
    disabled = false
  } = props;
  return createVNode("div", {
    "class": `today-container ${disabled ? "disabled" : ""}`
  }, [createVNode("button", {
    "class": "today-button",
    "disabled": disabled,
    "onClick": disabled ? void 0 : () => onSelected(new Date())
  }, [createTextVNode("\u4ECA\u5929")])]);
};
var index$8 = "";
const CalendarDatePanel = (props) => {
  const today = new Date();
  return createVNode("div", {
    "class": "devui-calendar-panel"
  }, [createVNode(CalendarToolbar, {
    "current": props.current,
    "compare": props.compare,
    "pos": props.pos,
    "type": props.type,
    "showTime": props.showTime,
    "onPreviousYear": props.onPreviousYear,
    "onPreviousMonth": props.onPreviousMonth,
    "onNextMonth": props.onNextMonth,
    "onNextYear": props.onNextYear,
    "dateMax": props.dateMax,
    "dateMin": props.dateMin
  }, null), createVNode("ol", {
    "class": "head row"
  }, [WEEK_DAYS.map((day) => createVNode("li", {
    "class": "cell"
  }, [day]))]), createVNode("ul", {
    "class": "body"
  }, [getMonthWeeklyDays(props.current).map((row2) => createVNode("li", {
    "class": "row"
  }, [row2.map((day) => {
    return createVNode("span", {
      "class": cellClassName(props, day),
      "onClick": () => trigEvent(props, day),
      "onMouseenter": () => handleDateEnter(props, day)
    }, [day.date.getDate()]);
  })]))]), props.type !== "range" ? createVNode(TodayDefault, {
    "disabled": !betweenDate(today, props.dateMin, props.dateMax),
    "onSelected": (curToday) => {
      typeof props.onToday === "function" && props.onToday(curToday, 0);
    }
  }, null) : null]);
};
var index$7 = "";
const VerticalSlider = defineComponent({
  props: verticalSliderProps,
  setup(props) {
    const {
      items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      selectedIndex = 0,
      size = 26,
      className: className2 = "",
      itemClassNormal = "",
      itemClassSelected = "selected",
      onChange
    } = props || {};
    let max_y = 0, min_y = 0;
    const container = ref();
    const movbar = ref();
    let pos_start = null;
    let pos_cache = null;
    const state = reactive({
      selectedIndex,
      barOpacity: 0,
      x: 0,
      y: 0,
      transition: "none"
    });
    const handleMouseDown = (e) => {
      e.stopPropagation();
      e.preventDefault();
      pos_start = [e.clientX, e.clientY];
      state.transition = "none";
    };
    const handleMouseMove = (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (!pos_start || !pos_cache) {
        return;
      }
      state.x = pos_cache[0] + e.clientX - pos_start[0];
      state.y = Math.min(max_y, Math.max(min_y, pos_cache[1] + e.clientY - pos_start[1]));
      state.selectedIndex = (max_y - state.y + size / 2) / size >> 0;
    };
    const handleMouseUp = (e) => {
      e.stopPropagation();
      e.preventDefault();
      pos_start = null;
      state.y = max_y - state.selectedIndex * size;
      state.transition = "transform 0.1s";
      if (pos_cache) {
        pos_cache[0] = state.x;
        pos_cache[1] = state.y;
      }
      if (typeof onChange === "function") {
        const idx = state.selectedIndex;
        const val = items[idx];
        onChange(val, idx);
      }
    };
    onMounted(() => {
      const {
        height: ch
      } = container.value.getBoundingClientRect();
      const {
        height: mh
      } = movbar.value.getBoundingClientRect();
      max_y = (ch - size) / 2;
      min_y = (ch + size) / 2 - mh;
      pos_cache = [0, max_y - state.selectedIndex * size];
      state.x = pos_cache[0];
      state.y = pos_cache[1];
      state.barOpacity = 1;
      state.transition = "transform 0.1s";
    });
    return () => {
      return createVNode("div", {
        "ref": container,
        "class": `devui-vertical-slider ${className2}`
      }, [createVNode("div", {
        "ref": movbar,
        "class": "movable-bar",
        "style": {
          opacity: state.barOpacity,
          transform: `translateY(${state.y}px)`,
          transition: state.transition
        }
      }, [items.map((c, i) => {
        const curClassName = i === state.selectedIndex ? itemClassSelected : itemClassNormal;
        return createVNode("span", {
          "class": `slider-item ${curClassName}`,
          "style": {
            height: `${size}px`,
            lineHeight: `${size}px`
          }
        }, [c]);
      })]), createVNode("div", {
        "class": "slider-mask",
        "onMousedown": handleMouseDown,
        "onMousemove": handleMouseMove,
        "onMouseup": handleMouseUp,
        "onMouseout": handleMouseUp
      }, null)]);
    };
  }
});
var index$6 = "";
const TimePicker$1 = defineComponent({
  props: timePickerProps$1,
  setup(props) {
    const {
      time = new Date()
    } = props || {};
    const state = reactive({
      hour: time.getHours(),
      minute: time.getMinutes(),
      second: time.getSeconds()
    });
    const hours = Array(24).fill(0).map((_, i) => `${i}`.padStart(2, "0"));
    const minutes = Array(60).fill(0).map((_, i) => `${i}`.padStart(2, "0"));
    return () => {
      return createVNode("div", {
        "class": "devui-calendar-timepicker"
      }, [createVNode("div", {
        "class": "head"
      }, [createVNode("div", {
        "class": "chars"
      }, [createVNode("span", null, [state.hour.toString().padStart(2, "0"), createTextVNode(":"), state.minute.toString().padStart(2, "0"), createTextVNode(":"), state.second.toString().padStart(2, "0")])])]), createVNode("div", {
        "class": "select"
      }, [createVNode(VerticalSlider, {
        "items": hours,
        "selectedIndex": state.hour,
        "onChange": (_, idx) => state.hour = idx
      }, null), createVNode(VerticalSlider, {
        "items": minutes,
        "selectedIndex": state.minute,
        "onChange": (_, idx) => state.minute = idx
      }, null), createVNode(VerticalSlider, {
        "items": minutes,
        "selectedIndex": state.second,
        "onChange": (_, idx) => state.second = idx
      }, null)])]);
    };
  }
});
var index$5 = "";
const Calendar = (props) => {
  const {
    showTime = false
  } = props;
  let {
    current
  } = props;
  if (!(current instanceof Date)) {
    current = new Date();
  }
  if (props.type === "range") {
    let {
      next
    } = props;
    if (!(next instanceof Date)) {
      next = new Date(current.getFullYear(), current.getMonth() + 1, 1);
    }
    return createVNode("div", {
      "class": "devui-calendar-container"
    }, [createVNode(CalendarDatePanel, mergeProps(props, {
      "pos": 0,
      "current": current,
      "compare": next
    }), null), showTime ? createVNode(TimePicker$1, {
      "time": current
    }, null) : null, createVNode(CalendarDatePanel, mergeProps(props, {
      "pos": 1,
      "current": next,
      "compare": current
    }), null), showTime ? createVNode(TimePicker$1, {
      "time": next
    }, null) : null]);
  } else {
    return createVNode("div", {
      "class": "devui-calendar-container"
    }, [createVNode(CalendarDatePanel, mergeProps(props, {
      "pos": 0,
      "current": current
    }), null), showTime ? createVNode(TimePicker$1, {
      "time": current
    }, null) : null]);
  }
};
var datePicker = "";
const formatRange = (state) => {
  const [start, end] = [state.start, state.end].sort((a, b) => a.getTime() - b.getTime());
  state.start = start;
  state.end = end;
  if (compareDateSort(start, end, "m") !== 0) {
    state.current = start;
    state.next = end;
  } else {
    if (compareDateSort(start, state.current) < 0) {
      state.current = start;
    }
    if (compareDateSort(state.next, end) < 0) {
      state.next = end;
    }
  }
};
var DatePicker = defineComponent({
  name: "DDatepicker",
  props: datePickerProps,
  setup(props) {
    const panel2 = ref(null);
    const input2 = ref(null);
    const current = parseDate(props.dateMin) || new Date();
    const next = new Date(current.getFullYear(), current.getMonth() + 1, 1);
    const state = reactive({
      show: false,
      value: "",
      placeholder: formatPlaceholder(props),
      current,
      next
    });
    state.value = formatValue(state, props);
    state.placeholder = formatPlaceholder(props);
    const documentClick = (e) => {
      e.stopPropagation();
      if (isIn(e.target, panel2.value) || isIn(e.target, input2.value)) {
        return;
      }
      state.show = false;
    };
    onMounted(() => {
      document.addEventListener("click", documentClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", documentClick);
    });
    return () => {
      return createVNode("div", {
        "class": "devui-datepicker-container"
      }, [createVNode("div", {
        "class": "input-container",
        "ref": input2
      }, [createVNode(DInput, {
        "ref": input2,
        "class": "datepicker-input",
        "modelValue": state.value,
        "placeholder": state.placeholder,
        "onFocus": () => {
          state.show = true;
        }
      }, null), createVNode(DIcon, {
        "size": "small",
        "name": "calendar",
        "class": "datepicker-input-icon"
      }, null)]), createVNode("div", {
        "class": "devui-datepicker-panel",
        "ref": panel2
      }, [state.show ? createVNode(Calendar, {
        "type": props.range ? "range" : "select",
        "showTime": props.showTime,
        "current": state.current,
        "next": state.next,
        "dateMin": parseDate(props.dateMin),
        "dateMax": parseDate(props.dateMax),
        "dateStart": state.start,
        "dateEnd": state.end,
        "dateHover": state.hover,
        "onReset": (date4) => {
          state.end = state.hover = void 0;
          state.start = date4;
        },
        "onChange": () => {
          state.value = formatValue(state, props);
          state.placeholder = formatPlaceholder(props);
          invokeFunction(props.selectedDateChange, state.value);
          if (props.autoClose) {
            state.show = false;
          }
        },
        "onToday": (date4) => {
          state.current = date4;
          state.start = date4;
          state.value = formatValue(state, props);
          state.placeholder = formatPlaceholder(props);
          invokeFunction(props.selectedDateChange, state.value);
          if (props.autoClose) {
            state.show = false;
          }
        },
        "onSelected": (date4) => {
          state.start = date4;
          if (compareDateSort(state.current, date4) !== 0) {
            state.current = date4;
          }
        },
        "onSelectStart": (date4) => state.start = date4,
        "onSelectEnd": (date4) => {
          state.end = date4;
          formatRange(state);
        },
        "onSelecting": (date4) => state.hover = date4,
        "onPreviousYear": (date4, pos) => {
          handleCalendarSwitchState(state, 0, pos, date4);
        },
        "onPreviousMonth": (date4, pos) => handleCalendarSwitchState(state, 1, pos, date4),
        "onNextMonth": (date4, pos) => handleCalendarSwitchState(state, 2, pos, date4),
        "onNextYear": (date4, pos) => handleCalendarSwitchState(state, 3, pos, date4)
      }, null) : null])]);
    };
  }
});
var index$4 = "";
const StickSlider = defineComponent({
  name: "DStickSlider",
  props: {},
  setup() {
    const state = reactive({
      showButtons: false,
      selectedIndex: 0
    });
    const reset = () => {
      state.showButtons = false;
    };
    const handleMainButtonMouseDown = (e) => {
      e.stopPropagation();
      state.showButtons = true;
    };
    const handleMainButtonMouseUp = (e) => {
      e.stopPropagation();
      reset();
    };
    return () => {
      return createVNode("div", {
        "class": "devui-stick-slider",
        "onMousedown": handleMainButtonMouseDown,
        "onMouseup": handleMainButtonMouseUp,
        "onMouseleave": handleMainButtonMouseUp
      }, [createVNode("div", {
        "class": "sub-buttons",
        "style": {
          display: state.showButtons ? "" : "none"
        }
      }, [Array(16).fill(null).map((_, i) => {
        return createVNode("div", {
          "class": `button ${i === state.selectedIndex ? "selected" : ""}`,
          "onMouseenter": () => state.selectedIndex = i
        }, [i]);
      })]), createVNode("div", {
        "class": "main-button"
      }, null)]);
    };
  }
});
var DatePickerInstall = {
  title: "DatePicker \u65E5\u671F\u9009\u62E9\u5668",
  category: "\u6570\u636E\u5F55\u5165",
  status: "50%",
  deprecated: {
    value: true,
    reason: "\u63A8\u8350\u4F7F\u7528 DatePickerPro \u7EC4\u4EF6\u66FF\u4EE3\u3002"
  },
  install(app) {
    app.component(DatePicker.name, DatePicker);
    app.component(StickSlider.name, StickSlider);
  }
};
const datePickerProCommonProps = {
  format: {
    type: String
  },
  showTime: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: "md"
  },
  disabled: {
    type: Boolean,
    default: false
  },
  calendarRange: {
    type: Array,
    default: [1970, 2099]
  },
  limitDateRange: {
    type: Array
  },
  type: {
    type: String,
    default: "date"
  }
};
const datePickerProProps = __spreadValues({
  modelValue: {
    type: [Date, String],
    default: ""
  },
  placeholder: {
    type: String,
    default: ""
  }
}, datePickerProCommonProps);
const datePickerProPanelProps = __spreadValues({
  visible: {
    type: Boolean,
    default: false
  },
  dateValue: {
    type: [Object, Array]
  },
  isRangeType: {
    type: Boolean,
    default: false
  },
  focusType: {
    type: String,
    default: "start"
  }
}, datePickerProCommonProps);
const timerPickerPanelProps = {
  visible: {
    type: Boolean,
    default: false
  },
  bindData: {
    type: String,
    default: ""
  }
};
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h2 = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, v = "en", D = {};
    D[v] = M;
    var p = function(t2) {
      return t2 instanceof _;
    }, S = function t2(e2, n2, r2) {
      var i2;
      if (!e2)
        return v;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (v = i2), i2 || !r2 && v;
    }, w = function(t2, e2) {
      if (p(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = g;
    O.l = S, O.i = p, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === $);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h3 = O.p(t2), $2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, l2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c:
            return r2 ? $2(1, 0) : $2(31, 11);
          case f:
            return r2 ? $2(1, M3) : $2(0, M3 + 1);
          case o:
            var v2 = this.$locale().weekStart || 0, D2 = (y2 < v2 ? y2 + 7 : y2) - v2;
            return $2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return l2(g2 + "Hours", 0);
          case u:
            return l2(g2 + "Minutes", 1);
          case s:
            return l2(g2 + "Seconds", 2);
          case i:
            return l2(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h3 + "Date", n2[d] = h3 + "Date", n2[f] = h3 + "Month", n2[c] = h3 + "FullYear", n2[u] = h3 + "Hours", n2[s] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $2 && this.$d[$2](l2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, h3) {
        var d2, $2 = this;
        r2 = Number(r2);
        var l2 = O.p(h3), y2 = function(t2) {
          var e2 = w($2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
        };
        if (l2 === f)
          return this.set(f, this.$M + r2);
        if (l2 === c)
          return this.set(c, this.$y + r2);
        if (l2 === a)
          return y2(1);
        if (l2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h3 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, c2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, d2 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h3(n2.monthsShort, a2, f2, 3), MMMM: h3(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o2, 2), ddd: h3(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || l2[t3] || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, $2) {
        var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, v2 = O.m(this, M3);
        return v2 = (l2 = {}, l2[c] = v2 / 12, l2[f] = v2, l2[h2] = v2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? v2 : O.a(v2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
      T[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1e3 * t2);
    }, w.en = D[v], w.Ls = D, w.p = {}, w;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
const DAY_DURATION = 24 * 60 * 60 * 1e3;
const yearItemHeight = 30;
const calendarItemHeight = 186;
const yearListHeight = 305;
const calendarListHeight = 270;
const monthPickerHeight = 300;
const monthCalendarItemHeight = 186;
const yearPickerHeight = 186;
const yearCalendarItemHeight = 48;
const DEFAULT_DATE = "YYYY/MM/DD";
const DEFAULT_TIME = `${DEFAULT_DATE} HH:mm:ss`;
const formatDayjsToStr = (date4, format2, type4) => {
  if (!date4) {
    return null;
  }
  if (type4 === "year") {
    return date4.year().toString();
  } else if (type4 === "month") {
    const month = date4.month() + 1 < 10 ? "0" + (date4.month() + 1) : date4.month() + 1;
    return `${date4.year()}-${month}`;
  } else {
    return dayjs(date4.format(format2)).isValid() ? date4.format(format2) : date4.format(DEFAULT_DATE);
  }
};
const isDateEquals = (pre, cur) => {
  const preDate = pre instanceof Date;
  const curDate = cur instanceof Date;
  return preDate && curDate ? pre.getTime() === cur.getTime() : pre === cur;
};
const parserDate = (date4) => {
  const day = dayjs(date4).locale("zh-cn");
  return day.isValid() ? day : void 0;
};
const resetActiveTimeData = (list2) => {
  list2.forEach((item) => {
    item.isActive = false;
  });
};
function usePickerPro(props, ctx2, t) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const originRef = ref();
  const inputRef = shallowRef();
  const overlayRef = shallowRef();
  const isPanelShow = ref(false);
  const placeholder = computed(() => props.placeholder || t("placeholder"));
  const isMouseEnter = ref(false);
  const pickerDisabled = computed(() => (formContext == null ? void 0 : formContext.disabled) || props.disabled);
  const pickerSize = computed(() => (formContext == null ? void 0 : formContext.size) || props.size);
  const isValidateError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const toggleChange = (isShow) => {
    isPanelShow.value = isShow;
    ctx2.emit("toggleChange", isShow);
    if (!isShow) {
      ctx2.emit("blur");
    }
  };
  onClickOutside(overlayRef, () => {
    toggleChange(false);
  }, { ignore: [originRef] });
  const onFocus = function(e) {
    toggleChange(true);
    ctx2.emit("focus", e);
  };
  const format2 = computed(() => {
    return props.showTime ? props.format || DEFAULT_TIME : props.format || DEFAULT_DATE;
  });
  const dateValue = computed(() => {
    let result2;
    if (props.modelValue) {
      result2 = parserDate(props.modelValue);
    }
    return result2;
  });
  const displayDateValue = computed(() => {
    const formatDate2 = formatDayjsToStr(dateValue.value, format2.value, props.type);
    if (formatDate2) {
      return formatDate2;
    }
    return "";
  });
  const showCloseIcon = computed(() => isMouseEnter.value && (props.modelValue ? true : false));
  const onSelectedDate = (date4, isConfirm) => {
    const result2 = date4 ? date4.toDate() : date4;
    if (!isDateEquals(props.modelValue, result2)) {
      ctx2.emit("update:modelValue", result2 ? result2 : "");
    }
    if (isConfirm) {
      ctx2.emit("confirmEvent", result2 ? result2 : "");
      toggleChange(false);
    }
  };
  const handlerClearTime = (e) => {
    if (!showCloseIcon.value) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    ctx2.emit("update:modelValue", "");
    ctx2.emit("confirmEvent", "");
    if (isPanelShow.value) {
      setTimeout(() => {
        var _a;
        (_a = inputRef.value) == null ? void 0 : _a.focus();
      });
    }
  };
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  }, { deep: true });
  return {
    originRef,
    inputRef,
    overlayRef,
    isPanelShow,
    placeholder,
    format: format2,
    dateValue,
    displayDateValue,
    isMouseEnter,
    showCloseIcon,
    pickerDisabled,
    pickerSize,
    isValidateError,
    onFocus,
    onSelectedDate,
    handlerClearTime
  };
}
function useCalendarSelected(props, ctx2) {
  const today = ref(new Date());
  const calendarRange = ref([]);
  const selectDate = ref();
  const rangeSelectDate = ref([]);
  const minDate = computed(() => {
    if (props.limitDateRange && props.limitDateRange[0]) {
      return props.limitDateRange[0];
    } else {
      return new Date(calendarRange.value[0], 0, 1);
    }
  });
  const maxDate = computed(() => {
    if (props.limitDateRange && props.limitDateRange[1]) {
      return props.limitDateRange[1];
    } else {
      return new Date(calendarRange.value[1], 11, 31);
    }
  });
  const fixRangeDate = () => {
    var _a, _b, _c, _d;
    const start = (_b = (_a = rangeSelectDate.value[0]) == null ? void 0 : _a.toDate()) == null ? void 0 : _b.getTime();
    const end = (_d = (_c = rangeSelectDate.value[1]) == null ? void 0 : _c.toDate()) == null ? void 0 : _d.getTime();
    if (start && end && end < start) {
      if (props.focusType === "start") {
        rangeSelectDate.value[1] = void 0;
      } else if (props.focusType === "end") {
        rangeSelectDate.value[0] = void 0;
      }
    }
  };
  const getToDate = (dateValue) => {
    let toDate;
    if (Array.isArray(dateValue)) {
      if (dateValue[0]) {
        const date4 = dateValue[0];
        toDate = date4;
        rangeSelectDate.value[0] = dateValue[0];
      } else {
        toDate = dayjs(today.value).locale("zh-cn");
      }
      if (dateValue[1]) {
        rangeSelectDate.value[1] = dateValue[1];
      }
    } else if (!Array.isArray(dateValue) && dateValue) {
      toDate = dateValue;
      selectDate.value = dateValue;
    } else {
      toDate = dayjs(today.value).locale("zh-cn");
    }
    return toDate;
  };
  const emitSelectedDate = () => {
    if (props.isRangeType) {
      if (props.focusType === "start" && (props.type !== "date" || props.type === "date" && !props.showTime)) {
        ctx2.emit("changeRangeFocusType", "end");
      } else if (props.focusType === "end" && !rangeSelectDate.value[0]) {
        rangeSelectDate.value[0] = selectDate.value;
      }
    }
    if (props.isRangeType) {
      ctx2.emit("selectedDate", rangeSelectDate.value);
    } else {
      ctx2.emit("selectedDate", selectDate.value);
    }
  };
  const isStartDate = (date4) => {
    var _a, _b;
    if (!props.isRangeType) {
      return false;
    }
    return date4.toDateString() === ((_b = (_a = rangeSelectDate.value[0]) == null ? void 0 : _a.toDate()) == null ? void 0 : _b.toDateString());
  };
  const isInRangeDate = (date4) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!props.isRangeType) {
      return false;
    }
    const dateTime = date4.getTime();
    const dateStr = date4.toDateString();
    const isIn2 = rangeSelectDate.value[0] && ((_a = rangeSelectDate.value[0].toDate()) == null ? void 0 : _a.getTime()) < dateTime && rangeSelectDate.value[1] && ((_c = (_b = rangeSelectDate.value[1]) == null ? void 0 : _b.toDate()) == null ? void 0 : _c.getTime()) > dateTime && ((_e = (_d = rangeSelectDate.value[0]) == null ? void 0 : _d.toDate()) == null ? void 0 : _e.toDateString()) !== dateStr && ((_g = (_f = rangeSelectDate.value[1]) == null ? void 0 : _f.toDate()) == null ? void 0 : _g.toDateString()) !== dateStr;
    return isIn2 ? true : false;
  };
  const isEndDate = (date4) => {
    var _a, _b;
    if (!props.isRangeType) {
      return false;
    }
    return date4.toDateString() === ((_b = (_a = rangeSelectDate.value[1]) == null ? void 0 : _a.toDate()) == null ? void 0 : _b.toDateString());
  };
  return {
    today,
    calendarRange,
    selectDate,
    rangeSelectDate,
    minDate,
    maxDate,
    fixRangeDate,
    getToDate,
    emitSelectedDate,
    isStartDate,
    isInRangeDate,
    isEndDate
  };
}
function useCalendarPanel(props, ctx2) {
  const yearScrollRef = ref();
  const monthScrollRef = ref();
  const yearAndMonthList = ref([]);
  const allMonthList = ref([]);
  const isListCollapse = ref(false);
  const calendarCacheData = /* @__PURE__ */ new Map();
  const currentMonthIndex = ref(0);
  const {
    today,
    calendarRange,
    selectDate,
    rangeSelectDate,
    minDate,
    maxDate,
    fixRangeDate,
    getToDate,
    emitSelectedDate,
    isStartDate,
    isInRangeDate,
    isEndDate
  } = useCalendarSelected(props, ctx2);
  const fillLeft = (num) => {
    return num < 10 ? `0${num}` : `${num}`;
  };
  const getDisplayWeeks = (year, month) => {
    const firstDayOfMonth = new Date(year, month, 1);
    const weekOfDay = firstDayOfMonth.getDay();
    const startDate = new Date(firstDayOfMonth.getTime() - weekOfDay * DAY_DURATION);
    const displayWeeks = [];
    for (let i = 0; i < 6; i++) {
      const startWeekDate = startDate.getTime() + i * 7 * DAY_DURATION;
      const weekDays = new Array(7).fill(0).map((value, index2) => {
        const currentDate = new Date(startWeekDate + index2 * DAY_DURATION);
        return {
          day: fillLeft(currentDate.getDate()),
          date: currentDate,
          inMonth: currentDate.getMonth().toString() === month.toString(),
          isToday: currentDate.toDateString() === today.value.toDateString()
        };
      });
      displayWeeks.push(weekDays);
    }
    return displayWeeks;
  };
  const initCalendarData = () => {
    const key = calendarRange.value.join("-");
    if (calendarCacheData.get(key)) {
      yearAndMonthList.value = calendarCacheData.get(key).yearAndMonthList;
      allMonthList.value = calendarCacheData.get(key).allMonthList;
      return;
    }
    yearAndMonthList.value = [];
    allMonthList.value = [];
    for (let year = calendarRange.value[0]; year <= calendarRange.value[1]; year++) {
      const yearOption = {
        year,
        isMonth: false,
        active: false
      };
      yearAndMonthList.value.push(yearOption);
      for (let month = 0; month < 12; month++) {
        const monthOption = {
          year,
          month,
          displayWeeks: getDisplayWeeks(year, month)
        };
        allMonthList.value.push(monthOption);
        const yearMonthOption = {
          year,
          month,
          isMonth: true,
          active: false
        };
        yearAndMonthList.value.push(yearMonthOption);
      }
    }
    calendarCacheData.set(key, {
      yearAndMonthList: yearAndMonthList.value,
      allMonthList: allMonthList.value
    });
  };
  const getCurrentIndex = (date4) => {
    const year = date4.getFullYear();
    const month = date4.getMonth();
    const yearIndex = isListCollapse.value ? year - calendarRange.value[0] : (year - calendarRange.value[0]) * 13 + month + 1;
    return {
      yearIndex,
      monthIndex: (year - calendarRange.value[0]) * 12 + month
    };
  };
  const updateYearActive = (index2) => {
    const curActive = yearAndMonthList.value.find((child) => child.active);
    if (curActive) {
      curActive.active = false;
    }
    yearAndMonthList.value[index2].active = true;
  };
  const goToYearDate = (index2) => {
    updateYearActive(index2);
    let scrollIndex = index2 - 4;
    if (scrollIndex < 0) {
      scrollIndex = 0;
    }
    nextTick(() => {
      var _a;
      const scrollEl = yearScrollRef.value;
      (_a = scrollEl == null ? void 0 : scrollEl.scrollTo) == null ? void 0 : _a.call(scrollEl, scrollIndex);
    });
  };
  const goToMonthDate = () => {
    let scrollIndex = currentMonthIndex.value;
    if (scrollIndex < 0) {
      scrollIndex = 0;
    }
    nextTick(() => {
      var _a;
      const scrollEl = monthScrollRef.value;
      (_a = scrollEl == null ? void 0 : scrollEl.scrollTo) == null ? void 0 : _a.call(scrollEl, scrollIndex);
    });
  };
  const goToShowDate = (date4) => {
    const scrollIndexObj = getCurrentIndex(date4);
    currentMonthIndex.value = scrollIndexObj.monthIndex;
    goToYearDate(scrollIndexObj.yearIndex);
    goToMonthDate();
  };
  const initCalendarShow = () => {
    if (!props.visible) {
      return;
    }
    const toDate = getToDate(props.dateValue);
    if (toDate) {
      goToShowDate(toDate.toDate());
    }
  };
  onBeforeMount(() => {
    today.value = new Date();
    calendarRange.value = props.calendarRange;
    initCalendarData();
  });
  onMounted(() => {
    initCalendarShow();
  });
  const handlerSetRangeDate = (day) => {
    if (props.focusType === "start") {
      rangeSelectDate.value[0] = dayjs(new Date(day.date.setHours(0, 0, 0))).locale("zh-cn");
    } else if (props.focusType === "end") {
      rangeSelectDate.value[1] = dayjs(new Date(day.date.setHours(23, 59, 59))).locale("zh-cn");
    }
    fixRangeDate();
  };
  const isDisabled = (date4) => {
    if (!date4) {
      return true;
    }
    const isInRange = date4.getTime() > minDate.value.getTime() && date4.getTime() < maxDate.value.getTime() || date4.toDateString() === minDate.value.toDateString() || date4.toDateString() === maxDate.value.toDateString();
    return !isInRange;
  };
  const handlerSelectDate = (day) => {
    if (!day.inMonth || isDisabled(day.date)) {
      return;
    }
    selectDate.value = dayjs(new Date(day.date.setHours(0, 0, 0))).locale("zh-cn");
    if (props.isRangeType) {
      handlerSetRangeDate(day);
    }
    emitSelectedDate();
  };
  const handlerYearCollapse = (date4) => {
    const activeItem = yearAndMonthList.value.find((child) => child.active);
    const selectedYear = activeItem == null ? void 0 : activeItem.year;
    const selectedMonth = activeItem == null ? void 0 : activeItem.month;
    isListCollapse.value = !isListCollapse.value;
    if (isListCollapse.value) {
      yearAndMonthList.value = yearAndMonthList.value.filter((child) => !child.isMonth);
    } else {
      initCalendarData();
    }
    nextTick(() => {
      goToShowDate(date4 || new Date(selectedYear || calendarRange.value[0], selectedMonth || 0, 1));
    });
  };
  const handlerClickMonth = (year, month) => {
    const date4 = new Date(year, month || 0, 1);
    if (isListCollapse.value) {
      handlerYearCollapse(date4);
    } else {
      goToShowDate(date4);
    }
  };
  const debounceScrollMonth = lodash.exports.throttle((newScrollTop) => {
    currentMonthIndex.value = Math.floor(newScrollTop / calendarItemHeight) + (newScrollTop % calendarItemHeight > 100 ? 1 : 0);
    const yearIndex = isListCollapse.value ? Math.floor(currentMonthIndex.value / 12) : currentMonthIndex.value + Math.floor(currentMonthIndex.value / 12) + 1;
    goToYearDate(yearIndex);
  }, 200);
  const handleScrollMonthList = (e) => {
    let { scrollTop: newScrollTop } = e.currentTarget;
    newScrollTop = newScrollTop > 0 ? newScrollTop : 0;
    debounceScrollMonth(newScrollTop);
  };
  const isDateSelected = (date4) => {
    if (selectDate.value && date4) {
      return selectDate.value.toDate().toDateString() === date4.toDateString();
    }
    return false;
  };
  watch([() => props.dateValue, () => props.focusType], ([dateValue, focusType]) => {
    if (Array.isArray(dateValue)) {
      rangeSelectDate.value = dateValue;
      let date4;
      if (focusType === "start") {
        date4 = dateValue[0];
      } else {
        date4 = dateValue[1] || dateValue[0];
      }
      if (date4) {
        goToShowDate(date4.toDate());
      } else {
        selectDate.value = date4;
      }
    } else {
      selectDate.value = dateValue;
      if (dateValue) {
        goToShowDate(dateValue.toDate());
      }
    }
  }, { deep: true });
  return {
    yearScrollRef,
    monthScrollRef,
    yearAndMonthList,
    allMonthList,
    isListCollapse,
    handlerSelectDate,
    handlerYearCollapse,
    handlerClickMonth,
    handleScrollMonthList,
    isDateSelected,
    isStartDate,
    isInRangeDate,
    isEndDate,
    isDisabled
  };
}
const DEFAULT_ITEM_HEIGHT = 20;
const virtualListProps = {
  data: {
    type: Array,
    default: () => []
  },
  component: {
    type: String,
    default: "div"
  },
  height: {
    type: Number,
    default: 100
  },
  itemHeight: {
    type: Number,
    default: DEFAULT_ITEM_HEIGHT
  },
  virtual: {
    type: Boolean,
    default: true
  },
  fullHeight: {
    type: Boolean
  },
  itemKey: {
    type: [String, Number, Function]
  }
};
const resizeObserverContainerProps = {
  height: {
    type: Number
  },
  offset: {
    type: Number || void 0
  },
  disabled: {
    type: Function
  },
  onInnerResize: {
    type: Function
  }
};
const scrollBarProps = {
  scrollTop: {
    type: Number
  },
  scrollHeight: {
    type: Number
  },
  height: {
    type: Number
  },
  count: {
    type: Number
  },
  onScroll: {
    type: Function
  },
  onStartMove: {
    type: Function
  },
  onStopMove: {
    type: Function
  }
};
const resizeObserverProps = {
  disabled: {
    type: Boolean
  },
  onResize: {
    type: Function
  }
};
function useVirtual(props) {
  const {
    height,
    data,
    itemHeight,
    virtual
  } = toRefs(props);
  const isVirtual = computed(() => {
    return Boolean(virtual.value !== false && height.value);
  });
  const inVirtual = computed(() => {
    return Boolean(isVirtual.value && data.value.length && itemHeight.value * data.value.length > height.value);
  });
  return {
    isVirtual,
    inVirtual
  };
}
function useHeights(mergedData, getKey) {
  const instance = /* @__PURE__ */ new Map();
  let heights = /* @__PURE__ */ new Map();
  const updatedMark = ref(Symbol("update"));
  watch(mergedData, () => {
    heights = /* @__PURE__ */ new Map();
    updatedMark.value = Symbol("update");
  });
  let heightUpdateId = 0;
  function collectHeight() {
    heightUpdateId += 1;
    const currentId = heightUpdateId;
    Promise.resolve().then(() => {
      if (currentId !== heightUpdateId) {
        return;
      }
      instance.forEach((element, key) => {
        if (element && element.offsetParent) {
          const {
            offsetHeight
          } = element;
          if (heights.get(key) !== offsetHeight) {
            updatedMark.value = Symbol("update");
            heights.set(key, element.offsetHeight);
          }
        }
      });
    });
  }
  function setInstance(item, ins) {
    const key = getKey(item);
    if (ins) {
      instance.set(key, ins.$el || ins);
      collectHeight();
    } else {
      instance.delete(key);
    }
  }
  return [setInstance, collectHeight, heights, updatedMark];
}
var useOriginScroll = (isScrollAtTop, isScrollAtBottom) => {
  let lock = false;
  let lockTimeout = null;
  function lockScroll2() {
    if (lockTimeout) {
      clearTimeout(lockTimeout);
    }
    lock = true;
    lockTimeout = setTimeout(() => {
      lock = false;
    }, 50);
  }
  return (deltaY, smoothOffset = false) => {
    const originScroll = deltaY < 0 && isScrollAtTop.value || deltaY > 0 && isScrollAtBottom.value;
    if (smoothOffset && originScroll) {
      if (lockTimeout) {
        clearTimeout(lockTimeout);
      }
      lock = false;
    } else if (!originScroll || lock) {
      lockScroll2();
    }
    return !lock && originScroll;
  };
};
const isValid = (value) => {
  return value !== void 0 && value !== null && value !== "";
};
const isEmptyElement = (c) => {
  var _a, _b;
  return !!c && (c.type === Comment$1 || c.type === Fragment && ((_a = c == null ? void 0 : c.children) == null ? void 0 : _a.length) === 0 || c.type === Text && ((_b = c == null ? void 0 : c.children) == null ? void 0 : _b.trim()) === "");
};
const flattenChildren = (children, filterEmpty = true) => {
  const temp = Array.isArray(children) ? children : [children];
  const res = [];
  temp.forEach((child) => {
    if (Array.isArray(child)) {
      res.push(...flattenChildren(child, filterEmpty));
    } else if (child && child.type === Fragment) {
      res.push(...flattenChildren(child.children, filterEmpty));
    } else if (child && isVNode(child)) {
      if (filterEmpty && !isEmptyElement(child)) {
        res.push(child);
      } else if (!filterEmpty) {
        res.push(child);
      }
    } else if (isValid(child)) {
      res.push(child);
    }
  });
  return res;
};
const findDOMNode = (instance) => {
  var _a;
  let node = ((_a = instance == null ? void 0 : instance.vnode) == null ? void 0 : _a.el) || instance && ((instance == null ? void 0 : instance.$el) || instance);
  while (node && !node.tagName) {
    node = node.nextSibling;
  }
  return node;
};
const isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  let offsetRef = 0;
  let nextFrame = null;
  let wheelValue = null;
  let isMouseScroll = false;
  const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  const onRawWheel = (event) => {
    var _a;
    if (!inVirtual.value) {
      return;
    }
    if (nextFrame) {
      window.cancelAnimationFrame(nextFrame);
    }
    const {
      deltaY
    } = event;
    offsetRef += deltaY;
    wheelValue = deltaY;
    if (originScroll(deltaY, false)) {
      return;
    }
    if (!isFF) {
      (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);
    }
    nextFrame = window.requestAnimationFrame(() => {
      const patchMultiple = isMouseScroll ? 10 : 1;
      onWheelDelta(offsetRef * patchMultiple);
      offsetRef = 0;
    });
  };
  const onFireFoxScroll = (event) => {
    if (!inVirtual.value) {
      return;
    }
    isMouseScroll = event.detail === wheelValue;
  };
  return [onRawWheel, onFireFoxScroll];
}
const SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  let touched = false;
  let touchY = 0;
  let element = null;
  let interval = null;
  const onTouchMove = (e) => {
    if (touched) {
      const currentY = Math.ceil(e.touches[0].pageY);
      let offsetY = touchY - currentY;
      touchY = currentY;
      if (callback(offsetY)) {
        e.preventDefault();
      }
      if (interval) {
        clearInterval(interval);
      }
      interval = setInterval(() => {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          if (interval) {
            clearInterval(interval);
          }
        }
      }, 16);
    }
  };
  const cleanUpEvents = () => {
    if (element) {
      element.removeEventListener("touchmove", onTouchMove);
      element.removeEventListener("touchend", () => {
        touched = false;
        cleanUpEvents();
      });
    }
  };
  const onTouchEnd = () => {
    touched = false;
    cleanUpEvents();
  };
  const onTouchStart = (e) => {
    cleanUpEvents();
    if (e.touches.length === 1 && !touched) {
      touched = true;
      touchY = Math.ceil(e.touches[0].pageY);
      element = e.target;
      element.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      element.addEventListener("touchend", onTouchEnd);
    }
  };
  onMounted(() => {
    watch(inVirtual, (val) => {
      var _a, _b;
      (_a = listRef.value) == null ? void 0 : _a.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      if (interval) {
        clearInterval(interval);
      }
      if (val) {
        (_b = listRef.value) == null ? void 0 : _b.addEventListener("touchstart", onTouchStart, {
          passive: false
        });
      }
    }, {
      immediate: true
    });
  });
}
var ResizeObserver$1 = defineComponent({
  name: "ResizeObserver",
  props: resizeObserverProps,
  emits: ["resize"],
  setup(props, {
    slots
  }) {
    const state = reactive({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    const currentElement = ref(null);
    const resizeObserver = ref(null);
    const destroyObserver = () => {
      if (resizeObserver.value) {
        resizeObserver.value.disconnect();
        resizeObserver.value = null;
      }
    };
    const onTriggerResize = (entries) => {
      const {
        onResize
      } = props;
      const target = entries[0].target;
      const {
        width,
        height
      } = target.getBoundingClientRect();
      const {
        offsetWidth,
        offsetHeight
      } = target;
      const fixedWidth = Math.floor(width);
      const fixedHeight = Math.floor(height);
      if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
        const size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        Object.assign(state, size);
        if (onResize) {
          Promise.resolve().then(() => {
            onResize(__spreadProps(__spreadValues({}, size), {
              offsetWidth,
              offsetHeight
            }), target);
          });
        }
      }
    };
    const instance = getCurrentInstance();
    const registerObserver = () => {
      const {
        disabled
      } = props;
      if (disabled) {
        destroyObserver();
        return;
      }
      if (instance) {
        const element = findDOMNode(instance);
        const elementChanged = element !== currentElement.value;
        const isSupported = window && "ResizeObserver" in window;
        if (elementChanged) {
          destroyObserver();
          currentElement.value = element;
        }
        if (!resizeObserver.value && element && isSupported) {
          resizeObserver.value = new ResizeObserver(onTriggerResize);
          resizeObserver.value.observe(element);
        }
      }
    };
    onMounted(() => {
      registerObserver();
    });
    onUpdated(() => {
      registerObserver();
    });
    onUnmounted(() => {
      destroyObserver();
    });
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots)[0];
    };
  }
});
const INIT_INNER_STYLE = {
  display: "flex",
  flexDirection: "column"
};
var ResizeObserverContainer = defineComponent({
  name: "ResizeObserverContainer",
  props: resizeObserverContainerProps,
  setup(props, ctx2) {
    const {
      height,
      offset: offset2
    } = toRefs(props);
    const outerStyle = ref({});
    const innerStyle = ref(INIT_INNER_STYLE);
    watch([() => height.value, () => offset2.value], () => {
      if (props.offset !== void 0) {
        outerStyle.value = {
          height: `${height.value}px`,
          position: "relative",
          overflow: "hidden"
        };
        innerStyle.value = __spreadProps(__spreadValues({}, innerStyle.value), {
          transform: `translateY(${offset2.value}px)`,
          left: 0,
          right: 0,
          top: 0
        });
      }
    }, {
      immediate: true
    });
    return () => createVNode("div", {
      "style": outerStyle.value
    }, [createVNode(ResizeObserver$1, {
      "onResize": ({
        offsetHeight
      }) => {
        if (offsetHeight && props.onInnerResize) {
          props.onInnerResize();
        }
      }
    }, {
      default: () => {
        var _a, _b;
        return [createVNode("div", {
          "style": innerStyle.value
        }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])];
      }
    })]);
  }
});
function getPageY(e) {
  return "touches" in e ? e.touches[0].pageY : e.pageY;
}
var ScrollBar = defineComponent({
  name: "ScrollBar",
  props: scrollBarProps,
  setup(props, ctx2) {
    const scrollbarRef = ref(null);
    const thumbRef = ref(null);
    const moveRaf = ref(0);
    const state = reactive({
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    });
    const visibleTimeout = ref(null);
    const canScroll = computed(() => {
      return (props.scrollHeight || 0) > (props.height || 0);
    });
    const getSpinHeight = () => {
      const {
        height = 0,
        count = 0
      } = props;
      let baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, 20);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    const getEnableScrollRange = () => {
      const {
        scrollHeight = 0,
        height = 0
      } = props;
      return scrollHeight - height || 0;
    };
    const getEnableHeightRange = () => {
      const {
        height = 0
      } = props;
      const spinHeight = getSpinHeight();
      return height - spinHeight || 0;
    };
    const getTop = () => {
      const {
        scrollTop = 0
      } = props;
      const enableScrollRange = getEnableScrollRange();
      const enableHeightRange = getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      const ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    const onMouseMove = (e) => {
      const {
        dragging,
        pageY,
        startTop
      } = state;
      const {
        onScroll: onScroll2
      } = props;
      window.cancelAnimationFrame(moveRaf.value);
      if (dragging) {
        const offsetY = getPageY(e) - (pageY || 0);
        const newTop = (startTop || 0) + offsetY;
        const enableScrollRange = getEnableScrollRange();
        const enableHeightRange = getEnableHeightRange();
        const ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        const newScrollTop = Math.ceil(ptg * enableScrollRange);
        moveRaf.value = window.requestAnimationFrame(() => {
          if (onScroll2) {
            onScroll2(newScrollTop);
          }
        });
      }
    };
    const onMouseUp = (callback) => {
      const {
        onStopMove
      } = props;
      state.dragging = false;
      if (onStopMove) {
        onStopMove();
      }
      if (callback) {
        callback();
      }
    };
    const onMouseDown = (e, callback) => {
      var _a, _b;
      const {
        onStartMove
      } = props;
      Object.assign(state, {
        dragging: true,
        pageY: getPageY(e),
        startTop: getTop()
      });
      if (onStartMove) {
        onStartMove();
      }
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", () => onMouseUp(callback));
      (_a = thumbRef == null ? void 0 : thumbRef.value) == null ? void 0 : _a.addEventListener("touchmove", onMouseMove, {
        passive: false
      });
      (_b = thumbRef == null ? void 0 : thumbRef.value) == null ? void 0 : _b.addEventListener("touchend", () => onMouseUp(callback));
      e.stopPropagation();
      e.preventDefault();
    };
    const removeEvents = () => {
      var _a, _b, _c, _d;
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", () => onMouseUp(removeEvents));
      (_a = scrollbarRef == null ? void 0 : scrollbarRef.value) == null ? void 0 : _a.removeEventListener("touchstart", (e) => {
        e.preventDefault();
      }, {
        passive: false
      });
      (_b = thumbRef == null ? void 0 : thumbRef.value) == null ? void 0 : _b.removeEventListener("touchstart", (e) => onMouseDown(e, removeEvents), {
        passive: false
      });
      (_c = thumbRef == null ? void 0 : thumbRef.value) == null ? void 0 : _c.removeEventListener("touchmove", onMouseMove, {
        passive: false
      });
      (_d = thumbRef == null ? void 0 : thumbRef.value) == null ? void 0 : _d.removeEventListener("touchend", () => onMouseUp(removeEvents));
      window.cancelAnimationFrame(moveRaf.value);
    };
    const onContainerMouseDown = (e) => {
      e.stopPropagation();
      e.preventDefault();
    };
    onBeforeUnmount(() => {
      removeEvents();
      if (visibleTimeout.value) {
        clearTimeout(visibleTimeout.value);
      }
    });
    onMounted(() => {
      var _a, _b;
      (_a = scrollbarRef == null ? void 0 : scrollbarRef.value) == null ? void 0 : _a.addEventListener("touchstart", (e) => {
        e.preventDefault();
      }, {
        passive: false
      });
      (_b = thumbRef.value) == null ? void 0 : _b.addEventListener("touchstart", (e) => onMouseDown(e, removeEvents), {
        passive: false
      });
    });
    const onShowBar = () => {
      if (visibleTimeout.value) {
        clearTimeout(visibleTimeout.value);
      }
      state.visible = true;
      visibleTimeout.value = setTimeout(() => {
        state.visible = false;
      }, 1e3);
    };
    ctx2.expose({
      onShowBar
    });
    return () => {
      const display = canScroll.value && state.visible ? void 0 : "none";
      return createVNode("div", {
        "ref": scrollbarRef,
        "style": {
          width: "8px",
          top: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display
        },
        "onMousedown": onContainerMouseDown,
        "onMousemove": onShowBar
      }, [createVNode("div", {
        "ref": thumbRef,
        "style": {
          width: "100%",
          height: getSpinHeight() + "px",
          top: getTop() + "px",
          left: 0,
          position: "absolute",
          background: "rgba(0, 0, 0, 0.5)",
          borderRadius: "99px",
          cursor: "pointer",
          userSelect: "none"
        },
        "onMousedown": (e) => onMouseDown(e, removeEvents)
      }, null)]);
    };
  }
});
function _isSlot$a(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const Item = ({
  setRef
}, {
  slots
}) => {
  var _a;
  const children = flattenChildren((_a = slots.default) == null ? void 0 : _a.call(slots));
  return children && children.length ? cloneVNode(children[0], {
    ref: setRef
  }) : children;
};
Item.props = {
  setRef: {
    type: Function
  }
};
function renderChildren(list2, startIndex, endIndex, setNodeRef, {
  getKey
}, renderFunc) {
  if (renderFunc === void 0) {
    return "";
  }
  return list2.slice(startIndex, endIndex + 1).map((item, index2) => {
    const eleIndex = startIndex + index2;
    const node = renderFunc(item, eleIndex, {});
    const key = getKey(item);
    return createVNode(Item, {
      "key": key,
      "setRef": (ele) => setNodeRef(item, ele)
    }, _isSlot$a(node) ? node : {
      default: () => [node]
    });
  });
}
const ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
var VirtualList = defineComponent({
  name: "DVirtualList",
  props: virtualListProps,
  setup(props, ctx2) {
    const {
      isVirtual,
      inVirtual
    } = useVirtual(props);
    const state = reactive({
      scrollTop: 0,
      scrollMoving: false
    });
    const data = computed(() => {
      return props.data || [];
    });
    const mergedData = shallowRef([]);
    watch(data, () => {
      mergedData.value = toRaw(data.value).slice();
    }, {
      immediate: true
    });
    const itemKey = shallowRef(null);
    watch(() => props.itemKey, (val) => {
      if (typeof val === "function") {
        itemKey.value = val;
      } else {
        if (val) {
          itemKey.value = (item) => item == null ? void 0 : item[val];
        }
      }
    }, {
      immediate: true
    });
    const componentRef = ref();
    const fillerInnerRef = ref();
    const barRef = ref();
    const getKey = (item) => {
      if (!itemKey.value || !props.itemKey) {
        return;
      }
      return itemKey.value(item);
    };
    const [setInstance, collectHeight, heights, updatedMark] = useHeights(mergedData, getKey);
    const calRes = reactive({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    });
    const offsetHeight = ref(0);
    onMounted(() => {
      nextTick(() => {
        var _a;
        offsetHeight.value = ((_a = fillerInnerRef.value) == null ? void 0 : _a.offsetHeight) || 0;
      });
    });
    onUpdated(() => {
      nextTick(() => {
        var _a;
        offsetHeight.value = ((_a = fillerInnerRef.value) == null ? void 0 : _a.offsetHeight) || 0;
      });
    });
    watch([isVirtual, mergedData], () => {
      if (!isVirtual.value) {
        Object.assign(calRes, {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    watch([isVirtual, mergedData, offsetHeight, inVirtual], () => {
      if (isVirtual.value && !inVirtual.value) {
        Object.assign(calRes, {
          scrollHeight: offsetHeight.value,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    watch([inVirtual, isVirtual, () => state.scrollTop, mergedData, updatedMark, () => props.height, offsetHeight], () => {
      if (!isVirtual.value || !inVirtual.value) {
        return;
      }
      let itemTop = 0;
      let startIndex;
      let startOffset;
      let endIndex;
      const mergedDataValue = unref(mergedData);
      const scrollTop = state.scrollTop;
      const {
        height
      } = props;
      const scrollTopHeight = scrollTop + height;
      for (let i = 0; i < mergedDataValue.length; i += 1) {
        const mergedDataItem = mergedDataValue[i];
        let cacheHeight;
        if (props.itemKey) {
          const key = getKey(mergedDataItem);
          cacheHeight = heights.get(key);
        }
        if (cacheHeight === void 0) {
          cacheHeight = props.itemHeight || DEFAULT_ITEM_HEIGHT;
        }
        const currentItemBottom = itemTop + cacheHeight;
        if (startIndex === void 0 && currentItemBottom >= scrollTop) {
          startIndex = i;
          startOffset = itemTop;
        }
        if (endIndex === void 0 && currentItemBottom > scrollTopHeight) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
      }
      if (endIndex === void 0) {
        endIndex = mergedDataValue.length - 1;
      }
      endIndex = Math.min(endIndex + 1, mergedDataValue.length);
      Object.assign(calRes, {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      });
    }, {
      immediate: true
    });
    const maxScrollHeight = computed(() => (calRes.scrollHeight || 0) - props.height);
    const keepInRange = (newScrollTop) => {
      let newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeight.value)) {
        newTop = Math.min(newTop, maxScrollHeight.value);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    };
    const isScrollAtTop = computed(() => state.scrollTop <= 0);
    const isScrollAtBottom = computed(() => state.scrollTop >= maxScrollHeight.value);
    const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    const syncScrollTop = (newTop) => {
      let value;
      if (typeof newTop === "function") {
        value = newTop(state.scrollTop);
      } else {
        value = newTop;
      }
      const alignedTop = keepInRange(value);
      if (componentRef.value) {
        componentRef.value.scrollTop = alignedTop;
      }
      state.scrollTop = alignedTop;
    };
    const onScrollBar = (newScrollTop) => {
      const newTop = newScrollTop;
      syncScrollTop(newTop);
    };
    const oldScrollTop = ref(0);
    const onComponentScroll = (e) => {
      var _a, _b;
      const {
        scrollTop: newScrollTop
      } = e.currentTarget;
      if (Math.abs(newScrollTop - state.scrollTop) >= 1) {
        syncScrollTop(newScrollTop);
      }
      if (oldScrollTop.value) {
        (_b = (_a = barRef == null ? void 0 : barRef.value) == null ? void 0 : _a.onShowBar) == null ? void 0 : _b.call(_a);
      }
      oldScrollTop.value = newScrollTop;
      ctx2.emit("scroll", e);
    };
    const [onRawWheel, onFireFoxScroll] = useFrameWheel(isVirtual, isScrollAtTop, isScrollAtBottom, (offsetY) => {
      syncScrollTop((top) => {
        const newTop = top + offsetY;
        return newTop;
      });
    });
    useMobileTouchMove(isVirtual, componentRef, (deltaY, smoothOffset) => {
      if (originScroll(deltaY, !!smoothOffset)) {
        return false;
      }
      onRawWheel({
        deltaY
      });
      return true;
    });
    const onMozMousePixelScroll = (e) => {
      if (isVirtual.value) {
        e.preventDefault();
      }
    };
    const removeEventListener = () => {
      if (componentRef.value) {
        componentRef.value.removeEventListener("wheel", onRawWheel, {
          passive: false
        });
        componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
    watchEffect(() => {
      nextTick(() => {
        if (componentRef.value) {
          removeEventListener();
          componentRef.value.addEventListener("wheel", onRawWheel, {
            passive: false
          });
          componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll);
          componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        }
      });
    });
    onBeforeUnmount(() => {
      removeEventListener();
    });
    const componentStyle = computed(() => {
      let cs = null;
      if (props.height) {
        cs = __spreadValues({
          maxHeight: isVirtual.value ? props.height + "px" : void 0
        }, ScrollStyle);
        if (isVirtual.value) {
          cs.overflowY = "hidden";
          if (state.scrollMoving) {
            cs.pointerEvents = "none";
          }
        }
      }
      return cs;
    });
    watch([() => calRes.start, () => calRes.end, mergedData], () => {
      const renderList = mergedData.value.slice(calRes.start, calRes.end + 1);
      ctx2.emit("show-change", renderList, mergedData.value);
    }, {
      flush: "post"
    });
    ctx2.expose({
      scrollTo(index2) {
        syncScrollTop(index2 * (props.itemHeight || DEFAULT_ITEM_HEIGHT));
      }
    });
    return () => {
      const Component = props.component;
      return createVNode("div", {
        "style": {
          position: "relative"
        }
      }, [createVNode(Component, {
        "style": componentStyle.value,
        "ref": componentRef,
        "onScroll": onComponentScroll
      }, {
        default: () => [createVNode(ResizeObserverContainer, {
          "height": calRes.scrollHeight,
          "offset": calRes.offset,
          "onInnerResize": collectHeight,
          "ref": fillerInnerRef
        }, {
          default: () => renderChildren(mergedData.value, calRes.start, calRes.end, setInstance, {
            getKey
          }, ctx2.slots.item)
        })]
      }), isVirtual.value && createVNode(ScrollBar, {
        "ref": barRef,
        "scrollTop": state.scrollTop,
        "height": props.height,
        "scrollHeight": calRes.scrollHeight,
        "count": mergedData.value.length,
        "onScroll": onScrollBar,
        "onStartMove": () => {
          state.scrollMoving = true;
        },
        "onStopMove": () => {
          state.scrollMoving = false;
        }
      }, null)]);
    };
  }
});
var VirtualListInstall = {
  title: "VirtualList \u865A\u62DF\u5217\u8868",
  category: "\u901A\u7528",
  status: "50%",
  install(app) {
    app.component(VirtualList.name, VirtualList);
  }
};
var CalendarPanel = defineComponent({
  name: "CalendarPanel",
  props: datePickerProPanelProps,
  emits: ["selectedDate", "changeRangeFocusType"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("date-picker-pro");
    const {
      yearScrollRef,
      monthScrollRef,
      yearAndMonthList,
      allMonthList,
      isListCollapse,
      handlerSelectDate,
      handlerYearCollapse,
      handlerClickMonth,
      handleScrollMonthList,
      isDateSelected,
      isStartDate,
      isInRangeDate,
      isEndDate,
      isDisabled
    } = useCalendarPanel(props, ctx2);
    return () => {
      const yearItemSlots = {
        item: (item) => {
          return createVNode("div", {
            "class": [ns2.em("calendar-panel", "year-list-item"), item.active && ns2.e("year-title-active")]
          }, [!item.isMonth && !isListCollapse.value && createVNode("div", {
            "class": ns2.e("year-title"),
            "onClick": () => handlerYearCollapse()
          }, [item.year]), !item.isMonth && isListCollapse.value && createVNode("div", {
            "class": ns2.e("year-title"),
            "onClick": () => {
              handlerClickMonth(item.year, 0);
            }
          }, [item.year]), item.isMonth && createVNode("div", {
            "class": ns2.e("month-title"),
            "onClick": () => {
              handlerClickMonth(item.year, item.month);
            }
          }, [t(`month${item.month ? item.month + 1 : 1}`)])]);
        }
      };
      const monthItemSlots = {
        item: (month) => {
          return createVNode("div", {
            "class": ns2.e("table-month")
          }, [createVNode("div", {
            "class": ns2.e("table-month-title")
          }, [t("getYearMonthStr")(month.year, (month.month || 0) + 1)]), createVNode("table", {
            "class": ns2.e("table-month-content")
          }, [createVNode("tbody", null, [month.displayWeeks && month.displayWeeks.map((week, weekIndex) => createVNode("tr", {
            "class": ns2.e("table-week-header"),
            "key": weekIndex
          }, [week.map((day, dayIndex) => createVNode("td", {
            "key": dayIndex,
            "class": [day.inMonth && ns2.e("table-date"), isDateSelected(day.date) && ns2.e("table-date-selected"), day.isToday && ns2.e("table-date-today"), isStartDate(day.date) && ns2.e("table-date-start"), isInRangeDate(day.date) && ns2.e("table-date-in-range"), isEndDate(day.date) && ns2.e("table-date-end"), isDisabled(day.date) && ns2.e("table-date-disabled")],
            "onClick": (e) => {
              e.preventDefault();
              e.stopPropagation();
              handlerSelectDate(day);
            }
          }, [createVNode("span", null, [day.inMonth ? day.day : ""])]))]))])])]);
        }
      };
      return createVNode("div", {
        "class": ns2.e("calendar-panel")
      }, [createVNode(VirtualList, {
        "ref": yearScrollRef,
        "class": ns2.em("calendar-panel", "year-list"),
        "data": yearAndMonthList.value,
        "height": yearListHeight,
        "itemHeight": yearItemHeight
      }, yearItemSlots), createVNode("div", {
        "class": ns2.em("calendar-panel", "main")
      }, [createVNode("table", {
        "class": ns2.e("calendar-table")
      }, [createVNode("thead", null, [createVNode("tr", {
        "class": ns2.e("table-week-header")
      }, [t("getWeekDays")().map((child) => createVNode("td", null, [child]))])]), createVNode("tbody", null, [createVNode("tr", null, [createVNode("td", {
        "colspan": "7"
      }, [createVNode(VirtualList, {
        "ref": monthScrollRef,
        "class": ns2.e("tbody-wrapper"),
        "data": allMonthList.value,
        "height": calendarListHeight,
        "itemHeight": calendarItemHeight,
        "onScroll": handleScrollMonthList
      }, monthItemSlots)])])])])])]);
    };
  }
});
const usePopupLine = (hourListRef, minuteListRef, secondListRef, minTime, maxTime, format2, itemHeight, timeListDom, ctx2) => {
  const activeTime = ref("00:00:00");
  const activeHour = ref("00");
  const activeMinute = ref("00");
  const activeSecond = ref("00");
  const setItemAstrict = (timeArr, min, max) => {
    timeArr.map((item) => {
      if (min !== "00" && item.time < min) {
        item.isDisabled = true;
      } else if (max !== "00" && item.time > max) {
        item.isDisabled = true;
      } else {
        item.isDisabled = false;
      }
    });
  };
  const getItemAstrict = (item) => {
    let min = "00";
    let max = "00";
    const minTimeHour = minTime.split(":")[0];
    const minTimeMinute = minTime.split(":")[1];
    const minTimeSecond = minTime.split(":")[2];
    const maxTimeHour = maxTime.split(":")[0];
    const maxTimeMinute = maxTime.split(":")[1];
    const maxTimeSecond = maxTime.split(":")[2];
    if (item.flag === "hour") {
      if (item.time === minTimeHour) {
        min = minTimeMinute;
        setItemAstrict(minuteListRef, min, max);
        activeMinute.value < minTimeMinute && setItemAstrict(secondListRef, minTimeSecond, max);
      } else if (item.time === maxTimeHour) {
        max = maxTimeMinute;
        setItemAstrict(minuteListRef, min, max);
        setItemAstrict(secondListRef, min, maxTimeSecond);
      } else {
        setItemAstrict(minuteListRef, min, max);
        setItemAstrict(secondListRef, min, max);
      }
    }
    if (item.flag === "minute" && format2 === "mm:ss") {
      if (item.time === minTimeMinute) {
        min = minTimeSecond;
        setItemAstrict(secondListRef, min, max);
      } else if (item.time === maxTimeMinute) {
        max = maxTimeSecond;
        setItemAstrict(secondListRef, min, max);
      } else {
        setItemAstrict(secondListRef, min, max);
      }
    } else if (item.flag === "minute") {
      if (activeHour.value === minTimeHour && item.time === minTimeMinute) {
        min = minTimeSecond;
        setItemAstrict(secondListRef, min, max);
      } else if (activeHour.value === maxTimeHour && item.time === maxTimeMinute) {
        max = maxTimeSecond;
        setItemAstrict(secondListRef, min, max);
      } else {
        setItemAstrict(secondListRef, min, max);
      }
    }
  };
  const resetTimeActive = (timeArr, itemValue) => {
    timeArr.map((item) => {
      item.isActive = item.time === itemValue;
    });
  };
  const resetTimeAstrict = (timeArr, time) => {
    timeArr.map((item) => {
      if (item.time === time) {
        getItemAstrict(item);
      }
    });
  };
  const resetTimeValue = (time) => {
    const timeValueArr = time.split(":");
    let hh = 0;
    let mm = 0;
    let ss = 0;
    if (format2 === "hh:mm:ss") {
      hh = parseInt(timeValueArr[0]);
      mm = parseInt(timeValueArr[1]);
      ss = parseInt(timeValueArr[2]);
      timeListDom.value.children[0].lastElementChild.children[0].scrollTop = hh * itemHeight;
      timeListDom.value.children[1].lastElementChild.children[0].scrollTop = mm * itemHeight;
      timeListDom.value.children[2].lastElementChild.children[0].scrollTop = ss * itemHeight;
      activeHour.value = timeValueArr[0];
      activeMinute.value = timeValueArr[1];
      activeSecond.value = timeValueArr[2];
      resetTimeActive(hourListRef, timeValueArr[0]);
      resetTimeActive(minuteListRef, timeValueArr[1]);
      resetTimeActive(secondListRef, timeValueArr[2]);
      resetTimeAstrict(hourListRef, activeHour.value);
      resetTimeAstrict(minuteListRef, activeMinute.value);
    } else if (format2 === "mm:hh:ss") {
      hh = parseInt(timeValueArr[0]);
      mm = parseInt(timeValueArr[1]);
      ss = parseInt(timeValueArr[2]);
      timeListDom.value.children[0].lastElementChild.children[0].scrollTop = mm * itemHeight;
      timeListDom.value.children[1].lastElementChild.children[0].scrollTop = hh * itemHeight;
      timeListDom.value.children[2].lastElementChild.children[0].scrollTop = ss * itemHeight;
      activeHour.value = timeValueArr[0];
      activeMinute.value = timeValueArr[1];
      activeSecond.value = timeValueArr[2];
      resetTimeActive(hourListRef, timeValueArr[0]);
      resetTimeActive(minuteListRef, timeValueArr[1]);
      resetTimeActive(secondListRef, timeValueArr[2]);
      resetTimeAstrict(hourListRef, activeHour.value);
      resetTimeAstrict(minuteListRef, activeMinute.value);
    } else if (format2 === "hh:mm") {
      hh = parseInt(timeValueArr[0]);
      mm = parseInt(timeValueArr[1]);
      timeListDom.value.children[0].lastElementChild.children[0].scrollTop = hh * itemHeight;
      timeListDom.value.children[1].lastElementChild.children[0].scrollTop = mm * itemHeight;
      activeHour.value = timeValueArr[0];
      activeMinute.value = timeValueArr[1];
      activeSecond.value = timeValueArr[2];
      resetTimeActive(hourListRef, timeValueArr[0]);
      resetTimeActive(minuteListRef, timeValueArr[1]);
      resetTimeAstrict(hourListRef, activeHour.value);
    } else if (format2 === "mm:ss") {
      mm = parseInt(timeValueArr[1]);
      ss = parseInt(timeValueArr[2]);
      timeListDom.value.children[0].lastElementChild.children[0].scrollTop = mm * itemHeight;
      timeListDom.value.children[1].lastElementChild.children[0].scrollTop = ss * itemHeight;
      activeHour.value = timeValueArr[0];
      activeMinute.value = timeValueArr[1];
      activeSecond.value = timeValueArr[2];
      resetTimeActive(minuteListRef, timeValueArr[1]);
      resetTimeActive(secondListRef, timeValueArr[2]);
      resetTimeAstrict(minuteListRef, activeMinute.value);
    }
  };
  const setTimeActive = (item, index2) => {
    let activeTimeList = [];
    let activeTimeValue = ref("");
    if (item.flag === "hour") {
      activeTimeList = hourListRef;
      activeTimeValue = activeHour;
      getItemAstrict(item);
    } else if (item.flag === "minute") {
      activeTimeList = minuteListRef;
      activeTimeValue = activeMinute;
      getItemAstrict(item);
    } else if (item.flag === "second") {
      activeTimeList = secondListRef;
      activeTimeValue = activeSecond;
    }
    activeTimeList.map((timeItem, timeIndex) => {
      timeItem.isActive = index2 === timeIndex;
    });
    activeTimeValue.value = activeTimeList[index2].time;
    activeTime.value = `${activeHour.value}:${activeMinute.value}:${activeSecond.value}`;
    if (activeTime.value < minTime) {
      activeTime.value = minTime;
      resetTimeValue(minTime);
    } else if (format2 === "mm:ss" && `${activeMinute.value}:${activeSecond.value}` > maxTime.slice(3)) {
      const newMinTime = minTime.slice(0, 3) + maxTime.slice(3);
      resetTimeValue(newMinTime);
    } else if (activeTime.value > maxTime) {
      activeTime.value = maxTime;
      resetTimeValue(maxTime);
    }
  };
  const activeTimeFun = (e, item, index2) => {
    var _a, _b;
    if (item.isDisabled) {
      return false;
    } else {
      setTimeActive(item, index2);
      if ((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.parentElement) {
        const pdom = (_b = e == null ? void 0 : e.target) == null ? void 0 : _b.parentElement;
        pdom && pdom.parentElement && (pdom.parentElement.scrollTop = index2 * itemHeight);
      }
    }
    ctx2.emit("change", { activeHour, activeMinute, activeSecond });
  };
  const getNewTime = () => {
    return { activeTime, activeHour, activeMinute, activeSecond };
  };
  const resetScrollTop = () => {
    for (let i = 0; i < timeListDom.value.children.length; i++) {
      timeListDom.value.children[i].lastElementChild.children[0].scrollTop = 0;
    }
  };
  return {
    activeTime,
    activeHour,
    activeMinute,
    activeSecond,
    activeTimeFun,
    resetTimeValue,
    getNewTime,
    resetScrollTop
  };
};
const popupLineProps = {
  hourList: {
    type: Array,
    default: () => []
  },
  minuteList: {
    type: Array,
    default: () => []
  },
  secondList: {
    type: Array,
    default: () => []
  },
  format: {
    type: String,
    default: "hh:mm:ss"
  },
  minTime: {
    type: String,
    default: "00:00:00"
  },
  maxTime: {
    type: String,
    default: "23:59:59"
  },
  itemHeight: {
    type: Number,
    default: 32
  }
};
const timePickerProps = {
  modelValue: {
    type: String,
    default: ""
  },
  placeholder: {
    type: String,
    default: "00:00:00"
  },
  disabled: {
    type: Boolean,
    default: false
  },
  timePickerWidth: {
    type: Number,
    default: 212
  },
  minTime: {
    type: String,
    default: "00:00:00"
  },
  maxTime: {
    type: String,
    default: "23:59:59"
  },
  format: {
    type: String,
    default: "hh:mm:ss"
  },
  autoOpen: {
    type: Boolean,
    default: false
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  size: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: false
  }
};
function useTimeScroll() {
  const scrollBoxDom = ref(null);
  const scrollContentDom = ref(null);
  const scrollThumbDom = ref(null);
  const scrollTrackDom = ref(null);
  const isDown = ref(false);
  const getScrollHeight = () => {
    var _a, _b;
    const thumbHeight = (((_a = scrollContentDom.value) == null ? void 0 : _a.clientHeight) || 0) / (((_b = scrollContentDom.value) == null ? void 0 : _b.scrollHeight) || 0) * 100;
    scrollThumbDom.value && (scrollThumbDom.value.style.height = thumbHeight + "%");
  };
  const setVirtualScroll = () => {
    var _a, _b;
    const thumbMoveY = (((_a = scrollContentDom.value) == null ? void 0 : _a.scrollTop) || 0) * 100 / (((_b = scrollContentDom.value) == null ? void 0 : _b.clientHeight) || 0);
    scrollThumbDom.value && (scrollThumbDom.value.style.transform = `translateY(${thumbMoveY}%)`);
  };
  const clickTrackFun = (e) => {
    var _a, _b, _c, _d, _e;
    const offsetNum = (((_c = (_b = (_a = scrollTrackDom.value) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.top) || 0) - e.clientY;
    const offset2 = Math.abs(offsetNum > 0 ? 0 : offsetNum);
    const thumbCenter = (((_d = scrollThumbDom.value) == null ? void 0 : _d.offsetHeight) || 0) / 2;
    const thumbPosition = (offset2 - thumbCenter) * 100 / (((_e = scrollContentDom.value) == null ? void 0 : _e.offsetHeight) || 0);
    if (scrollContentDom.value) {
      scrollContentDom.value.scrollTop = thumbPosition * scrollContentDom.value.scrollHeight / 100;
      scrollContentDom.value.style.top = scrollContentDom.value.scrollTop + "px";
    }
  };
  const thumbMouseMove = (e) => {
    const path = e.composedPath && e.composedPath() || e.path;
    if (scrollBoxDom.value && path.includes(scrollBoxDom.value) || isDown.value) {
      scrollTrackDom.value && (scrollTrackDom.value.style.opacity = "1");
    } else {
      scrollTrackDom.value && (scrollTrackDom.value.style.opacity = "0");
    }
    if (!isDown.value) {
      return;
    }
    clickTrackFun(e);
  };
  const mouseDownThum = () => {
    isDown.value = true;
    scrollTrackDom.value && (scrollTrackDom.value.style.opacity = "1");
  };
  const mouseOutThum = (e) => {
    isDown.value = false;
    thumbMouseMove(e);
  };
  const getScrollWidth = () => {
    var _a;
    const ua = navigator.userAgent;
    let marginRight = -20;
    if (ua.indexOf("Chrome") > -1) {
      marginRight = -8;
    } else {
      const outer = document.createElement("div");
      outer.className = "devui-scrollbar-wrap";
      outer.style.width = "100px";
      outer.style.visibility = "hidden";
      outer.style.position = "absolute";
      outer.style.top = "-9999px";
      document.body.appendChild(outer);
      const widthNoScroll = outer.offsetWidth;
      outer.style.overflow = "scroll";
      const inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
      const widthWithScroll = inner.offsetWidth;
      (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
      marginRight = (widthNoScroll - widthWithScroll + 3) * -1;
    }
    return marginRight;
  };
  return {
    scrollThumbDom,
    scrollTrackDom,
    scrollContentDom,
    scrollBoxDom,
    isDown,
    getScrollHeight,
    setVirtualScroll,
    clickTrackFun,
    mouseDownThum,
    mouseOutThum,
    thumbMouseMove,
    getScrollWidth
  };
}
var index$3 = "";
var TimeScroll = defineComponent({
  name: "DTimeScroll",
  props: timePickerProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("scroll-box");
    const {
      scrollBoxDom,
      scrollThumbDom,
      scrollTrackDom,
      scrollContentDom,
      isDown,
      getScrollHeight,
      setVirtualScroll,
      clickTrackFun,
      mouseDownThum,
      mouseOutThum,
      thumbMouseMove,
      getScrollWidth
    } = useTimeScroll();
    const marginRight = getScrollWidth();
    onMounted(() => {
      var _a, _b, _c;
      getScrollWidth();
      getScrollHeight();
      (_a = scrollBoxDom.value) == null ? void 0 : _a.addEventListener("click", setVirtualScroll);
      (_b = scrollContentDom.value) == null ? void 0 : _b.addEventListener("scroll", setVirtualScroll);
      (_c = scrollThumbDom.value) == null ? void 0 : _c.addEventListener("mousedown", mouseDownThum);
      document.addEventListener("mouseup", mouseOutThum);
      document.addEventListener("mousemove", thumbMouseMove);
    });
    onBeforeUnmount(() => {
      var _a, _b, _c;
      (_a = scrollBoxDom.value) == null ? void 0 : _a.removeEventListener("click", setVirtualScroll);
      (_b = scrollContentDom.value) == null ? void 0 : _b.removeEventListener("scroll", setVirtualScroll);
      (_c = scrollThumbDom.value) == null ? void 0 : _c.removeEventListener("mousedown", mouseDownThum);
    });
    onUnmounted(() => {
      document.removeEventListener("mouseup", mouseOutThum);
      document.removeEventListener("mousemove", thumbMouseMove);
    });
    return () => {
      var _a, _b;
      return createVNode(Fragment, null, [createVNode("div", {
        "ref": scrollBoxDom,
        "class": ns2.b()
      }, [createVNode("div", {
        "ref": scrollContentDom,
        "class": `box-content ${isDown.value || !props.showAnimation ? "box-content-behavior-auto" : ""}`,
        "style": {
          "margin-right": marginRight + "px"
        }
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]), createVNode("div", {
        "ref": scrollTrackDom,
        "class": "box-sroll",
        "onClick": clickTrackFun
      }, [createVNode("div", {
        "ref": scrollThumbDom,
        "class": "scroll-child"
      }, null)])])]);
    };
  }
});
var index$2 = "";
var PopupLine = defineComponent({
  name: "DTimeList",
  props: popupLineProps,
  emits: ["change"],
  setup(props, ctx2) {
    const ns2 = useNamespace("time-list");
    const timeListDom = ref();
    const {
      getNewTime,
      activeTimeFun,
      resetTimeValue,
      resetScrollTop
    } = usePopupLine(props.hourList, props.minuteList, props.secondList, props.minTime, props.maxTime, props.format, props.itemHeight, timeListDom, ctx2);
    const setOuterTime = (time) => {
      resetTimeValue(time);
    };
    const TimeLi = (timeArr) => {
      return timeArr.map((item, index2) => createVNode("li", {
        "class": `time-li ${item.flag}Id-${index2} ${item.isActive ? "active-li" : ""} ${item.isDisabled ? "disabled-li" : ""}`,
        "onClick": (e) => {
          activeTimeFun(e, item, index2);
        }
      }, [createVNode("span", null, [item.time])]));
    };
    const TimeUl = (timeList) => {
      return createVNode("div", {
        "class": "time-item",
        "style": {
          flex: 1
        }
      }, [createVNode(TimeScroll, null, {
        default: () => [createVNode("ul", {
          "class": "time-ul"
        }, [TimeLi(timeList)])]
      })]);
    };
    const formatTimeUl = () => {
      const timeList = {
        hh: props.hourList,
        mm: props.minuteList,
        ss: props.secondList
      };
      const timeFormatArr = props.format.split(":");
      return timeFormatArr.map((timeItem) => {
        return TimeUl(timeList[timeItem]);
      });
    };
    ctx2.expose({
      resetScrollTop,
      setOuterTime,
      getNewTime
    });
    return () => createVNode("div", {
      "class": ns2.b(),
      "ref": timeListDom
    }, [formatTimeUl()]);
  }
});
function initializeTimeData(type4) {
  const timeArr = reactive([]);
  let arrLength = 0;
  if (type4 === "hour") {
    arrLength = 24;
  } else {
    arrLength = 60;
  }
  for (let i = 0; i < arrLength; i++) {
    timeArr.push({
      time: i < 10 ? "0" + i : i + "",
      isActive: false,
      flag: type4,
      isDisabled: false,
      type: type4
    });
  }
  return timeArr;
}
const setTimeAstrict = (hourList, minuteList, secondList, minTime, maxTime, format2) => {
  const maxTimeHour = maxTime.split(":")[0];
  const maxTimeMinute = maxTime.split(":")[1];
  const minTimeHour = minTime.split(":")[0];
  const minTimeMinute = minTime.split(":")[1];
  const minTimeSecond = minTime.split(":")[2];
  hourList.map((item) => {
    if (item.time < minTimeHour || item.time > maxTimeHour) {
      item.isDisabled = true;
    }
  });
  if (format2 === "mm:ss") {
    minuteList.map((item) => {
      if (item.time < minTimeMinute || item.time > maxTimeMinute) {
        item.isDisabled = true;
      }
    });
  } else {
    minuteList.map((item) => {
      if (item.time < minTimeMinute) {
        item.isDisabled = true;
      }
    });
  }
  secondList.map((item) => {
    if (item.time < minTimeSecond) {
      item.isDisabled = true;
    }
  });
};
function useTimePickerPanel(props, ctx2) {
  const timeListDom = ref();
  const hourList = initializeTimeData("hour");
  const minuteList = initializeTimeData("minute");
  const secondList = initializeTimeData("second");
  onMounted(() => {
    var _a;
    if (props.bindData) {
      (_a = timeListDom == null ? void 0 : timeListDom.value) == null ? void 0 : _a.setOuterTime(props.bindData);
    }
  });
  watch(() => [props.visible, props.bindData], ([visible, newTimeVal], [, oldTimeVal]) => {
    if (newTimeVal && (visible || newTimeVal !== oldTimeVal)) {
      timeListDom.value.setOuterTime(newTimeVal);
    } else {
      timeListDom.value.resetScrollTop();
      resetActiveTimeData(hourList);
      resetActiveTimeData(minuteList);
      resetActiveTimeData(secondList);
    }
  });
  const handlerTimeSelected = (date4) => {
    const { activeHour, activeMinute, activeSecond } = date4;
    const time = `${activeHour.value}:${activeMinute.value}:${activeSecond.value}`;
    ctx2.emit("selectedTime", time);
  };
  return {
    timeListDom,
    hourList,
    minuteList,
    secondList,
    handlerTimeSelected
  };
}
var TimerPickerPanel = defineComponent({
  name: "TimerPickerPanel",
  props: timerPickerPanelProps,
  emits: ["selectedTime"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("date-picker-pro");
    const {
      timeListDom,
      hourList,
      minuteList,
      secondList,
      handlerTimeSelected
    } = useTimePickerPanel(props, ctx2);
    return () => {
      return createVNode("div", {
        "class": ns2.e("panel-time")
      }, [createVNode("div", {
        "class": ns2.em("panel-time", "title")
      }, [t("getTimeArr")().map((child) => createVNode("span", {
        "class": ns2.em("panel-time", "title-item")
      }, [createTextVNode(" "), child]))]), createVNode("div", {
        "class": ns2.em("panel-time", "content")
      }, [createVNode(PopupLine, {
        "ref": timeListDom,
        "hourList": hourList,
        "minuteList": minuteList,
        "secondList": secondList,
        "itemHeight": 30,
        "onChange": handlerTimeSelected
      }, null)])]);
    };
  }
});
function useYearCalendarPanel(props, ctx2) {
  const ns2 = useNamespace("date-picker-pro");
  const yarListScrollRef = ref();
  const yearList = ref([]);
  const { today, calendarRange, selectDate, rangeSelectDate, minDate, maxDate, fixRangeDate, getToDate, emitSelectedDate } = useCalendarSelected(props, ctx2);
  const initYearList = () => {
    var _a, _b;
    calendarRange.value[0] = ((_a = props.calendarRange) == null ? void 0 : _a[0]) || 1970;
    calendarRange.value[1] = ((_b = props.calendarRange) == null ? void 0 : _b[1]) || 2099;
    const list2 = new Array(calendarRange.value[1] - calendarRange.value[0] + 1).fill(1).map((item, i) => i + calendarRange.value[0]);
    yearList.value = lodash.exports.chunk(list2, 3);
  };
  const goToShowYear = (date4) => {
    if (date4) {
      const index2 = Math.floor((date4.year() - calendarRange.value[0]) / 3);
      let scrollIndex = index2 - 1;
      if (scrollIndex < 0) {
        scrollIndex = 0;
      }
      nextTick(() => {
        var _a;
        const scrollEl = yarListScrollRef.value;
        (_a = scrollEl == null ? void 0 : scrollEl.scrollTo) == null ? void 0 : _a.call(scrollEl, scrollIndex);
      });
    }
  };
  onBeforeMount(() => {
    today.value = new Date();
    initYearList();
    const toDate = getToDate(props.dateValue);
    if (props.visible && toDate) {
      goToShowYear(toDate);
    }
  });
  const isThisYear = (year) => {
    return year === today.value.getFullYear();
  };
  const isDisableYear = (year) => {
    const date4 = new Date(year, 0, 1);
    return maxDate.value.getTime() < date4.getTime() || minDate.value.getTime() > date4.getTime();
  };
  const isActiveYear = (year) => {
    var _a, _b, _c;
    if (props.isRangeType) {
      return year === ((_a = rangeSelectDate.value[0]) == null ? void 0 : _a.year()) || year === ((_b = rangeSelectDate.value[1]) == null ? void 0 : _b.year());
    } else {
      return year === ((_c = selectDate.value) == null ? void 0 : _c.year());
    }
  };
  const isStartYear = (year) => {
    var _a;
    if (!props.isRangeType) {
      return false;
    }
    return year === ((_a = rangeSelectDate.value[0]) == null ? void 0 : _a.year());
  };
  const isEndYear = (year) => {
    var _a;
    if (!props.isRangeType) {
      return false;
    }
    return year === ((_a = rangeSelectDate.value[1]) == null ? void 0 : _a.year());
  };
  const isInRangeYear = (year) => {
    if (!props.isRangeType) {
      return false;
    }
    const isIn2 = rangeSelectDate.value[0] && rangeSelectDate.value[0].year() < year && rangeSelectDate.value[1] && rangeSelectDate.value[1].year() > year;
    return isIn2 ? true : false;
  };
  const getYearItemCls = (year) => {
    return {
      [ns2.e("year-item-title")]: true,
      [ns2.e("this-year")]: isThisYear(year),
      [ns2.e("year-disabled")]: isDisableYear(year),
      [ns2.e("year-active")]: isActiveYear(year),
      [ns2.e("year-start")]: isStartYear(year),
      [ns2.e("year-end")]: isEndYear(year),
      [ns2.e("year-in-range")]: isInRangeYear(year)
    };
  };
  watch([() => props.dateValue, () => props.focusType], ([dateValue, focusType]) => {
    if (Array.isArray(dateValue)) {
      rangeSelectDate.value = dateValue;
      let date4;
      if (focusType === "start") {
        date4 = dateValue[0];
      } else {
        date4 = dateValue[1] || dateValue[0];
      }
      if (date4) {
        goToShowYear(date4);
      } else {
        selectDate.value = date4;
      }
    } else {
      selectDate.value = dateValue;
      if (dateValue) {
        goToShowYear(dateValue);
      }
    }
  }, { deep: true });
  const handlerSetRangeDate = (year) => {
    const date4 = dayjs(new Date(year, 0, 1)).locale("zh-cn");
    if (props.focusType === "start") {
      rangeSelectDate.value[0] = date4;
    } else if (props.focusType === "end") {
      rangeSelectDate.value[1] = date4;
    }
    fixRangeDate();
  };
  const handlerSelectYear = (year) => {
    if (isDisableYear(year)) {
      return;
    }
    selectDate.value = dayjs(new Date(year, 0, 1)).locale("zh-cn");
    if (props.isRangeType) {
      handlerSetRangeDate(year);
    }
    emitSelectedDate();
  };
  return { yarListScrollRef, yearList, getYearItemCls, handlerSelectYear };
}
var YearCalendarPanel = defineComponent({
  name: "YearCalendarPanel",
  props: datePickerProPanelProps,
  emits: ["selectedDate", "changeRangeFocusType"],
  setup(props, ctx2) {
    const ns2 = useNamespace("date-picker-pro");
    const {
      yarListScrollRef,
      yearList,
      getYearItemCls,
      handlerSelectYear
    } = useYearCalendarPanel(props, ctx2);
    return () => {
      const yearItemSlots = {
        item: (years) => {
          return createVNode("div", {
            "class": ns2.e("year-list-item")
          }, [years.map((year) => createVNode("div", {
            "key": year,
            "class": getYearItemCls(year),
            "onClick": (e) => {
              e.preventDefault();
              e.stopPropagation();
              handlerSelectYear(year);
            }
          }, [year]))]);
        }
      };
      return createVNode("div", {
        "class": ns2.e("year-calendar-panel")
      }, [createVNode(VirtualList, {
        "ref": yarListScrollRef,
        "class": ns2.e("year-list"),
        "data": yearList.value,
        "height": yearPickerHeight,
        "itemHeight": yearCalendarItemHeight
      }, yearItemSlots)]);
    };
  }
});
function useMonthCalendarPanel(props, ctx2) {
  const ns2 = useNamespace("date-picker-pro");
  const yearScrollRef = ref();
  const monthScrollRef = ref();
  const yearList = ref([]);
  const monthList = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [10, 11, 12]
  ];
  const currentYearIndex = ref(0);
  const {
    today,
    calendarRange,
    selectDate,
    rangeSelectDate,
    minDate,
    maxDate,
    fixRangeDate,
    getToDate,
    emitSelectedDate,
    isStartDate,
    isInRangeDate,
    isEndDate
  } = useCalendarSelected(props, ctx2);
  const initYearList = () => {
    const years = [];
    for (let index2 = calendarRange.value[0]; index2 <= calendarRange.value[1]; index2++) {
      years.push({
        year: index2,
        active: false
      });
    }
    yearList.value = years;
  };
  const updateYearActive = () => {
    const curActive = yearList.value.find((child) => child.active);
    if (curActive) {
      curActive.active = false;
    }
    yearList.value[currentYearIndex.value].active = true;
  };
  const goToYearDate = () => {
    updateYearActive();
    let scrollIndex = currentYearIndex.value - 4;
    if (scrollIndex < 0) {
      scrollIndex = 0;
    }
    nextTick(() => {
      var _a;
      const scrollEl = yearScrollRef.value;
      (_a = scrollEl == null ? void 0 : scrollEl.scrollTo) == null ? void 0 : _a.call(scrollEl, scrollIndex);
    });
  };
  const goToMonthDate = () => {
    let scrollIndex = currentYearIndex.value;
    if (scrollIndex < 0) {
      scrollIndex = 0;
    }
    nextTick(() => {
      var _a;
      const scrollEl = monthScrollRef.value;
      (_a = scrollEl == null ? void 0 : scrollEl.scrollTo) == null ? void 0 : _a.call(scrollEl, scrollIndex);
    });
  };
  const goToShowDate = (date4) => {
    const year = date4.year();
    currentYearIndex.value = year - calendarRange.value[0];
    goToYearDate();
    goToMonthDate();
  };
  onBeforeMount(() => {
    today.value = new Date();
    calendarRange.value = props.calendarRange;
    initYearList();
    const toDate = getToDate(props.dateValue);
    if (props.visible && toDate) {
      goToShowDate(toDate);
    }
  });
  const handlerSelectYear = (year) => {
    const toDate = dayjs(new Date(year, 0, 1)).locale("zh-cn");
    goToShowDate(toDate);
  };
  const debounceScrollMonth = lodash.exports.throttle((newScrollTop) => {
    currentYearIndex.value = Math.floor(newScrollTop / monthCalendarItemHeight) + (newScrollTop % monthCalendarItemHeight > 100 ? 1 : 0);
    goToYearDate();
  }, 200);
  const handlerMonthScroll = (e) => {
    let { scrollTop: newScrollTop } = e.currentTarget;
    newScrollTop = newScrollTop > 0 ? newScrollTop : 0;
    debounceScrollMonth(newScrollTop);
  };
  const isThisMonth = (year, month) => {
    return year === today.value.getFullYear() && month === today.value.getMonth() + 1;
  };
  const isDisableMonth = (year, month) => {
    const date4 = new Date(year, month - 1, 1);
    return maxDate.value.getTime() < date4.getTime() || minDate.value.getTime() > date4.getTime();
  };
  const isActiveMonth = (year, month) => {
    var _a, _b, _c, _d, _e, _f;
    if (props.isRangeType) {
      return year === ((_a = rangeSelectDate.value[0]) == null ? void 0 : _a.year()) && month === ((_b = rangeSelectDate.value[0]) == null ? void 0 : _b.month()) + 1 || year === ((_c = rangeSelectDate.value[1]) == null ? void 0 : _c.year()) && month === ((_d = rangeSelectDate.value[1]) == null ? void 0 : _d.month()) + 1;
    } else {
      return year === ((_e = selectDate.value) == null ? void 0 : _e.year()) && month === ((_f = selectDate.value) == null ? void 0 : _f.month()) + 1;
    }
  };
  const isStartMonth = (year, month) => {
    const date4 = new Date(year, month - 1, 1);
    return isStartDate(date4);
  };
  const isEndMonth = (year, month) => {
    const date4 = new Date(year, month - 1, 1);
    return isEndDate(date4);
  };
  const isInRangeMonth = (year, month) => {
    const date4 = new Date(year, month - 1, 1);
    return isInRangeDate(date4);
  };
  const getMonthItemCls = (year, month) => {
    return {
      [ns2.e("month-item")]: true,
      [ns2.e("this-month")]: isThisMonth(year, month),
      [ns2.e("month-disabled")]: isDisableMonth(year, month),
      [ns2.e("month-active")]: isActiveMonth(year, month),
      [ns2.e("month-start")]: isStartMonth(year, month),
      [ns2.e("month-end")]: isEndMonth(year, month),
      [ns2.e("month-in-range")]: isInRangeMonth(year, month)
    };
  };
  const handlerSetRangeDate = (year, month) => {
    const date4 = dayjs(new Date(year, month - 1, 1)).locale("zh-cn");
    if (props.focusType === "start") {
      rangeSelectDate.value[0] = date4;
    } else if (props.focusType === "end") {
      rangeSelectDate.value[1] = date4;
    }
    fixRangeDate();
  };
  const handlerSelectMonth = (year, month) => {
    if (isDisableMonth(year, month)) {
      return;
    }
    selectDate.value = dayjs(new Date(year, month - 1, 1)).locale("zh-cn");
    if (props.isRangeType) {
      handlerSetRangeDate(year, month);
    }
    emitSelectedDate();
  };
  watch([() => props.dateValue, () => props.focusType], ([dateValue, focusType]) => {
    if (Array.isArray(dateValue)) {
      rangeSelectDate.value = dateValue;
      let date4;
      if (focusType === "start") {
        date4 = dateValue[0];
      } else {
        date4 = dateValue[1] || dateValue[0];
      }
      if (date4) {
        goToShowDate(date4);
      } else {
        selectDate.value = date4;
      }
    } else {
      selectDate.value = dateValue;
      if (dateValue) {
        goToShowDate(dateValue);
      }
    }
  }, { deep: true });
  return {
    yearScrollRef,
    monthScrollRef,
    yearList,
    monthList,
    handlerSelectYear,
    handlerMonthScroll,
    getMonthItemCls,
    handlerSelectMonth
  };
}
var MonthCalendarPanel = defineComponent({
  name: "MonthCalendarPanel",
  props: datePickerProPanelProps,
  emits: ["selectedDate", "changeRangeFocusType"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("date-picker-pro");
    const {
      yearScrollRef,
      monthScrollRef,
      yearList,
      monthList,
      handlerSelectYear,
      handlerMonthScroll,
      getMonthItemCls,
      handlerSelectMonth
    } = useMonthCalendarPanel(props, ctx2);
    return () => {
      const yearItemSlots = {
        item: (year) => {
          return createVNode("div", {
            "class": [ns2.e("year-list-item"), year.active && ns2.e("year-item-active")],
            "key": year.year,
            "onClick": () => handlerSelectYear(year.year)
          }, [year.year]);
        }
      };
      const monthItemSlots = {
        item: (year) => {
          return createVNode("div", {
            "class": ns2.e("table-month")
          }, [createVNode("div", {
            "class": ns2.e("table-month-title")
          }, [year.year + t("year")]), createVNode("table", {
            "class": ns2.e("table-month-content")
          }, [createVNode("tbody", null, [monthList.map((season, seasonIndex) => createVNode("tr", {
            "key": seasonIndex
          }, [season.map((month) => createVNode("td", {
            "key": month,
            "class": getMonthItemCls(year.year, month),
            "onClick": (e) => {
              e.preventDefault();
              e.stopPropagation();
              handlerSelectMonth(year.year, month);
            }
          }, [createVNode("span", null, [t(`month${month}`) || "m"])]))]))])])]);
        }
      };
      return createVNode("div", {
        "class": ns2.e("month-calendar-panel")
      }, [createVNode(VirtualList, {
        "ref": yearScrollRef,
        "class": ns2.e("year-list"),
        "data": yearList.value,
        "height": monthPickerHeight,
        "itemHeight": yearItemHeight
      }, yearItemSlots), createVNode("div", {
        "class": ns2.e("month-wrapper")
      }, [createVNode(VirtualList, {
        "ref": monthScrollRef,
        "class": ns2.e("month-list"),
        "data": yearList.value,
        "height": monthPickerHeight,
        "itemHeight": monthCalendarItemHeight,
        "onScroll": handlerMonthScroll
      }, monthItemSlots)])]);
    };
  }
});
function useDatePicker(props, ctx2) {
  const calendarPanelRef = ref();
  const currentDate = ref();
  const currentRangeDate = ref([]);
  const timeData = ref("");
  const getSelectedDate = (date4) => {
    const curDate = date4.toDate().toLocaleDateString();
    const curDateTime = `${curDate} ${timeData.value || "00:00:00"}`;
    return dayjs(curDateTime).locale("zh-cn");
  };
  const getRangeSelectedDate = (date4) => {
    const [startDate, endDate] = date4;
    if (props.focusType === "start") {
      const selectStart = startDate ? getSelectedDate(startDate) : startDate;
      return [selectStart, endDate];
    } else {
      const selectEnd = endDate ? getSelectedDate(endDate) : endDate;
      return [startDate, selectEnd];
    }
  };
  const onSelectedDate = (date4) => {
    if (Array.isArray(date4)) {
      currentRangeDate.value = date4;
      if (props.focusType === "start") {
        timeData.value = "00:00:00";
      } else {
        timeData.value = "23:59:59";
      }
      if (!props.showTime) {
        ctx2.emit("selectedDate", date4, date4[0] && date4[1] && props.focusType === "end" ? true : false);
      } else {
        ctx2.emit("selectedDate", getRangeSelectedDate(date4), false);
      }
    } else {
      currentDate.value = date4;
      if (!props.showTime) {
        ctx2.emit("selectedDate", date4, true);
      } else {
        ctx2.emit("selectedDate", getSelectedDate(date4), false);
      }
    }
  };
  const timeFormat = computed(() => {
    const format2 = props.format || "YYYY/MM/DD";
    return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
  });
  const retDefaultDateValue = () => {
    currentDate.value = void 0;
    timeData.value = "";
  };
  watch([() => props.dateValue, () => props.focusType], ([dateValue, focusType]) => {
    if (Array.isArray(dateValue)) {
      if (dateValue[0]) {
        currentRangeDate.value[0] = dateValue[0];
      } else {
        currentRangeDate.value[0] = null;
      }
      if (dateValue[1]) {
        currentRangeDate.value[1] = dateValue[1];
      } else {
        currentRangeDate.value[1] = null;
      }
      let date4;
      if (focusType === "start") {
        date4 = dateValue[0];
      } else {
        date4 = dateValue[1] || dateValue[0];
      }
      if (date4) {
        currentDate.value = date4;
        timeData.value = date4.format(timeFormat.value);
      } else {
        retDefaultDateValue();
      }
    } else if (dateValue) {
      const date4 = dateValue;
      currentDate.value = date4;
      timeData.value = date4.format(timeFormat.value);
    } else {
      retDefaultDateValue();
    }
  }, { immediate: true, deep: true });
  const handlerConfirm = () => {
    if (props.isRangeType) {
      if (props.focusType === "start") {
        if (!currentRangeDate.value[0]) {
          return;
        }
        ctx2.emit("changeRangeFocusType", "end");
      }
      if (props.focusType === "end") {
        ctx2.emit("selectedDate", getRangeSelectedDate(currentRangeDate.value), true);
      }
    } else {
      if (!currentDate.value) {
        return;
      }
      ctx2.emit("selectedDate", getSelectedDate(currentDate.value), true);
    }
  };
  const handlerSelectedTime = (time) => {
    timeData.value = time;
    if (props.isRangeType) {
      if (props.focusType === "start") {
        if (currentRangeDate.value[0]) {
          ctx2.emit("selectedDate", getRangeSelectedDate(currentRangeDate.value), false);
        } else {
          const nowDate = dayjs().locale("zh-cn");
          currentRangeDate.value[0] = nowDate;
          ctx2.emit("selectedDate", getRangeSelectedDate(currentRangeDate.value), false);
        }
      }
      if (props.focusType === "end") {
        if (currentRangeDate.value[1]) {
          ctx2.emit("selectedDate", getRangeSelectedDate(currentRangeDate.value), false);
        } else {
          currentRangeDate.value[1] = currentRangeDate.value[0];
          ctx2.emit("selectedDate", getRangeSelectedDate(currentRangeDate.value), false);
        }
      }
    } else {
      if (currentDate.value) {
        ctx2.emit("selectedDate", getSelectedDate(currentDate.value), false);
      } else {
        const nowDate = dayjs().locale("zh-cn");
        ctx2.emit("selectedDate", getSelectedDate(nowDate), false);
      }
    }
  };
  const onChangeRangeFocusType = (type4) => {
    ctx2.emit("changeRangeFocusType", type4);
  };
  return {
    calendarPanelRef,
    timeData,
    onSelectedDate,
    handlerConfirm,
    handlerSelectedTime,
    onChangeRangeFocusType
  };
}
function _isSlot$9(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var DatePickerProPanel = defineComponent({
  name: "DatePickerProPanel",
  props: datePickerProPanelProps,
  emits: ["selectedDate", "changeRangeFocusType"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("date-picker-pro");
    const {
      calendarPanelRef,
      timeData,
      onSelectedDate,
      handlerConfirm,
      handlerSelectedTime,
      onChangeRangeFocusType
    } = useDatePicker(props, ctx2);
    return () => {
      var _a, _b, _c, _d, _e;
      let _slot;
      return createVNode("div", {
        "class": ns2.e("panel")
      }, [createVNode("div", {
        "class": ns2.e("panel-content")
      }, [props.type === "date" && createVNode(CalendarPanel, mergeProps({
        "ref": calendarPanelRef
      }, props, {
        "onSelectedDate": onSelectedDate,
        "onChangeRangeFocusType": onChangeRangeFocusType
      }), null), props.type === "date" && props.showTime && createVNode(TimerPickerPanel, {
        "visible": props.visible,
        "bindData": timeData.value,
        "onSelectedTime": handlerSelectedTime
      }, null), props.type === "year" && createVNode(YearCalendarPanel, mergeProps(props, {
        "onSelectedDate": onSelectedDate,
        "onChangeRangeFocusType": onChangeRangeFocusType
      }), null), props.type === "month" && createVNode(MonthCalendarPanel, mergeProps(props, {
        "onSelectedDate": onSelectedDate,
        "onChangeRangeFocusType": onChangeRangeFocusType
      }), null), ((_a = ctx2.slots) == null ? void 0 : _a.rightArea) && createVNode("div", {
        "class": ns2.e("panel-right-area")
      }, [(_b = ctx2.slots) == null ? void 0 : _b.rightArea()])]), ((_c = ctx2.slots) == null ? void 0 : _c.footer) && createVNode("div", {
        "class": ns2.e("panel-footer")
      }, [(_d = ctx2.slots) == null ? void 0 : _d.footer()]), !((_e = ctx2.slots) == null ? void 0 : _e.footer) && props.showTime && createVNode("div", {
        "class": ns2.e("panel-footer")
      }, [createVNode("div", {
        "class": ns2.e("panel-footer-center")
      }, [createVNode(DButton, {
        "variant": "solid",
        "onClick": handlerConfirm
      }, _isSlot$9(_slot = t("ok")) ? _slot : {
        default: () => [_slot]
      })])])]);
    };
  }
});
const IconCalendar = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("path", {
  "d": "M5,0 L5,1 L11,1 L11,0 L12,0 L12,1 L14,1 C15.1045695,         1 16,1.8954305 16,3 L16,14 C16,15.1045695 15.1045695,16 14,         16 L2,16 C0.8954305,16 0,15.1045695 0,14 L0,3 C0,         1.8954305 0.8954305,1 2,1 L4,1 L4,0 L5,0 Z M15,5 L1,         5 L1,14 C1,14.5522847 1.44771525,15 2,15 L14,15 C14.5522847,         15 15,14.5522847 15,14 L15,5 Z M6,7 C6.55228475,7 7,7.44771525 7,         8 L7,10 C7,10.5522847 6.55228475,11 6,11 L4,11 C3.44771525,11 3,         10.5522847 3,10 L3,8 C3,7.44771525 3.44771525,7 4,7 L6,7 Z M6,         8 L4,8 L4,10 L6,10 L6,8 Z M4,2 L2,2 C1.44771525,2 1,2.44771525 1,         3 L1,4 L15,4 L15,3 C15,2.44771525 14.5522847,2 14,2 L12,2 L12,         3 L11,3 L11,2 L5,2 L5,3 L4,3 L4,2 Z",
  "fill": "#BABBC0"
}, null)])]);
const IconClose$2 = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("path", {
  "d": "M8,1 C11.8659932,1 15,4.13400675 15,8 C15,         11.8659932 11.8659932,15 8,15 C4.13400675,15 1,         11.8659932 1,8 C1,4.13400675 4.13400675,1 8,         1 Z M5.87867966,5.17157288 C5.68341751,4.97631073 5.36683502,         4.97631073 5.17157288,5.17157288 C4.99800652,5.34513923 4.97872137,         5.61456363 5.11371742,5.80943177 L5.17157288,5.87867966 L7.29218611,         7.99929289 L5.17157288,10.1213203 C4.97631073,10.3165825 4.97631073,         10.633165 5.17157288,10.8284271 C5.34513923,11.0019935 5.61456363,         11.0212786 5.80943177,10.8862826 L5.87867966,10.8284271 L7.99929289,         8.70639967 L10.1213203,10.8284271 C10.3165825,11.0236893 10.633165,         11.0236893 10.8284271,10.8284271 C11.0019935,10.6548608 11.0212786,         10.3854364 10.8862826,10.1905682 L10.8284271,10.1213203 L8.70710678,         8 L10.8284271,5.87867966 C11.0236893,5.68341751 11.0236893,         5.36683502 10.8284271,5.17157288 C10.6548608,4.99800652 10.3854364,         4.97872137 10.1905682,5.11371742 L10.1213203,5.17157288 L8,         7.29289322 L5.87867966,5.17157288 Z",
  "fill-rule": "nonzero"
}, null)])]);
var datePickerPro = "";
var DatePickerPro = defineComponent({
  name: "DDatePickerPro",
  props: datePickerProProps,
  emits: ["update:modelValue", "toggleChange", "confirmEvent", "focus", "blur"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("date-picker-pro");
    const {
      originRef,
      inputRef,
      overlayRef,
      placeholder,
      isPanelShow,
      format: format2,
      dateValue,
      displayDateValue,
      isMouseEnter,
      showCloseIcon,
      pickerDisabled,
      pickerSize,
      isValidateError,
      onFocus,
      onSelectedDate,
      handlerClearTime
    } = usePickerPro(props, ctx2, t);
    const position = ref(["bottom-start", "top-start"]);
    return () => {
      var _a, _b;
      const vSlots = {
        rightArea: ((_a = ctx2.slots) == null ? void 0 : _a.rightArea) && (() => renderSlot(useSlots(), "rightArea")),
        footer: ((_b = ctx2.slots) == null ? void 0 : _b.footer) && (() => renderSlot(useSlots(), "footer"))
      };
      return createVNode("div", {
        "class": ns2.b()
      }, [createVNode("div", {
        "class": ns2.e("single-picker"),
        "ref": originRef,
        "onMouseover": () => isMouseEnter.value = true,
        "onMouseout": () => isMouseEnter.value = false
      }, [createVNode(DInput, {
        "ref": inputRef,
        "modelValue": displayDateValue.value,
        "placeholder": placeholder.value || t("placeholder"),
        "onFocus": withModifiers(onFocus, ["stop"]),
        "size": pickerSize.value,
        "disabled": pickerDisabled.value,
        "error": isValidateError.value
      }, {
        prefix: () => createVNode("span", {
          "class": ns2.e("single-picker-icon")
        }, [createVNode(IconCalendar, null, null)]),
        suffix: () => createVNode("span", {
          "class": ["close-icon", showCloseIcon.value ? ns2.m("icon-visible") : ns2.m("icon-hidden")],
          "onClick": handlerClearTime
        }, [createVNode(IconClose$2, null, null)])
      })]), createVNode(Teleport, {
        "to": "body"
      }, {
        default: () => [createVNode(Transition, {
          "name": "fade"
        }, {
          default: () => [createVNode(FlexibleOverlay, {
            "modelValue": isPanelShow.value,
            "onUpdate:modelValue": ($event) => isPanelShow.value = $event,
            "ref": overlayRef,
            "origin": originRef.value,
            "align": "start",
            "position": position.value,
            "style": {
              zIndex: "var(--b-z-index-dropdown, 1052)"
            }
          }, {
            default: () => [createVNode(DatePickerProPanel, mergeProps(props, {
              "dateValue": dateValue.value,
              "visible": isPanelShow.value,
              "format": format2.value,
              "onSelectedDate": onSelectedDate
            }), vSlots)]
          })]
        })]
      })]);
    };
  }
});
const rangeDatePickerProProps = __spreadValues({
  modelValue: {
    type: Array,
    default: ["", ""]
  },
  placeholder: {
    type: Array,
    default: ["", ""]
  },
  separator: {
    type: String,
    default: "-"
  }
}, datePickerProCommonProps);
function useRangePickerPro(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const originRef = ref();
  const startInputRef = shallowRef();
  const endInputRef = shallowRef();
  const overlayRef = shallowRef();
  const isPanelShow = ref(false);
  const placeholder = computed(() => props.placeholder);
  const isMouseEnter = ref(false);
  const focusType = ref("start");
  const pickerDisabled = computed(() => (formContext == null ? void 0 : formContext.disabled) || props.disabled);
  const pickerSize = computed(() => (formContext == null ? void 0 : formContext.size) || props.size);
  const isValidateError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const toggleChange = (isShow) => {
    isPanelShow.value = isShow;
    ctx2.emit("toggleChange", isShow);
    if (!isShow) {
      ctx2.emit("blur");
    }
  };
  onClickOutside(overlayRef, () => {
    toggleChange(false);
  }, { ignore: [originRef] });
  const focusHandler = function(e) {
    ctx2.emit("focus", e);
  };
  const format2 = computed(() => {
    return props.showTime ? props.format || "YYYY/MM/DD HH:mm:ss" : props.format || "YYYY/MM/DD";
  });
  const dateValue = computed(() => {
    let start;
    let end;
    if (props.modelValue[0]) {
      start = parserDate(props.modelValue[0]);
    }
    if (props.modelValue[1]) {
      end = parserDate(props.modelValue[1]);
    }
    return [start, end];
  });
  const displayDateValue = computed(() => {
    const startFormatDate = formatDayjsToStr(dateValue.value[0], format2.value, props.type);
    const endFormatDate = formatDayjsToStr(dateValue.value[1], format2.value, props.type);
    if (startFormatDate) {
      return endFormatDate ? [startFormatDate, endFormatDate] : [startFormatDate, ""];
    } else if (endFormatDate) {
      return startFormatDate ? [startFormatDate, endFormatDate] : ["", endFormatDate];
    }
    return ["", ""];
  });
  const showCloseIcon = computed(() => isMouseEnter.value && (displayDateValue.value[0] !== "" || displayDateValue.value[1] !== ""));
  const onSelectedDate = (date4, isConfirm) => {
    const [startDate, endDate] = date4;
    const selectStart = startDate ? startDate.toDate() : startDate;
    const selectEnd = endDate ? endDate.toDate() : endDate;
    const [start, end] = props.modelValue;
    if (!isDateEquals(start, selectStart) || !isDateEquals(end, selectEnd)) {
      ctx2.emit("update:modelValue", [selectStart ? selectStart : "", selectEnd ? selectEnd : ""]);
    }
    if (isConfirm) {
      ctx2.emit("confirmEvent", [selectStart ? selectStart : "", selectEnd ? selectEnd : ""]);
      toggleChange(false);
    }
  };
  const onChangeRangeFocusType = (type4) => {
    focusType.value = type4;
    if (focusType.value === "start") {
      setTimeout(() => {
        var _a;
        (_a = startInputRef.value) == null ? void 0 : _a.focus();
      });
    } else {
      setTimeout(() => {
        var _a;
        (_a = endInputRef.value) == null ? void 0 : _a.focus();
      });
    }
  };
  const handlerClearTime = (e) => {
    if (!showCloseIcon.value) {
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    ctx2.emit("update:modelValue", ["", ""]);
    ctx2.emit("confirmEvent", ["", ""]);
    if (isPanelShow.value) {
      onChangeRangeFocusType("start");
    }
  };
  ctx2.expose({
    focusChange: onChangeRangeFocusType
  });
  const onFocus = function(type4) {
    if (!isPanelShow.value) {
      type4 = "start";
    }
    onChangeRangeFocusType(type4);
    toggleChange(true);
  };
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  }, { deep: true });
  return {
    originRef,
    startInputRef,
    endInputRef,
    overlayRef,
    isPanelShow,
    placeholder,
    format: format2,
    dateValue,
    displayDateValue,
    isMouseEnter,
    showCloseIcon,
    focusType,
    pickerDisabled,
    pickerSize,
    isValidateError,
    onFocus,
    focusHandler,
    onSelectedDate,
    handlerClearTime,
    onChangeRangeFocusType
  };
}
var DRangeDatePickerPro = defineComponent({
  name: "DRangeDatePickerPro",
  props: rangeDatePickerProProps,
  emits: ["update:modelValue", "toggleChange", "confirmEvent", "focus", "blur"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DDatePickerPro", app);
    const ns2 = useNamespace("range-date-picker-pro");
    const {
      originRef,
      startInputRef,
      endInputRef,
      overlayRef,
      placeholder,
      isPanelShow,
      format: format2,
      dateValue,
      displayDateValue,
      isMouseEnter,
      showCloseIcon,
      onFocus,
      focusHandler,
      focusType,
      pickerDisabled,
      pickerSize,
      isValidateError,
      onSelectedDate,
      handlerClearTime,
      onChangeRangeFocusType
    } = useRangePickerPro(props, ctx2);
    const position = ref(["bottom-start", "top-start"]);
    return () => {
      var _a, _b;
      const vSlots = {
        rightArea: ((_a = ctx2.slots) == null ? void 0 : _a.rightArea) && (() => renderSlot(useSlots(), "rightArea")),
        footer: ((_b = ctx2.slots) == null ? void 0 : _b.footer) && (() => renderSlot(useSlots(), "footer"))
      };
      return createVNode("div", {
        "class": [ns2.b(), props.showTime ? ns2.e("range-time-width") : ns2.e("range-width"), isPanelShow.value && ns2.m("open")]
      }, [createVNode("div", {
        "class": [ns2.e("range-picker"), pickerDisabled.value && ns2.m("disabled"), isValidateError.value && ns2.m("error")],
        "ref": originRef,
        "onMouseover": () => isMouseEnter.value = true,
        "onMouseout": () => isMouseEnter.value = false
      }, [createVNode("span", {
        "class": [isPanelShow.value && focusType.value === "start" ? ns2.e("active-input") : ns2.e("normal-input"), ns2.e("input"), ns2.e("start")]
      }, [createVNode(DInput, {
        "ref": startInputRef,
        "modelValue": displayDateValue.value[0],
        "placeholder": placeholder.value[0] || t("startPlaceholder"),
        "onFocus": withModifiers((e) => {
          onFocus("start");
          focusHandler(e);
        }, ["stop"]),
        "size": pickerSize.value,
        "disabled": pickerDisabled.value
      }, {
        prefix: () => createVNode("span", {
          "class": ns2.e("range-picker-icon")
        }, [createVNode(IconCalendar, null, null)])
      })]), createVNode("span", {
        "class": ns2.e("separator")
      }, [props.separator]), createVNode("span", {
        "class": [isPanelShow.value && focusType.value === "end" ? ns2.e("active-input") : ns2.e("normal-input"), ns2.e("input"), ns2.e("end")]
      }, [createVNode(DInput, {
        "ref": endInputRef,
        "modelValue": displayDateValue.value[1],
        "placeholder": placeholder.value[1] || t("endPlaceholder"),
        "onFocus": withModifiers((e) => {
          onFocus("end");
          focusHandler(e);
        }, ["stop"]),
        "size": pickerSize.value,
        "disabled": pickerDisabled.value
      }, {
        suffix: () => createVNode("span", {
          "class": [showCloseIcon.value ? ns2.m("icon-visible") : ns2.m("icon-hidden"), "close-icon"],
          "onClick": handlerClearTime
        }, [createVNode(IconClose$2, null, null)])
      })])]), createVNode(Teleport, {
        "to": "body"
      }, {
        default: () => [createVNode(Transition, {
          "name": "fade"
        }, {
          default: () => [createVNode(FlexibleOverlay, {
            "modelValue": isPanelShow.value,
            "onUpdate:modelValue": ($event) => isPanelShow.value = $event,
            "ref": overlayRef,
            "origin": originRef.value,
            "align": "start",
            "position": position.value,
            "style": {
              zIndex: "var(--b-z-index-dropdown, 1052)"
            }
          }, {
            default: () => [createVNode(DatePickerProPanel, mergeProps(props, {
              "dateValue": dateValue.value,
              "visible": isPanelShow.value,
              "format": format2.value,
              "isRangeType": true,
              "focusType": focusType.value,
              "onSelectedDate": onSelectedDate,
              "onChangeRangeFocusType": onChangeRangeFocusType
            }), vSlots)]
          })]
        })]
      })]);
    };
  }
});
var DatePickerProInstall = {
  title: "DatePickerPro \u65E5\u671F\u9009\u62E9\u5668",
  category: "\u6570\u636E\u5F55\u5165",
  status: "50%",
  install(app) {
    app.component(DatePickerPro.name, DatePickerPro);
    app.component(DRangeDatePickerPro.name, DRangeDatePickerPro);
  }
};
const SHADOW_ID = "devui-dragdrop-placeholder-shadow";
function getElementStyle(id, styleName) {
  return document.getElementById(id).currentStyle ? document.getElementById(id).currentStyle[styleName] : window.getComputedStyle(document.getElementById(id), styleName);
}
function createShadow(originId) {
  const shadow = document.createElement("div");
  shadow.id = SHADOW_ID;
  shadow.style.background = "rgb(206, 215, 255)";
  shadow.style.width = getElementStyle(originId, "width");
  shadow.style.height = "20px";
  return shadow;
}
function changeDragState(el, originId, dragStart, drag, dragover, drop, shouldCreateShadow, dragFlag) {
  el.dataset.originId = originId;
  el.dataset.dragStart = dragStart;
  el.dataset.dragover = dragover;
  el.dataset.drop = drop;
  el.dataset.shouldCreateShadow = shouldCreateShadow;
  el.dataset.dragFlag = dragFlag;
}
function computeCompareElementHeight(compareElement) {
  return compareElement.getBoundingClientRect().top + Math.floor(compareElement.offsetHeight / 2);
}
function createInsertSortableShadow(sortDropArea, mouseObject, originId) {
  const sortDropAreaArr = [...sortDropArea.children];
  if (sortDropAreaArr.length === 0) {
    if (!document.getElementById(SHADOW_ID)) {
      const shadowElement = createShadow(originId);
      sortDropArea.appendChild(shadowElement);
    }
  } else {
    for (let index2 = 0; index2 < sortDropAreaArr.length; index2++) {
      const compareHeight = computeCompareElementHeight(sortDropAreaArr[index2]);
      document.getElementById(SHADOW_ID) ? sortDropArea.removeChild(document.getElementById(SHADOW_ID)) : null;
      if (Math.floor(mouseObject.clientY) <= Math.floor(compareHeight / 2) + sortDropAreaArr[index2].getBoundingClientRect().top) {
        sortDropArea.insertBefore(createShadow(originId), sortDropAreaArr[index2]);
        break;
      } else {
        index2 === sortDropAreaArr.length - 1 && sortDropArea.appendChild(createShadow(originId));
      }
    }
  }
}
function deleteInsertedSortableShadow(dropSortArea) {
  if (dropSortArea) {
    if (document.getElementById(SHADOW_ID)) {
      if (dropSortArea.contains(document.getElementById(SHADOW_ID))) {
        dropSortArea.removeChild(document.getElementById(SHADOW_ID));
      }
    }
  }
}
function judgeMouseIsInSortableArea(mouse, sortableArea) {
  const { clientX, clientY } = mouse;
  const eleLeft = sortableArea.getBoundingClientRect().left;
  const eleRight = sortableArea.getBoundingClientRect().right;
  const eleTop = sortableArea.getBoundingClientRect().top;
  const eleBottom = sortableArea.getBoundingClientRect().bottom;
  if (clientX > eleLeft && clientX < eleRight && clientY > eleTop && clientY < eleBottom) {
    return true;
  } else {
    return false;
  }
}
function sameOriginExchangeElementPosition(mouse, comparedArr, dragId, dropArea) {
  if (comparedArr.length <= 1) {
    return;
  }
  for (let index2 = 0; index2 < comparedArr.length; index2++) {
    if (mouse.clientY < comparedArr[index2].getBoundingClientRect().top) {
      dropArea.insertBefore(document.getElementById(dragId), comparedArr[index2]);
      break;
    }
    if (index2 === comparedArr.length - 1 && mouse.clientY > comparedArr[index2].getBoundingClientRect().bottom) {
      dropArea.appendChild(document.getElementById(dragId));
      break;
    }
  }
}
function exchangeShadowPosition(mouse, dropAreaElements, dragId, dropArea) {
  var _a, _b, _c;
  for (let index2 = 0; index2 < dropAreaElements.length; index2++) {
    if (((_a = dropAreaElements[index2]) == null ? void 0 : _a.id) !== SHADOW_ID) {
      if (Math.floor(mouse.clientY) <= dropAreaElements[index2].getBoundingClientRect().top) {
        if (((_b = dropAreaElements[index2 - 1]) == null ? void 0 : _b.id) !== SHADOW_ID) {
          if (document.getElementById(SHADOW_ID)) {
            dropArea.removeChild(document.getElementById(SHADOW_ID));
          }
          dropArea.insertBefore(createShadow(dragId), dropAreaElements[index2]);
          break;
        }
      }
      if (Math.floor(mouse.clientY) > dropAreaElements[dropAreaElements.length - 1].getBoundingClientRect().top) {
        if (index2 === dropAreaElements.length - 1 && ((_c = dropAreaElements[index2]) == null ? void 0 : _c.id) !== SHADOW_ID) {
          if (document.getElementById(SHADOW_ID)) {
            dropArea.removeChild(document.getElementById(SHADOW_ID));
          }
          dropArea.appendChild(createShadow(dragId));
        }
        break;
      }
    }
  }
}
var DraggableDirective = {
  mounted(el, binding) {
    el.setAttribute("draggable", "true");
    el.style.cursor = "grab";
    el.addEventListener("drag", () => {
      changeDragState(el, el.id, "true", "true", "false", "false", "false", "true");
      if (binding.instance.$root.dropElement && document.getElementById(SHADOW_ID)) {
        deleteInsertedSortableShadow(binding.instance.$root.dropElement);
        binding.instance.$root.dropElement = null;
      }
    }, false);
    el.addEventListener("dragstart", () => {
      changeDragState(el, el.id, "true", "true", "false", "false", "false", "false");
      binding.instance.$root.identity = el.id;
      el.dataset.dragArea = el.parentNode.className;
    }, false);
  }
};
var DroppableDirective = {
  mounted(el, binding) {
    el.addEventListener("dragover", (event) => {
      event.preventDefault();
      const dragId = binding.instance.$root.identity;
      changeDragState(document.getElementById(dragId), dragId, "true", "false", "true", "false", "false", "false");
      document.getElementById(dragId).dataset.dropArea = [...el.childNodes][1].className;
    }, false);
    el.addEventListener("drop", (event) => {
      event.preventDefault();
      const dragId = binding.instance.$root.identity;
      document.getElementById(dragId).dataset.parent = "not-sortable-drop-area";
      if (document.getElementById(dragId).dataset.dropArea === document.getElementById(dragId).dataset.dragArea) {
        return;
      }
      const childrenArr = [...Array.from(el.children)[1].children];
      if (childrenArr.length > 0) {
        for (let index2 = 0; index2 < childrenArr.length; index2++) {
          const childrenYRange = childrenArr[index2].getBoundingClientRect().top + childrenArr[index2].offsetHeight / 2;
          if (parseFloat(event.clientY) < parseFloat(childrenYRange)) {
            el.children[1].insertBefore(document.getElementById(dragId), childrenArr[index2]);
            break;
          }
          if (index2 === childrenArr.length - 1) {
            el.children[1].appendChild(document.getElementById(dragId));
          }
        }
      } else {
        el.childNodes[1].appendChild(document.getElementById(dragId));
      }
    });
  }
};
var SortableDirective = {
  mounted(el, binding) {
    const self2 = el;
    el.addEventListener("dragover", function(event) {
      var _a;
      event.preventDefault();
      const dragId = binding.instance.$root.identity;
      if (((_a = document.getElementById(dragId)) == null ? void 0 : _a.dataset.parent) === "sortable-drop-area") {
        return;
      }
      if (!document.getElementById(SHADOW_ID) && [...self2.childNodes[1].children].length === 0) {
        createInsertSortableShadow([...self2.childNodes][1], event, dragId);
      } else if ([...self2.childNodes[1].children].length >= 1) {
        exchangeShadowPosition(event, [...self2.childNodes[1].children], dragId, self2.childNodes[1]);
      }
    });
    el.addEventListener("drop", function(event) {
      var _a;
      const dropArea = [...el.childNodes][1];
      const dragId = binding.instance.$root.identity;
      if (((_a = document.getElementById(dragId)) == null ? void 0 : _a.dataset.parent) === "sortable-drop-area") {
        sameOriginExchangeElementPosition(event, [...dropArea.children], dragId, dropArea);
        return;
      }
      if (document.getElementById(SHADOW_ID)) {
        dropArea.replaceChild(document.getElementById(dragId), document.getElementById(SHADOW_ID));
        if (document.getElementById(dragId)) {
          document.getElementById(dragId).dataset.parent = "sortable-drop-area";
        }
      }
    });
    el.addEventListener("dragleave", function(event) {
      const dropArea = [...el.childNodes][1];
      if (document.getElementById(SHADOW_ID) && !judgeMouseIsInSortableArea(event, el)) {
        dropArea.removeChild(document.getElementById(SHADOW_ID));
      }
    });
  }
};
var DragdropInstall = {
  title: "Dragdrop \u62D6\u62FD",
  category: "\u901A\u7528",
  status: "10%",
  install(app) {
    app.directive("DDraggable", DraggableDirective);
    app.directive("DDroppable", DroppableDirective);
    app.directive("DSortable", SortableDirective);
  }
};
const drawerProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  zIndex: {
    type: Number,
    default: 1040
  },
  showOverlay: {
    type: Boolean,
    default: true
  },
  escKeyCloseable: {
    type: Boolean,
    default: true
  },
  position: {
    type: String,
    default: "right"
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  },
  beforeClose: {
    type: Function
  }
};
const drawerOverlayProps = {
  visible: {
    type: Boolean,
    default: false
  },
  onClick: {
    type: Function
  }
};
var drawerOverlay = "";
var DrawerOverlay = defineComponent({
  name: "DDrawerOverlay",
  props: drawerOverlayProps,
  emits: ["click"],
  setup(props, ctx2) {
    const ns2 = useNamespace("drawer");
    const handleClick = (e) => {
      ctx2.emit("click", e);
    };
    return () => createVNode(Transition, {
      "name": "drawer-overlay-fade"
    }, {
      default: () => [props.visible && createVNode("div", {
        "class": ns2.e("overlay"),
        "onClick": handleClick
      }, null)]
    });
  }
});
function useDrawer(props, emit) {
  const ns2 = useNamespace("drawer");
  const modalNs = useNamespace("modal", true);
  const drawerRef = ref();
  const overlayRef = ref();
  const drawerClasses = computed(() => ({
    [ns2.b()]: true,
    [ns2.m(props.position)]: true
  }));
  const close2 = () => {
    emit("update:modelValue", false);
    emit("close");
  };
  let lockScrollCb;
  const execClose = () => {
    props.beforeClose ? props.beforeClose(close2) : close2();
  };
  const handleOverlayClick = () => {
    props.closeOnClickOverlay && execClose();
  };
  const handleEscClose = (e) => {
    e.code === "Escape" && execClose();
  };
  const handleClickOutside = (e) => {
    const composedPath = e.composedPath();
    const modalOverlay = document.querySelectorAll(modalNs.e("overlay"));
    const modal2 = document.querySelectorAll(modalNs.b());
    const isClickModalOverlay = Array.from(modalOverlay).filter((item) => composedPath.includes(item));
    const isClickModal = Array.from(modal2).filter((item) => composedPath.includes(item));
    if (isClickModalOverlay.length || isClickModal.length) {
      return;
    }
    execClose();
  };
  setTimeout(() => {
    onClickOutside(drawerRef, handleClickOutside, { capture: false, ignore: [overlayRef] });
  });
  const removeBodyAdditions = () => {
    lockScrollCb == null ? void 0 : lockScrollCb();
    document.removeEventListener("keyup", handleEscClose);
  };
  watch(() => props.modelValue, (val) => {
    if (val) {
      emit("open");
      props.lockScroll && (lockScrollCb = lockScroll());
      props.escKeyCloseable && document.addEventListener("keyup", handleEscClose);
    } else {
      removeBodyAdditions();
    }
  });
  onUnmounted(removeBodyAdditions);
  return { overlayRef, drawerRef, drawerClasses, handleOverlayClick };
}
var drawer = "";
var Drawer = defineComponent({
  name: "DDrawer",
  inheritAttrs: false,
  props: drawerProps,
  emits: ["close", "update:modelValue", "open"],
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const {
      overlayRef,
      drawerRef,
      drawerClasses,
      handleOverlayClick
    } = useDrawer(props, emit);
    return () => createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [props.showOverlay && createVNode(DrawerOverlay, {
        "ref": overlayRef,
        "visible": props.modelValue,
        "style": {
          zIndex: props.zIndex - 1
        },
        "onClick": handleOverlayClick
      }, null), createVNode(Transition, {
        "name": `drawer-fly-${props.position}`
      }, {
        default: () => {
          var _a;
          return [props.modelValue && createVNode("div", mergeProps({
            "ref": drawerRef,
            "class": drawerClasses.value,
            "style": {
              zIndex: props.zIndex
            }
          }, attrs), [(_a = slots.default) == null ? void 0 : _a.call(slots)])];
        }
      })]
    });
  }
});
function _isSlot$8(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const defaultOptions$2 = {
  modelValue: false,
  content: "",
  zIndex: 1e3,
  showOverlay: true,
  escKeyCloseable: true,
  position: "right",
  lockScroll: true,
  closeOnClickOverlay: true
};
function initInstance$2(state) {
  const container = document.createElement("div");
  const content2 = state.content;
  delete state.content;
  const app = createApp({
    setup() {
      const handleVisibleChange = () => {
        state.modelValue = false;
      };
      onUnmounted(() => {
        document.body.removeChild(container);
      });
      return () => createVNode(Drawer, mergeProps(state, {
        "onUpdate:modelValue": handleVisibleChange
      }), _isSlot$8(content2) ? content2 : {
        default: () => [content2]
      });
    }
  });
  document.body.appendChild(container);
  app.mount(container);
  return app;
}
class DrawerService {
  open(options) {
    const state = reactive(__spreadValues(__spreadValues({}, defaultOptions$2), options));
    const app = initInstance$2(state);
    state.modelValue = true;
    return {
      close: () => {
        state.modelValue = false;
        app.unmount();
      }
    };
  }
}
var DrawerInstall = {
  title: "Drawer \u62BD\u5C49\u677F",
  category: "\u53CD\u9988",
  status: "75%",
  install(app) {
    app.component(Drawer.name, Drawer);
    app.config.globalProperties.$drawerService = new DrawerService();
  }
};
const dropdownMenuProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  origin: {
    type: Object,
    require: true
  },
  position: {
    type: Array,
    default: ["bottom"]
  },
  align: {
    type: String,
    default: null
  },
  offset: {
    type: [Number, Object],
    default: 4
  },
  clickOutside: {
    type: Function,
    default: () => true
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  overlayClass: {
    type: String,
    default: ""
  }
};
var DropdownMenu = defineComponent({
  name: "DDropdownMenu",
  inheritAttrs: false,
  props: dropdownMenuProps,
  emits: ["update:modelValue"],
  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const {
      modelValue,
      origin,
      position,
      align,
      offset: offset2,
      clickOutside,
      showAnimation,
      overlayClass
    } = toRefs(props);
    const dropdownMenuRef = ref(null);
    const ns2 = useNamespace("dropdown");
    onClickOutside(dropdownMenuRef, (value) => {
      var _a, _b;
      if (((_a = clickOutside.value) == null ? void 0 : _a.call(clickOutside)) && !((_b = origin == null ? void 0 : origin.value) == null ? void 0 : _b.contains(value.target))) {
        emit("update:modelValue", false);
      }
    });
    const currentPosition = ref("bottom");
    const handlePositionChange = (pos) => {
      currentPosition.value = pos.split("-")[0] === "top" ? "top" : "bottom";
    };
    const styles = computed(() => ({
      transformOrigin: currentPosition.value === "top" ? "0% 100%" : "0% 0%"
    }));
    return () => createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode(Transition, {
        "name": showAnimation.value ? ns2.m(`fade-${currentPosition.value}`) : ""
      }, {
        default: () => [createVNode(FlexibleOverlay, {
          "modelValue": modelValue.value,
          "onUpdate:modelValue": ($event) => modelValue.value = $event,
          "origin": origin == null ? void 0 : origin.value,
          "position": position.value,
          "align": align.value,
          "offset": offset2.value,
          "onPositionChange": handlePositionChange,
          "class": overlayClass.value,
          "style": styles.value
        }, {
          default: () => {
            var _a;
            return [createVNode("div", mergeProps({
              "ref": dropdownMenuRef,
              "class": ns2.e("menu-wrap")
            }, attrs), [(_a = slots.default) == null ? void 0 : _a.call(slots)])];
          }
        })]
      })]
    });
  }
});
var DropdownInstall = {
  title: "Dropdown \u4E0B\u62C9\u83DC\u5355",
  category: "\u5BFC\u822A",
  status: "50%",
  install(app) {
    app.component(Dropdown$1.name, Dropdown$1);
    app.component(DropdownMenu.name, DropdownMenu);
  }
};
const editableSelectProps = {
  modelValue: {
    type: [String, Number]
  },
  appendToBody: {
    type: Boolean,
    default: false
  },
  position: {
    type: Array,
    default: ["bottom"]
  },
  options: {
    type: Array,
    default: () => []
  },
  width: {
    type: Number
  },
  maxHeight: {
    type: Number
  },
  size: {
    type: String
  },
  placeholder: {
    type: String,
    default: "Select"
  },
  loading: {
    type: Boolean,
    default: false
  },
  allowClear: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  disabledKey: {
    type: String,
    default: ""
  },
  remote: {
    type: Boolean,
    default: false
  },
  filterMethod: {
    type: Function
  },
  remoteMethod: {
    type: Function
  },
  enableLazyLoad: {
    type: Boolean,
    default: false
  }
};
const SELECT_KEY = Symbol("EditableSelect");
const dropdownProps = {
  options: {
    type: Array,
    default: () => []
  },
  width: {
    type: Number
  },
  maxHeight: {
    type: Number
  }
};
const editableSelectOptionProps = {
  label: {
    type: String
  },
  value: {
    type: [String, Number]
  },
  disabled: {
    type: Boolean,
    default: false
  },
  hovering: {
    type: Boolean,
    default: false
  }
};
function useOption$1(props) {
  const ns2 = useNamespace("editable-select");
  const select2 = inject(SELECT_KEY);
  const { disabled, hovering } = toRefs(props);
  const isSelected = computed(() => {
    var _a;
    return ((_a = select2 == null ? void 0 : select2.modelValue) == null ? void 0 : _a.value) === props.value;
  });
  const optionClasses = computed(() => ({
    [ns2.e("item")]: true,
    [ns2.em("item", "selected")]: isSelected.value,
    [ns2.em("item", "disabled")]: disabled.value,
    [ns2.em("item", "hover")]: hovering.value,
    [ns2.em("item", "no-data-tip")]: !(props.label || props.value)
  }));
  return { optionClasses };
}
var Option$1 = defineComponent({
  name: "DEditableSelectOption",
  props: editableSelectOptionProps,
  emits: ["select"],
  setup(props, ctx2) {
    const {
      optionClasses
    } = useOption$1(props);
    const currentLabel = computed(() => props.label || props.value);
    const handleClick = () => {
      if (!props.disabled) {
        ctx2.emit("select");
      }
    };
    return () => {
      return createVNode("li", {
        "class": optionClasses.value,
        "onClick": handleClick
      }, [ctx2.slots.default ? ctx2.slots.default() : currentLabel.value]);
    };
  }
});
var Dropdown = defineComponent({
  name: "DEditableSelectDropdown",
  directives: {
    Loading: LoadingDirective
  },
  props: dropdownProps,
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("editable-select");
    const {
      width,
      maxHeight
    } = toRefs(props);
    const select2 = inject(SELECT_KEY);
    const {
      dropdownRef,
      hoveringIndex,
      handleOptionSelect,
      loadMore,
      emptyText
    } = select2;
    const isHovering = (index2) => {
      return hoveringIndex.value === index2;
    };
    const isDisabled = (option2) => {
      return select2.disabledKey ? !!option2[select2.disabledKey] : false;
    };
    const debounceLoadMore = lodash.exports.debounce(loadMore, 300);
    const onScroll2 = () => {
      debounceLoadMore();
    };
    const renderOption = () => {
      if (props.options.length === 0) {
        return createVNode("li", {
          "class": ns2.em("item", "no-data-tip")
        }, [slots.noResultItem ? slots.noResultItem() : emptyText.value]);
      }
      return props.options.map((option2, index2) => {
        return createVNode(Option$1, {
          "label": option2.label,
          "value": option2.value,
          "hovering": isHovering(index2),
          "disabled": isDisabled(option2),
          "onSelect": () => {
            handleOptionSelect(option2, true);
          }
        }, slots.item ? {
          default: () => renderSlot(useSlots(), "item", {
            option: option2,
            index: index2
          })
        } : {});
      });
    };
    return () => {
      return withDirectives(createVNode("div", {
        "class": ns2.e("dropdown"),
        "style": {
          width: `${width == null ? void 0 : width.value}px`
        }
      }, [createVNode("div", {
        "ref": dropdownRef,
        "class": ns2.e("inner"),
        "style": {
          maxHeight: `${maxHeight == null ? void 0 : maxHeight.value}px`
        },
        "onScroll": onScroll2
      }, [renderOption()])]), [[resolveDirective("loading"), select2.loading.value]]);
    };
  }
});
function useSelectStates() {
  return reactive({
    hoveringIndex: -1,
    selectedIndex: -1,
    query: "",
    inputValue: "",
    selectedLabel: "",
    isFocus: false,
    visible: false,
    softFocus: false,
    isSilentBlur: false,
    inputHovering: false
  });
}
function useSelect$3(dropdownRef, props, states, setSoftFocus, ctx2) {
  const app = getCurrentInstance();
  const t = createI18nTranslate("DEditableSelect", app);
  const cachedOptions = ref(props.options);
  const filteredOptions = computed(() => {
    return cachedOptions.value.filter((option2) => {
      return option2.label.toLocaleLowerCase().includes(states.query.toLocaleLowerCase().trim());
    });
  });
  const emptyText = computed(() => {
    let text = "";
    props.remote ? text = t("noData") : text = t("noRelatedRecords");
    return text;
  });
  const showClearable = computed(() => {
    const hasModelValue = !lodash.exports.isNil(props.modelValue) && props.modelValue !== "";
    return props.allowClear && !props.disabled && states.inputHovering && hasModelValue;
  });
  const toggleMenu = () => {
    if (!props.disabled) {
      states.visible = !states.visible;
    }
  };
  const updateIndex = (index2) => {
    states.hoveringIndex = index2;
    states.selectedIndex = index2;
  };
  const setSelected = () => {
    const options = cachedOptions.value;
    if (!lodash.exports.isNil(props.modelValue)) {
      const index2 = options.findIndex((option2) => option2.value === props.modelValue);
      if (index2 !== -1) {
        states.inputValue = options[index2].label;
        states.selectedLabel = options[index2].label;
        updateIndex(index2);
      } else {
        states.inputValue = `${props.modelValue}`;
        states.selectedLabel = `${props.modelValue}`;
      }
    } else {
      states.inputValue = "";
    }
  };
  const handleOptionSelect = (option2, byClick) => {
    ctx2.emit("update:modelValue", option2.value);
    ctx2.emit("change", option2.value);
    states.isSilentBlur = byClick;
    setSoftFocus();
    states.visible = false;
  };
  const scrollToItem = (idx) => {
    const ul = dropdownRef.value;
    const li = ul.children[idx];
    nextTick(() => {
      if (li.scrollIntoViewIfNeeded) {
        li.scrollIntoViewIfNeeded(false);
      } else {
        const containerInfo = ul.getBoundingClientRect();
        const elementInfo = li.getBoundingClientRect();
        if (elementInfo.bottom > containerInfo.bottom || elementInfo.top < containerInfo.top) {
          li.scrollIntoView(false);
        }
      }
    });
  };
  watch(() => states.visible, (visible) => {
    if (visible) {
      states.selectedIndex !== -1 && nextTick(() => {
        scrollToItem(states.selectedIndex);
      });
    } else {
      states.query = "";
      states.inputValue = states.selectedLabel;
    }
    ctx2.emit("visibleChange", visible);
  });
  watch(() => props.modelValue, () => {
    setSelected();
  });
  watch(() => props.options, (newOptions) => {
    if (newOptions.length !== 0) {
      cachedOptions.value = newOptions;
    }
  });
  onMounted(() => {
    setSelected();
  });
  return {
    cachedOptions,
    filteredOptions,
    emptyText,
    showClearable,
    toggleMenu,
    handleOptionSelect,
    scrollToItem
  };
}
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  up: "ArrowUp",
  down: "ArrowDown",
  esc: "Escape"
};
function useKeyboardSelect(props, states, filteredOptions, scrollToItem, handleOptionSelect) {
  const updateHoveringIndex = (index2) => {
    states.hoveringIndex = index2;
  };
  const onKeyboardNavigate = (direction, hoverIndex = states.hoveringIndex) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (filteredOptions.value.length === 0 || props.loading) {
      return;
    }
    let newIndex = 0;
    if (direction === "ArrowDown") {
      newIndex = hoverIndex + 1;
      if (newIndex > filteredOptions.value.length - 1) {
        newIndex = 0;
      }
    } else if (direction === "ArrowUp") {
      newIndex = hoverIndex - 1;
      if (newIndex < 0) {
        newIndex = filteredOptions.value.length - 1;
      }
    }
    const option2 = filteredOptions.value[newIndex];
    if (option2[props.disabledKey]) {
      return onKeyboardNavigate(direction, newIndex);
    } else {
      updateHoveringIndex(newIndex);
      scrollToItem(newIndex);
    }
  };
  const onEscOrTab = () => {
    states.visible = false;
  };
  const onKeyboardSelect = () => {
    if (!states.visible) {
      return states.visible = true;
    }
    const option2 = filteredOptions.value[states.hoveringIndex];
    if (option2) {
      handleOptionSelect(option2, false);
    }
  };
  const onKeydown = (e) => {
    const keyCode = e.key || e.code;
    const { tab: tab2, esc, down, up, enter } = EVENT_CODE;
    if (keyCode === up || keyCode === down) {
      e.preventDefault();
    }
    switch (keyCode) {
      case up:
        onKeyboardNavigate("ArrowUp");
        break;
      case down:
        onKeyboardNavigate("ArrowDown");
        break;
      case esc:
      case tab2:
        onEscOrTab();
        break;
      case enter:
        onKeyboardSelect();
        break;
    }
  };
  return {
    onKeydown
  };
}
function useInputRender(props, states) {
  const ns2 = useNamespace("editable-select-input");
  const inputClasses = computed(() => ({
    [ns2.b()]: true,
    [ns2.m("sm")]: props.size === "sm",
    [ns2.m("lg")]: props.size === "lg",
    [ns2.m("open")]: states.visible
  }));
  const inputWrapperClasses = computed(() => ({
    [ns2.e("wrapper")]: true,
    [ns2.em("wrapper", "focus")]: states.isFocus,
    [ns2.em("wrapper", "disabled")]: props.disabled
  }));
  const inputInnerClasses = computed(() => ({
    [ns2.e("inner")]: true
  }));
  const inputPlaceholderClasses = computed(() => ({
    [ns2.e("placeholder")]: true
  }));
  const inputSuffixClasses = computed(() => ({
    [ns2.e("suffix")]: true
  }));
  return {
    inputClasses,
    inputWrapperClasses,
    inputInnerClasses,
    inputPlaceholderClasses,
    inputSuffixClasses
  };
}
function useInputEvent(inputRef, props, states, ctx2) {
  const delay = computed(() => props.remote ? 300 : 0);
  const setSoftFocus = () => {
    var _a;
    const _input = inputRef.value;
    if (_input) {
      (_a = _input.focus) == null ? void 0 : _a.call(_input);
    }
  };
  const handleFocus = (e) => {
    if (!states.softFocus) {
      ctx2.emit("focus", e);
      states.isFocus = true;
    } else {
      states.softFocus = false;
    }
  };
  const handleBlur = async (e) => {
    if (states.isSilentBlur) {
      states.isSilentBlur = false;
    } else {
      ctx2.emit("blur", e);
      states.isFocus = true;
    }
    states.softFocus = false;
  };
  const updateInputValue = (value) => {
    states.inputValue = value;
  };
  const handleQueryChange = (value) => {
    if (props.remote && lodash.exports.isFunction(props.remoteMethod)) {
      props.remoteMethod(value);
    } else if (lodash.exports.isFunction(props.filterMethod)) {
      props.filterMethod(value);
    }
  };
  const handleInputChange = () => {
    states.query = states.inputValue;
    handleQueryChange(states.query);
  };
  const debouncedOnInputChange = lodash.exports.debounce(handleInputChange, delay.value);
  const onInput = (e) => {
    const value = e.target.value;
    updateInputValue(value);
    if (states.inputValue.length > 0 && !states.visible) {
      states.visible = true;
    }
    if (props.remote) {
      debouncedOnInputChange();
    } else {
      handleInputChange();
    }
  };
  const onMouseenter = () => {
    states.inputHovering = true;
  };
  const onMouseleave = () => {
    states.inputHovering = false;
  };
  const handleClear = () => {
    ctx2.emit("update:modelValue", "");
    ctx2.emit("change", "");
    ctx2.emit("clear");
    states.hoveringIndex = -1;
    states.visible = false;
  };
  return {
    blur,
    setSoftFocus,
    handleFocus,
    handleBlur,
    handleClear,
    onInput,
    onMouseenter,
    onMouseleave
  };
}
function useLazyLoad$2(dropdownRef, props, ctx2) {
  const { enableLazyLoad } = toRefs(props);
  const loadMore = () => {
    if (!dropdownRef.value || !enableLazyLoad.value) {
      return;
    }
    if ((dropdownRef == null ? void 0 : dropdownRef.value.clientHeight) + dropdownRef.value.scrollTop >= dropdownRef.value.scrollHeight - 12) {
      ctx2.emit("loadMore");
    }
  };
  return { loadMore };
}
var editableSelect = "";
function _isSlot$7(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var EditableSelect = defineComponent({
  name: "DEditableSelect",
  props: editableSelectProps,
  emits: ["update:modelValue", "focus", "blur", "clear", "change", "visibleChange", "loadMore"],
  setup(props, ctx2) {
    const ns2 = useNamespace("editable-select");
    const inputRef = ref();
    const originRef = ref();
    const dropdownRef = ref();
    const overlayRef = ref();
    const states = useSelectStates();
    const {
      appendToBody,
      disabled,
      modelValue,
      position,
      placeholder
    } = toRefs(props);
    const {
      onInput,
      onMouseenter,
      onMouseleave,
      setSoftFocus,
      handleBlur,
      handleFocus,
      handleClear
    } = useInputEvent(inputRef, props, states, ctx2);
    const {
      filteredOptions,
      emptyText,
      showClearable,
      toggleMenu,
      handleOptionSelect,
      scrollToItem
    } = useSelect$3(dropdownRef, props, states, setSoftFocus, ctx2);
    const {
      onKeydown
    } = useKeyboardSelect(props, states, filteredOptions, scrollToItem, handleOptionSelect);
    const {
      loadMore
    } = useLazyLoad$2(dropdownRef, props, ctx2);
    provide(SELECT_KEY, {
      dropdownRef,
      disabledKey: props.disabledKey,
      modelValue,
      inputValue: toRef(states, "inputValue"),
      query: toRef(states, "query"),
      hoveringIndex: toRef(states, "hoveringIndex"),
      loading: toRef(props, "loading"),
      emptyText,
      loadMore,
      handleOptionSelect,
      setSoftFocus
    });
    onClickOutside(originRef, () => {
      states.visible = false;
      states.isFocus = false;
    }, {
      ignore: [overlayRef]
    });
    const {
      inputClasses,
      inputWrapperClasses,
      inputInnerClasses,
      inputSuffixClasses
    } = useInputRender(props, states);
    const renderBasicDropdown = () => {
      return createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => [createVNode(FlexibleOverlay, {
          "ref": overlayRef,
          "modelValue": states.visible,
          "onUpdate:modelValue": ($event) => states.visible = $event,
          "origin": originRef.value,
          "position": position.value,
          "style": {
            zIndex: "var(--b-z-index-dropdown, 1052)"
          }
        }, {
          default: () => [createVNode(Dropdown, {
            "options": filteredOptions.value,
            "width": props.width,
            "maxHeight": props.maxHeight
          }, ctx2.slots)]
        })]
      });
    };
    const renderDropdown = () => {
      if (appendToBody.value) {
        let _slot;
        return createVNode(Teleport, {
          "to": "body"
        }, _isSlot$7(_slot = renderBasicDropdown()) ? _slot : {
          default: () => [_slot]
        });
      } else {
        return renderBasicDropdown();
      }
    };
    return () => {
      return createVNode("div", {
        "ref": originRef,
        "class": ns2.b(),
        "style": {
          width: props.width + "px"
        },
        "onClick": toggleMenu
      }, [createVNode("div", {
        "class": inputClasses.value,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave
      }, [createVNode("div", {
        "class": inputWrapperClasses.value
      }, [createVNode("input", {
        "ref": inputRef,
        "class": inputInnerClasses.value,
        "disabled": disabled.value,
        "placeholder": placeholder.value,
        "value": states.inputValue,
        "type": "text",
        "onInput": onInput,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onKeydown": onKeydown
      }, null), createVNode("span", {
        "class": inputSuffixClasses.value
      }, [withDirectives(createVNode("span", {
        "class": ns2.e("clear-icon"),
        "onClick": withModifiers(handleClear, ["stop"])
      }, [createVNode(DIcon, {
        "name": "icon-remove"
      }, null)]), [[vShow, showClearable.value]]), withDirectives(createVNode("span", {
        "class": ns2.e("arrow-icon")
      }, [createVNode(DIcon, {
        "name": "select-arrow"
      }, null)]), [[vShow, !showClearable.value]])])])]), renderDropdown()]);
    };
  }
});
var EditableSelectInstall = {
  title: "EditableSelect \u53EF\u8F93\u5165\u4E0B\u62C9\u9009\u62E9\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(EditableSelect.name, EditableSelect);
  }
};
const fullscreenProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  mode: {
    type: String,
    default: "normal"
  },
  zIndex: {
    type: Number,
    default: 10
  }
};
const ESC_KEY_CODE = 27;
function useKeydown(props, ctx2) {
  const { modelValue } = toRefs(props);
  const handleKeydown = (event) => {
    if (event.keyCode === ESC_KEY_CODE && modelValue) {
      ctx2.emit("update:modelValue", false);
    }
  };
  onMounted(() => {
    document.addEventListener("keydown", handleKeydown);
  });
  onUnmounted(() => {
    document.removeEventListener("keydown", handleKeydown);
  });
}
const ns$e = useNamespace("fullscreen");
const launchNormalFullscreen = (targetElement, props) => {
  targetElement.classList.add(ns$e.b());
  if (props.zIndex) {
    targetElement.setAttribute("style", `z-index: ${props.zIndex}`);
  }
};
const exitNormalFullscreen = (targetElement) => {
  targetElement.classList.remove(ns$e.b());
  targetElement.style.zIndex = "";
};
const launchImmersiveFullScreen = async (docElement) => {
  let fullscreenLaunch = null;
  if (docElement.requestFullscreen) {
    fullscreenLaunch = docElement.requestFullscreen();
  } else if (docElement.mozRequestFullScreen) {
    fullscreenLaunch = docElement.mozRequestFullScreen();
  } else if (docElement.webkitRequestFullScreen) {
    fullscreenLaunch = Promise.resolve(docElement.webkitRequestFullScreen());
  } else if (docElement.msRequestFullscreen) {
    fullscreenLaunch = Promise.resolve(docElement.msRequestFullscreen());
  }
  return await (fullscreenLaunch == null ? void 0 : fullscreenLaunch.then(() => !!document.fullscreenElement));
};
const exitImmersiveFullScreen = async (doc) => {
  let fullscreenExit = null;
  if (doc.exitFullscreen) {
    fullscreenExit = doc.exitFullscreen();
  } else if (doc.mozCancelFullScreen) {
    fullscreenExit = doc.mozCancelFullScreen();
  } else if (doc.webkitCancelFullScreen) {
    fullscreenExit = Promise.resolve(doc.webkitCancelFullScreen());
  } else if (doc.msExitFullscreen) {
    fullscreenExit = Promise.resolve(doc.msExitFullscreen());
  }
  return await (fullscreenExit == null ? void 0 : fullscreenExit.then(() => !!document.fullscreenElement));
};
const addFullScreenStyle = () => {
  document.getElementsByTagName("html")[0].classList.add(ns$e.e("html"));
};
const removeFullScreenStyle = () => {
  document.getElementsByTagName("html")[0].classList.remove(ns$e.e("html"));
};
function useFullscreen(props, slotElement, ctx2) {
  const { modelValue, mode } = toRefs(props);
  let exitByKeydown = false;
  const handleNormalFullscreen = (isOpen) => {
    if (isOpen) {
      launchNormalFullscreen(slotElement.value, props);
      addFullScreenStyle();
    } else {
      exitNormalFullscreen(slotElement.value);
      removeFullScreenStyle();
    }
  };
  const handleImmersiveFullscreen = (isOpen) => {
    if (isOpen) {
      launchImmersiveFullScreen(slotElement.value);
    } else {
      if (!exitByKeydown) {
        exitImmersiveFullScreen(document);
      }
    }
  };
  watch(modelValue, (newVal) => {
    if (mode.value === "normal") {
      handleNormalFullscreen(newVal);
    }
    if (mode.value === "immersive") {
      handleImmersiveFullscreen(newVal);
    }
  });
  const handleFullscreenChange = () => {
    if (!document.fullscreenElement) {
      ctx2.emit("update:modelValue");
      exitByKeydown = true;
    } else {
      exitByKeydown = false;
    }
  };
  onMounted(() => {
    document.addEventListener("fullscreenchange", handleFullscreenChange);
  });
  onUnmounted(() => {
    document.removeEventListener("fullscreenchange", handleFullscreenChange);
  });
}
var fullscreen = "";
var Fullscreen = defineComponent({
  name: "DFullscreen",
  props: fullscreenProps,
  emits: ["update:modelValue"],
  setup(props, ctx2) {
    const slotElement = ref();
    useFullscreen(props, slotElement, ctx2);
    useKeydown(props, ctx2);
    return () => {
      const defaultSlot = renderSlot(useSlots(), "default");
      return createVNode("div", {
        "ref": slotElement
      }, [defaultSlot]);
    };
  }
});
var FullscreenInstall = {
  title: "Fullscreen \u5168\u5C4F",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.component(Fullscreen.name, Fullscreen);
  }
};
var ganttScale = "";
var GanttScaleUnit = /* @__PURE__ */ ((GanttScaleUnit2) => {
  GanttScaleUnit2["day"] = "day";
  GanttScaleUnit2["week"] = "week";
  GanttScaleUnit2["month"] = "month";
  return GanttScaleUnit2;
})(GanttScaleUnit || {});
const isSameDate = (date4, compareDate2) => {
  return date4.getFullYear() === compareDate2.getFullYear() && date4.getMonth() === compareDate2.getMonth() && date4.getDate() === compareDate2.getDate();
};
const useScaleData = (milestoneList) => {
  const SCALE_START_LABLE_OFFSET = 7;
  const generateDateInfo = (date4, index2) => {
    const dateInfo = {
      dayOfMonthLabel: "",
      dayOfWeekLabel: "",
      monthLabel: "",
      yearLabel: "",
      date: date4,
      monthStart: false,
      weekend: false,
      today: false,
      milestone: "",
      highlightStart: false,
      scaleStartVisable: true,
      index: index2
    };
    const dayOfMonth = date4.getDate();
    dateInfo.dayOfMonthLabel = dayOfMonth + "";
    if (dayOfMonth === 1) {
      dateInfo.monthStart = true;
    }
    const dayOfWeek = date4.getDay();
    dateInfo.dayOfWeekLabel = dayOfWeek + "";
    if (dayOfWeek === 6) {
      dateInfo.weekend = true;
    }
    const month = date4.getMonth() + 1;
    dateInfo.monthLabel = month + "";
    const year = date4.getFullYear();
    dateInfo.yearLabel = year + "";
    if (isSameDate(date4, new Date())) {
      dateInfo.today = true;
    }
    if (new Date(year, month - 1, dayOfMonth + SCALE_START_LABLE_OFFSET).getMonth() > month - 1) {
      dateInfo.scaleStartVisable = false;
    }
    if (milestoneList.value) {
      milestoneList.value.forEach((milestone) => {
        if (milestone.date) {
          if (isSameDate(milestone.date, dateInfo.date)) {
            dateInfo.milestone = milestone.lable;
          }
        }
      });
    }
    return dateInfo;
  };
  const getNextDay = (date4) => {
    const nextDayDate = date4.setDate(date4.getDate() + 1);
    return new Date(nextDayDate);
  };
  const generateScaleData = (startDate, endDate) => {
    const scaleData = [];
    let handleDate = startDate;
    let index2 = 0;
    while (!isSameDate(handleDate, endDate)) {
      const dateInfo = generateDateInfo(handleDate, index2);
      scaleData.push(dateInfo);
      handleDate = getNextDay(new Date(handleDate));
      index2++;
    }
    return scaleData;
  };
  return {
    generateScaleData
  };
};
const i18nText = {
  en: {
    today: "today",
    monthsOfYear: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    yearDisplay(year) {
      return `${year}`;
    },
    monthDisplay(strMonthIndex) {
      return this.monthsOfYear[Number(strMonthIndex) - 1];
    },
    yearAndMonthDisplay(year, strMonthIndex) {
      return this.yearDisplay(year) + this.monthDisplay(strMonthIndex);
    }
  },
  zh: {
    today: "\u4ECA\u5929",
    monthsOfYear: [
      "1\u6708",
      "2\u6708",
      "3\u6708",
      "4\u6708",
      "5\u6708",
      "6\u6708",
      "7\u6708",
      "8\u6708",
      "9\u6708",
      "10\u6708",
      "11\u6708",
      "12\u6708"
    ],
    yearDisplay(year) {
      return `${year}\u5E74`;
    },
    monthDisplay(strMonthIndex) {
      return this.monthsOfYear[Number(strMonthIndex) - 1];
    },
    yearAndMonthDisplay(year, strMonthIndex) {
      return this.yearDisplay(year) + this.monthDisplay(strMonthIndex);
    }
  }
};
var DGanttScale = defineComponent({
  name: "DGanttScale",
  props: {
    unit: {
      type: String,
      default: GanttScaleUnit.day
    },
    height: {
      type: Number
    },
    startDate: {
      type: Date
    },
    endDate: {
      type: Date
    },
    ganttScaleContainerOffsetLeft: {
      type: Number
    },
    milestoneList: {
      type: Array
    },
    scrollElement: {
      type: Object
    },
    ganttBarContainerElement: {
      type: Object
    }
  },
  emits: ["addMilestone"],
  setup(props, ctx2) {
    const {
      startDate,
      endDate,
      milestoneList,
      scrollElement,
      unit
    } = toRefs(props);
    const scaleData = ref([]);
    const viewSCaleData = ref([]);
    const scaleWidth = ref({
      day: 40,
      week: 30,
      month: 20
    });
    const highlight = ref(false);
    const highlightStartText = ref("");
    const highlightEndText = ref("");
    const {
      generateScaleData
    } = useScaleData(milestoneList);
    let viewScaleRange = [0, 0];
    const addMilestone = (info2) => {
      ctx2.emit("addMilestone", info2);
    };
    const getViewScaleData = () => {
      if (scrollElement.value) {
        const containerWidth = scrollElement.value.clientWidth;
        const scrollLeft = scrollElement.value.scrollLeft;
        const start = Math.floor(scrollLeft / scaleWidth.value[unit.value]);
        const offset2 = Math.ceil(containerWidth / scaleWidth.value[unit.value]);
        viewScaleRange = [start - 2, start + offset2 + 2];
        viewSCaleData.value = scaleData.value.filter((i) => {
          return i.index >= viewScaleRange[0] && i.index <= viewScaleRange[1];
        });
      }
    };
    onMounted(() => {
      if (startDate.value && endDate.value) {
        scaleData.value = generateScaleData(startDate.value, endDate.value);
        getViewScaleData();
      }
    });
    watch(() => props.scrollElement, () => {
      getViewScaleData();
      props.scrollElement.addEventListener("scroll", () => {
        getViewScaleData();
      });
    });
    return {
      viewSCaleData,
      scaleWidth,
      addMilestone,
      highlight,
      highlightStartText,
      highlightEndText
    };
  },
  render() {
    const {
      unit,
      viewSCaleData,
      scaleWidth,
      addMilestone,
      highlight,
      highlightStartText,
      highlightEndText,
      ganttBarContainerElement
    } = this;
    return createVNode("div", {
      "class": "devui-gantt-scale-wrapper"
    }, [viewSCaleData.map((data, index2) => withDirectives(createVNode("div", {
      "class": `devui-gantt-scale ${unit} ${data.today} ${data.milestone}`,
      "style": {
        left: `${scaleWidth[unit] * data.index}px`,
        width: `${scaleWidth[unit]}px`
      }
    }, [createVNode("div", {
      "class": `devui-scale-start ${data.milestone}`
    }, [data.milestone && unit === "day" && createVNode("div", null, [data.milestone]), (!data.milestone || unit !== "day") && data.scaleStartVisable && (index2 === 0 || data.monthStart) ? unit === "month" ? i18nText.zh.yearDisplay(data.yearLabel) : i18nText.zh.yearAndMonthDisplay(data.yearLabel, data.monthLabel) : ""]), createVNode("div", {
      "class": "devui-scale-unit"
    }, [highlight && data.highlightStart && createVNode("div", {
      "class": "scale-highlight"
    }, [createVNode("div", {
      "style": "float: left"
    }, [highlightStartText]), createVNode("div", {
      "style": "float: right"
    }, [highlightEndText]), createVNode("div", {
      "style": "clear: both"
    }, null)]), (!highlight || !data.highlightStart) && unit === "day" && createVNode("div", {
      "class": `border-left ${data.today ? "today" : ""}`
    }, [data.today ? i18nText.zh.today : data.dayOfMonthLabel]), (!highlight || !data.highlightStart) && unit === "week" && createVNode("div", {
      "class": `${data.weekend || index2 === 0 ? "border-left" : ""}`
    }, [index2 === 0 || data.weekend ? data.dayOfMonthLabel : ""]), (!highlight || !data.highlightStart) && unit === "month" && createVNode("div", {
      "class": `${data.monthStart || index2 === 0 ? "border-left" : ""}`
    }, [index2 === 0 || data.monthStart ? i18nText.zh.monthDisplay(data.monthLabel) : ""])]), createVNode("div", {
      "class": `milestone-new ${unit}`,
      "title": "milestone",
      "onClick": () => addMilestone(data)
    }, [createVNode(resolveComponent("d-icon"), {
      "name": "add"
    }, null)])]), [[resolveDirective("gantt-marker"), {
      ganttBarContainerElement,
      monthMark: data.monthMark,
      weekend: data.weekend,
      milestone: data.milestone,
      today: data.today,
      date: data.date,
      unit,
      last: index2 === viewSCaleData.length - 1
    }]]))]);
  }
});
var ganttTools = "";
var GanttTools = defineComponent({
  name: "DGanttTools",
  props: {
    unit: {
      type: String,
      default: null
    },
    isFullScreen: {
      type: Boolean,
      default: false
    }
  },
  emits: ["goToday", "reduceUnit", "increaseUnit", "switchView"],
  setup(props, ctx2) {
    const currentUnitLabel = ref(props.unit);
    const views = ref([{
      name: "Day",
      value: "day"
    }, {
      name: "Week",
      value: "week"
    }, {
      name: "Month",
      value: "month"
    }]);
    const actionHandle = (type4) => {
      switch (type4) {
        case "today":
          ctx2.emit("goToday");
          break;
        case "reduce":
          ctx2.emit("reduceUnit");
          break;
        case "increase":
          ctx2.emit("increaseUnit");
          break;
      }
    };
    const selectView = (selectItem) => {
      ctx2.emit("switchView", selectItem.value);
    };
    return {
      actionHandle,
      currentUnitLabel,
      views,
      selectView
    };
  },
  render() {
    const {
      isFullScreen,
      actionHandle,
      views,
      selectView,
      $slots
    } = this;
    return createVNode("div", {
      "class": "tools-container",
      "style": {
        position: isFullScreen ? "fixed" : "absolute"
      }
    }, [createVNode(resolveComponent("d-button"), {
      "variant": "common",
      "onClick": () => actionHandle("today"),
      "class": "tool"
    }, {
      default: () => [createTextVNode("Today")]
    }), createVNode("div", {
      "class": "tool"
    }, [createVNode(resolveComponent("d-select"), {
      "modelValue": this.currentUnitLabel,
      "onUpdate:modelValue": ($event) => this.currentUnitLabel = $event,
      "options": views,
      "onValueChange": selectView
    }, null)]), createVNode(resolveComponent("d-button"), {
      "variant": "common",
      "class": ["tool", "minus", this.currentUnitLabel === GanttScaleUnit.day ? "disabled" : ""],
      "disabled": this.currentUnitLabel === GanttScaleUnit.day,
      "onClick": () => actionHandle("reduce")
    }, {
      default: () => [createVNode(resolveComponent("d-icon"), {
        "name": "minus"
      }, null)]
    }), createVNode(resolveComponent("d-button"), {
      "variant": "common",
      "class": ["tool", "add", this.currentUnitLabel === GanttScaleUnit.month ? "disabled" : ""],
      "disabled": this.currentUnitLabel === GanttScaleUnit.month,
      "onClick": () => actionHandle("increase")
    }, {
      default: () => [createVNode(resolveComponent("d-icon"), {
        "name": "add"
      }, null)]
    }), $slots.default && $slots.default()]);
  }
});
const ganttProps = {
  startDate: {
    type: Date
  },
  endDate: {
    type: Date
  },
  unit: {
    type: String,
    default: GanttScaleUnit.day
  },
  progressRate: {
    type: Number
  }
};
var gantt = "";
const useGantt = (scaleUnit = GanttScaleUnit.day) => {
  const DAY_DURATION2 = 24 * 60 * 60 * 1e3;
  const getScaleUnitPixel = () => {
    switch (scaleUnit) {
      case GanttScaleUnit.day:
        return 40;
      case GanttScaleUnit.week:
        return 30;
      case GanttScaleUnit.month:
        return 20;
    }
  };
  const getDuration = (startDate, endDate) => {
    if (startDate && endDate) {
      const timeOffset = endDate.getTime() - startDate.getTime();
      const duration = timeOffset / DAY_DURATION2 + 1;
      return Math.round(duration);
    }
  };
  const getDurationWidth = (startDate, endDate) => {
    if (startDate && endDate) {
      const duration = getDuration(startDate, endDate);
      return duration * getScaleUnitPixel();
    }
  };
  return {
    getDurationWidth
  };
};
var Gantt = defineComponent({
  name: "DGantt",
  components: {
    DGanttScale,
    DGanttTools: GanttTools
  },
  props: ganttProps,
  setup(props, ctx2) {
    const {
      startDate,
      endDate
    } = toRefs(props);
    const ganttContainer = ref();
    const ganttScaleWidth = ref();
    const {
      getDurationWidth
    } = useGantt();
    onMounted(() => {
      ganttScaleWidth.value = getDurationWidth(startDate.value, endDate.value);
    });
    return {
      ganttContainer,
      ganttScaleWidth
    };
  },
  render() {
    const {
      $slots,
      startDate,
      endDate,
      unit,
      ganttContainer,
      ganttScaleWidth
    } = this;
    return createVNode("div", {
      "style": {
        position: "relative"
      }
    }, [createVNode("div", {
      "class": "devui-gantt gantt-container",
      "ref": "ganttContainer"
    }, [createVNode("div", {
      "class": "header",
      "style": {
        width: `${ganttScaleWidth}px`
      }
    }, [createVNode(resolveComponent("d-gantt-scale"), {
      "startDate": startDate,
      "endDate": endDate,
      "unit": unit,
      "scrollElement": ganttContainer
    }, null)]), createVNode(resolveComponent("d-gantt-tools"), {
      "unit": unit
    }, null), createVNode("div", {
      "class": "body",
      "style": {
        width: `${ganttScaleWidth}px`
      }
    }, null)])]);
  }
});
const ganttMarkerDirective = {
  ganttBarContainerElement: null,
  monthMarkElement: null,
  weekendElement: null,
  todayElement: null,
  milestoneElement: null,
  monthMark: "",
  mounted(el, binding) {
    const { ganttBarContainerElement, monthMark } = binding.value;
    if (ganttBarContainerElement) {
      this.ganttBarContainerElement = ganttBarContainerElement;
    }
    if (monthMark) {
      this.monthMark = this.monthMark;
    }
  },
  updated(el, binding) {
    const { monthMark, weekend, today, milestone, unit } = binding.value;
    if (monthMark) {
      this.initMarkElement();
    }
  },
  initMarkElement() {
    if (this.ganttBarContainerElement) {
      if (this.monthMark && !this.monthMarkElement)
        ;
    }
  }
};
Gantt.install = function(app) {
  app.component(Gantt.name, Gantt);
  app.component(GanttTools.name, GanttTools);
  app.directive("gantt-marker", ganttMarkerDirective);
};
var GanttInstall = {
  title: "Gantt \u7518\u7279\u56FE",
  category: "\u6570\u636E\u5C55\u793A",
  status: "10%",
  install(app) {
    app.use(Gantt);
  }
};
const rowProps = {
  align: {
    type: String,
    default: "top"
  },
  gutter: {
    type: [Number, Object, Array],
    default: 0
  },
  justify: {
    type: String,
    default: "start"
  },
  wrap: {
    type: Boolean,
    default: false
  }
};
const numberProp = Number;
const colPropsBaseStyle = {
  flex: [String, Number],
  order: numberProp
};
const colPropsBaseClass = {
  offset: numberProp,
  pull: numberProp,
  push: numberProp,
  span: numberProp
};
const screenSizesProp = [Number, Object];
const screenSizes = {
  xs: screenSizesProp,
  sm: screenSizesProp,
  md: screenSizesProp,
  lg: screenSizesProp,
  xl: screenSizesProp,
  xxl: screenSizesProp
};
const colProps = __spreadValues(__spreadValues(__spreadValues({}, colPropsBaseStyle), colPropsBaseClass), screenSizes);
const RESULT_SCREEN = ["xxl", "xl", "lg", "md", "sm", "xs"];
const screenMedias = {
  xs: "screen and (max-width: 575px)",
  sm: "screen and (min-width: 576px)",
  md: "screen and (min-width: 768px)",
  lg: "screen and (min-width: 992px)",
  xl: "screen and (min-width: 1200px)",
  xxl: "screen and (min-width: 1600px)"
};
const subscribers = /* @__PURE__ */ new Map();
let subUid = -1;
const screen = {};
const results = {};
function dispatch() {
  subscribers.forEach((value) => {
    value(__spreadValues({}, screen));
  });
}
function register2() {
  Object.keys(screenMedias).forEach((key) => {
    const result2 = window.matchMedia(screenMedias[key]);
    if (result2.matches) {
      screen[key] = true;
      dispatch();
    }
    const listener = (e) => {
      screen[key] = e.matches;
      dispatch();
    };
    result2.addEventListener("change", listener);
    results[key] = {
      res: result2,
      listener
    };
  });
}
function responesScreen(func) {
  if (!subscribers.size) {
    register2();
  }
  subUid += 1;
  subscribers.set(subUid, func);
  func(__spreadValues({}, screen));
  return subUid;
}
function unRegister() {
  Object.keys(screenMedias).forEach((key) => {
    const handler = results[key];
    handler.res.removeEventListener("change", handler.listener);
  });
  subscribers.clear();
}
function removeSubscribeCb(id) {
  subscribers.delete(id);
  if (subscribers.size === 0) {
    unRegister();
  }
}
var row = "";
var Row = defineComponent({
  name: "DRow",
  props: rowProps,
  emits: [],
  setup(props, {
    slots
  }) {
    const gutterScreenSize = ref({});
    const ns2 = useNamespace("row");
    const rowClass = computed(() => ({
      [ns2.em("align", props.align)]: true,
      [ns2.em("justify", props.justify)]: true,
      [ns2.e("wrap")]: props.wrap
    }));
    let token;
    onMounted(() => {
      token = responesScreen((screen2) => {
        gutterScreenSize.value = screen2;
      });
    });
    onUnmounted(() => {
      removeSubscribeCb(token);
    });
    const gutterStyle = computed(() => {
      if (!props.gutter) {
        return {};
      }
      let currentGutter = [0, 0];
      if (Array.isArray(props.gutter)) {
        currentGutter = props.gutter;
      } else if (typeof props.gutter === "number") {
        currentGutter = [props.gutter, 0];
      } else {
        RESULT_SCREEN.some((size) => {
          const gzs = props.gutter[size];
          if (gutterScreenSize.value[size] && gzs) {
            if (typeof gzs === "number") {
              currentGutter = [gzs, 0];
            } else {
              currentGutter = gzs;
            }
            return true;
          }
          return false;
        });
      }
      const paddingLeft = `${(currentGutter[0] || 0) / 2}px`;
      const paddingRight = `${(currentGutter[0] || 0) / 2}px`;
      const paddingTop = `${(currentGutter[1] || 0) / 2}px`;
      const paddingBottom = `${(currentGutter[1] || 0) / 2}px`;
      return {
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom
      };
    });
    provide("gutterStyle", gutterStyle);
    return () => {
      var _a;
      return createVNode("div", {
        "class": [ns2.b(), rowClass.value]
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
const colNs = useNamespace("col");
function useColClassNames(props) {
  return computed(() => ({
    [colNs.em("span", props.span ? String(props.span) : "")]: true,
    [colNs.em("offset", props.offset ? String(props.offset) : "")]: true,
    [colNs.em("pull", props.pull ? String(props.pull) : "")]: true,
    [colNs.em("push", props.push ? String(props.push) : "")]: true
  }));
}
function setSpace(val) {
  return ` ${val.trim()}${val && " "}`;
}
function useSize(colSizes) {
  const keys2 = Object.keys(colSizes).filter((key) => key in screenSizes);
  return computed(() => {
    return keys2.reduce((total, key) => {
      const valueType = typeof colSizes[key];
      if (valueType === "number") {
        total = `${setSpace(total)}${colNs.em(key, `span-${colSizes[key]}`)}`;
      } else if (valueType === "object") {
        const colSizesKeys = Object.keys(colSizes[key]);
        const sum = colSizesKeys.filter((item) => item in colPropsBaseClass).reduce((tot, k) => {
          const baseClass = colSizes[key];
          const _class = baseClass[k];
          if (typeof _class !== "number") {
            return "";
          } else {
            tot = `${setSpace(tot)}${colNs.em(key, `${k}-${_class}`)}`;
          }
          return tot;
        }, "");
        total = `${setSpace(total)}${sum}`;
      }
      return total;
    }, "");
  });
}
var col = "";
var Col = defineComponent({
  name: "DCol",
  props: colProps,
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("col");
    const formatFlex = (flex) => {
      if (typeof flex === "number") {
        return `${flex} ${flex} auto`;
      }
      if (/^\d+(\.\d+)?(px|rem|em|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }
      return flex;
    };
    const colClassNames = useColClassNames(props);
    const sizeClassNames = useSize(props);
    const colStyle = computed(() => ({
      flex: formatFlex(props.flex),
      order: props.order
    }));
    const gutterStyle = inject("gutterStyle");
    return () => {
      var _a;
      return createVNode("div", {
        "class": [ns2.b(), colClassNames.value, sizeClassNames.value],
        "style": __spreadValues(__spreadValues({}, colStyle.value), gutterStyle == null ? void 0 : gutterStyle.value)
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var GridInstall = {
  title: "Grid \u6805\u683C",
  category: "\u5E03\u5C40",
  status: "100%",
  install(app) {
    app.component(Row.name, Row);
    app.component(Col.name, Col);
  }
};
const imagePreviewProps = {
  url: {
    type: String,
    default: "",
    required: true
  },
  previewUrlList: {
    type: Array,
    default: () => [],
    required: true
  },
  zIndex: {
    type: Number,
    required: false
  },
  backDropZIndex: {
    type: Number,
    required: false
  }
};
class Transform {
  constructor(el, options = {}) {
    __publicField(this, "el");
    __publicField(this, "oTransformX", 0);
    __publicField(this, "oTransformY", 0);
    __publicField(this, "transformX");
    __publicField(this, "transformY");
    __publicField(this, "zoom");
    __publicField(this, "rotate");
    __publicField(this, "STEP", 0.25);
    __publicField(this, "MIN_SCALE", 0.2);
    __publicField(this, "MAX_SCALE", 2.5);
    __publicField(this, "TRANSFORMX", 0);
    __publicField(this, "TRANSFORMY", 0);
    __publicField(this, "ZOOM", 1);
    __publicField(this, "ROTATE", 0);
    this.el = el;
    this.transformX = options.transformX || this.TRANSFORMX;
    this.transformY = options.transformY || this.TRANSFORMY;
    this.zoom = options.zoom || this.ZOOM;
    this.rotate = options.rotate || this.ROTATE;
    this.handleDefaultDraggable();
    this.onDraggable();
    this.onMouseWheel();
  }
  handleDefaultDraggable() {
    document.body.ondragstart = () => {
      window.event.returnValue = false;
      return false;
    };
  }
  onDraggable() {
    this.el.onmousedown = (e) => {
      const ox = e.clientX;
      const oy = e.clientY;
      document.onmousemove = (e1) => {
        const disX = e1.clientX - ox;
        const disY = e1.clientY - oy;
        this.transformX = this.oTransformX + disX;
        this.transformY = this.oTransformY + disY;
        this.el.style.cursor = "grabbing";
        this.setPosition();
      };
    };
    document.onmouseup = () => {
      document.onmousemove = null;
      this.oTransformX = this.transformX;
      this.oTransformY = this.transformY;
      this.el.style.cursor = "grab";
    };
  }
  onMouseWheel() {
    const handleWheel = this.throttle(this.setMouseWheel, 100);
    this.el.onmousewheel = (e) => {
      const value = -e.wheelDelta || e.deltaY || e.detail;
      handleWheel(value);
    };
  }
  throttle(fn, t) {
    let timer = null;
    return (...args) => {
      if (!timer) {
        setTimeout(() => {
          timer = null;
          fn.apply(this, args);
        }, t);
      }
    };
  }
  setMouseWheel(value) {
    if (value < 0) {
      if (this.zoom >= this.MAX_SCALE) {
        this.el.style.cursor = "not-allowed";
        return;
      }
      this.el.style.cursor = "zoom-in";
      this.setZoomIn(this.STEP);
    } else {
      if (this.zoom <= this.MIN_SCALE) {
        this.el.style.cursor = "not-allowed";
        return;
      }
      this.el.style.cursor = "zoom-out";
      this.setZoomOut(this.STEP);
    }
    this.setPosition();
  }
  setZoomIn(step2 = this.STEP) {
    this.zoom = Math.min(this.MAX_SCALE, this.zoom + step2);
    this.setPosition();
  }
  setZoomOut(step2 = this.STEP) {
    this.zoom = Math.max(this.MIN_SCALE, this.zoom - step2);
    this.setPosition();
  }
  setZoomBest() {
    this.reset();
    this.setPosition();
  }
  setZoomOriginal() {
    this.reset();
    this.setPosition();
  }
  setRotate() {
    this.rotate += 0.25;
    this.setPosition();
  }
  reset() {
    this.transformX = this.TRANSFORMX;
    this.transformY = this.TRANSFORMY;
    this.oTransformX = this.transformX;
    this.oTransformY = this.transformY;
    this.zoom = this.ZOOM;
  }
  setPosition() {
    this.el.style.transform = `translate(${this.transformX}px, ${this.transformY}px) scale(${this.zoom}) rotate(${this.rotate}turn)`;
  }
}
var imagePreview$1 = "";
var imagePreview = defineComponent({
  name: "DImagePreview",
  props: imagePreviewProps,
  emits: [],
  setup(props) {
    const ns2 = useNamespace("image-preview");
    let transform = null;
    const index2 = ref(0);
    const url2 = computed(() => props.previewUrlList[index2.value]);
    const imageStyle = props.zIndex ? {
      zIndex: props.zIndex
    } : {};
    const bgStyle = props.backDropZIndex ? {
      zIndex: props.backDropZIndex
    } : {};
    function initTransform() {
      const imageElement = document.querySelector(`.${ns2.e("main-image")}`);
      transform = new Transform(imageElement);
    }
    function initIndex() {
      index2.value = props.previewUrlList.findIndex((curUrl) => curUrl === props.url);
    }
    function onPrev() {
      index2.value = index2.value <= 0 ? props.previewUrlList.length - 1 : index2.value - 1;
    }
    function onNext() {
      index2.value = index2.value >= props.previewUrlList.length - 1 ? 0 : index2.value + 1;
    }
    function onClose() {
      ImagePreviewService.close();
    }
    function onZoomIn() {
      transform.setZoomIn();
    }
    function onZoomOut() {
      transform.setZoomOut();
    }
    function onRotate() {
      transform.setRotate();
    }
    function onZoomBest() {
      transform.setZoomBest();
    }
    function onZoomOriginal() {
      transform.setZoomOriginal();
    }
    function onKeyDown(event) {
      if (event.defaultPrevented) {
        return;
      }
      if (event.code === "Escape") {
        onClose();
      } else if (event.code === "ArrowLeft") {
        onPrev();
      } else if (event.code === "ArrowRight") {
        onNext();
      }
    }
    function initKeyboard() {
      document.addEventListener("keydown", onKeyDown, false);
    }
    function unKeyBoard() {
      document.removeEventListener("keydown", onKeyDown, false);
    }
    onMounted(() => {
      initIndex();
      initTransform();
      initKeyboard();
    });
    onUnmounted(() => {
      unKeyBoard();
    });
    return () => {
      return createVNode(Fragment, null, [createVNode("div", {
        "class": ns2.b(),
        "style": imageStyle
      }, [createVNode("img", {
        "class": ns2.e("main-image"),
        "src": url2.value
      }, null), createVNode("button", {
        "class": ns2.e("close-btn"),
        "onClick": onClose
      }, [createVNode("svg", {
        "width": "16px",
        "height": "16px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill": "#293040",
        "fill-rule": "nonzero",
        "points": "8 6.58578644 12.2426407 2.34314575 13.6568542 3.75735931 9.41421356 8                     13.6568542 12.2426407 12.2426407 13.6568542 8 9.41421356 3.75735931 13.6568542                      2.34314575 12.2426407 6.58578644 8 2.34314575 3.75735931 3.75735931 2.34314575"
      }, null)])])]), createVNode("button", {
        "class": ns2.e("arrow-left"),
        "onClick": onPrev
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill": "#293040",
        "fill-rule": "nonzero",
        "points": "10.7071068 12.2928932 9.29289322 13.7071068 3.58578644 8 9.29289322                     2.29289322 10.7071068 3.70710678 6.41421356 8"
      }, null)])])]), createVNode("button", {
        "class": ns2.e("arrow-right"),
        "onClick": onNext
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill": "#293040",
        "fill-rule": "nonzero",
        "transform": "translate(8.146447, 8.000000) scale(-1, 1) translate(-8.146447, -8.000000) ",
        "points": "11.7071068 12.2928932 10.2928932 13.7071068 4.58578644 8 10.2928932 2.29289322                     11.7071068 3.70710678 7.41421356 8"
      }, null)])])]), createVNode("div", {
        "class": ns2.e("toolbar")
      }, [createVNode("button", {
        "onClick": onZoomIn
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "fill": "#293040",
        "fill-rule": "nonzero"
      }, [createVNode("path", {
        "d": "M6,6 L6,4 L8,4 L8,6 L10,6 L10,8 L8,8 L8,10 L6,10 L6,8 L4,8 L4,6 L6,6 Z                       M12.6063847,11.1921711 L15.6568542,14.2426407 L14.2426407,15.6568542 L11.1921711,12.6063847                       C10.0235906,13.4815965 8.5723351,14 7,14 C3.13400675,14 0,10.8659932 0,7 C0,3.13400675                        3.13400675,0 7,0 C10.8659932,0 14,3.13400675 14,7 C14,8.5723351 13.4815965,10.0235906                         12.6063847,11.1921711 L12.6063847,11.1921711 Z M7,12 C9.76142375,12 12,9.76142375                          12,7 C12,4.23857625 9.76142375,2 7,2 C4.23857625,2 2,4.23857625 2,7 C2,9.76142375                           4.23857625,12 7,12 Z"
      }, null)])])])]), createVNode("button", {
        "onClick": onZoomOut
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "fill": "#293040",
        "fill-rule": "nonzero"
      }, [createVNode("path", {
        "d": "M12.6063847,11.1921711 L15.6568542,14.2426407 L14.2426407,15.6568542                       L11.1921711,12.6063847 C10.0235906,13.4815965 8.5723351,14 7,14 C3.13400675,14 0,10.8659932                        0,7 C0,3.13400675 3.13400675,0 7,0 C10.8659932,0 14,3.13400675 14,7 C14,8.5723351                         13.4815965,10.0235906 12.6063847,11.1921711 L12.6063847,11.1921711 Z M7,12 C9.76142375,12                          12,9.76142375 12,7 C12,4.23857625 9.76142375,2 7,2 C4.23857625,2 2,4.23857625 2,7 C2,9.76142375                           4.23857625,12 7,12 Z M4,6 L10,6 L10,8 L4,8 L4,6 Z"
      }, null)])])])]), createVNode("button", {
        "onClick": onRotate
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("path", {
        "d": "M7.5,3.02242151 L7.5,4 L4.5,2 L7.5,0 L7.5,1.01640228 C7.66526181,1.00552468                       7.83198572,1 8,1 C12.1421356,1 15.5,4.35786438 15.5,8.5 C15.5,12.6421356                        12.1421356,16 8,16 C3.85786438,16 0.5,12.6421356 0.5,8.5 C0.5,6.9828355                         0.950484514,5.5708873 1.72499011,4.39061882 L3.42173231,5.4510827 C2.83944149,6.32371289                          2.5,7.37221604 2.5,8.5 C2.5,11.5375661 4.96243388,14 8,14 C11.0375661,14 13.5,11.5375661                           13.5,8.5 C13.5,5.46243388 11.0375661,3 8,3 C7.83145515,3 7.66468102,3.00758131 7.5,3.02242151                            Z M8,11 C6.61928813,11 5.5,9.88071187 5.5,8.5 C5.5,7.11928813 6.61928813,6 8,6 C9.38071187,6                             10.5,7.11928813 10.5,8.5 C10.5,9.88071187 9.38071187,11 8,11 Z M8,10 C8.82842712,10 9.5,9.32842712                              9.5,8.5 C9.5,7.67157288 8.82842712,7 8,7 C7.17157288,7 6.5,7.67157288 6.5,8.5 C6.5,9.32842712                               7.17157288,10 8,10 Z",
        "fill": "#293040"
      }, null)])])]), createVNode("button", {
        "onClick": onPrev
      }, [createVNode("svg", {
        "width": "16px",
        "height": "16px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill": "#293040",
        "fill-rule": "nonzero",
        "points": "10.7071068 12.2928932 9.29289322 13.7071068 3.58578644 8 9.29289322 2.29289322                       10.7071068 3.70710678 6.41421356 8"
      }, null)])])]), createVNode("span", {
        "class": ns2.e("index")
      }, [index2.value + 1, createTextVNode(":"), props.previewUrlList.length]), createVNode("button", {
        "onClick": onNext
      }, [createVNode("svg", {
        "width": "16px",
        "height": "16px",
        "viewBox": "0 0 16 16",
        "version": "1.1"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("polygon", {
        "fill": "#293040",
        "fill-rule": "nonzero",
        "transform": "translate(8.146447, 8.000000) scale(-1, 1) translate(-8.146447, -8.000000) ",
        "points": "11.7071068 12.2928932 10.2928932 13.7071068 4.58578644 8 10.2928932 2.29289322                       11.7071068 3.70710678 7.41421356 8"
      }, null)])])]), createVNode("button", {
        "onClick": onZoomBest
      }, [createVNode("svg", {
        "width": "18px",
        "height": "18px",
        "viewBox": "0 0 16 16"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("path", {
        "d": "M16,16 L11.429,16 L11.429,15 L14.456,15 L11.006,11.226 L11.652,10.519 L15.086,14.275                       L15.086,11 L16,11 L16,16 Z M15.164,1.544 L12.009,4.994 L11.418,4.348 L14.558,0.914                        L11.82,0.914 L11.82,0 L16,0 L16,4.571 L15.164,4.571 L15.164,1.544 Z M5,15 L5,16                         L0,16 L0,11 L1,11 L1,14.275 L4.756,10.519 L5.463,11.226 L1.689,15 L5,15 Z M4.365,4.994                          L0.914,1.544 L0.914,4.571 L3.41060513e-13,4.571 L3.41060513e-13,0 L4.571,0 L4.571,0.914                           L1.578,0.914 L5.011,4.348 L4.365,4.994 Z",
        "fill": "#293040",
        "fill-rule": "nonzero"
      }, null)])])]), createVNode("button", {
        "onClick": onZoomOriginal
      }, [createVNode("span", null, [createTextVNode("1:1")])])])]), createVNode("div", {
        "class": ns2.e("bg"),
        "style": bgStyle
      }, null)]);
    };
  }
});
function createComponent(props) {
  return createApp(imagePreview, props);
}
class ImagePreviewService {
  static open(props) {
    this.$body = document.body;
    this.$div = document.createElement("div");
    this.$overflow = this.$body.style.overflow;
    this.$body.appendChild(this.$div);
    createComponent(props).mount(this.$div);
    this.$body.style.setProperty("overflow", "hidden", "important");
  }
  static close() {
    var _a, _b;
    (_a = this.$body) == null ? void 0 : _a.style.setProperty("overflow", this.$overflow);
    this.$overflow = null;
    this.$div && ((_b = this.$body) == null ? void 0 : _b.removeChild(this.$div));
    this.$body = null;
    this.$div = null;
  }
}
__publicField(ImagePreviewService, "$body", null);
__publicField(ImagePreviewService, "$div", null);
__publicField(ImagePreviewService, "$overflow", "");
function mountedPreviewImages(props) {
  ImagePreviewService.open({
    url: props.url,
    previewUrlList: props.previewUrlList,
    zIndex: props.zIndex,
    backDropZIndex: props.backDropZIndex
  });
}
function unmountedPreviewImages() {
  ImagePreviewService.close();
}
function getImgByEl(el) {
  const imgs = [...el.querySelectorAll("img")];
  const urlList = imgs.map((item) => {
    var _a;
    return (_a = item.getAttribute("preview-src") || item.getAttribute("src")) != null ? _a : "";
  });
  return urlList;
}
function handleImg(e) {
  var _a;
  e.stopPropagation();
  const el = e.currentTarget;
  const target = e.target;
  if (((_a = target == null ? void 0 : target.nodeName) == null ? void 0 : _a.toLowerCase()) === "img") {
    const urlList = getImgByEl(el);
    const url2 = target.getAttribute("src");
    if (!url2) {
      return console.error("attribute is not exist");
    }
    mountedPreviewImages({
      url: url2,
      previewUrlList: urlList,
      zIndex: el == null ? void 0 : el.zIndex,
      backDropZIndex: el == null ? void 0 : el.backDropZIndex
    });
  }
}
function handleImgByEl(el) {
  el.addEventListener("click", handleImg);
}
function removeHandle(el) {
  el.removeEventListener("click", handleImg);
}
var ImagePreviewDirective = {
  mounted(el, binding) {
    if (!(binding == null ? void 0 : binding.value)) {
      return handleImgByEl(el);
    }
    const { custom, disableDefault } = binding.value;
    if (custom instanceof Object) {
      custom.open = () => {
        const urlList = getImgByEl(el);
        mountedPreviewImages({
          url: urlList == null ? void 0 : urlList[0],
          previewUrlList: urlList,
          zIndex: el == null ? void 0 : el.zIndex,
          backDropZIndex: el == null ? void 0 : el.backDropZIndex
        });
      };
      custom.close = () => unmountedPreviewImages();
    }
    if (disableDefault) {
      return;
    }
    handleImgByEl(el);
  },
  unmounted() {
    unmountedPreviewImages();
  },
  updated(el, binding) {
    var _a, _b;
    el.zIndex = (_a = binding == null ? void 0 : binding.value) == null ? void 0 : _a.zIndex;
    el.backDropZIndex = (_b = binding == null ? void 0 : binding.value) == null ? void 0 : _b.backDropZIndex;
    if (binding == null ? void 0 : binding.value) {
      const {
        value: { disableDefault },
        oldValue: { disableDefault: oldDisableDefault }
      } = binding;
      if (disableDefault !== oldDisableDefault) {
        if (disableDefault) {
          removeHandle(el);
        } else {
          handleImgByEl(el);
        }
      }
    }
  }
};
var ImagePreviewInstall = {
  title: "ImagePreview \u56FE\u7247\u9884\u89C8",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.directive("d-image-preview", ImagePreviewDirective);
    app.config.globalProperties.$imagePreviewService = ImagePreviewService;
  }
};
var inputIcon = "";
const inputIconProps = __spreadProps(__spreadValues({}, inputProps), {
  name: {
    type: String,
    value: "calendar",
    required: false
  },
  onIconclick: {
    type: Function,
    required: false
  },
  iconBgColor: {
    type: String,
    value: "transparent"
  },
  iconColor: {
    type: String,
    value: "#000000"
  }
});
var InputIcon = defineComponent({
  name: "DInputIcon",
  props: inputIconProps,
  setup(props) {
    const _a = toRefs(props), {
      name,
      iconBgColor,
      iconColor
    } = _a, restProps = __objRest(_a, [
      "name",
      "iconBgColor",
      "iconColor"
    ]);
    const state = reactive({
      value: ""
    });
    const onInputChange = (v) => {
      state.value = v;
      typeof props.onChange === "function" && props.onChange(state.value);
    };
    const onIconClick = (e) => {
      typeof props.onIconclick === "function" && props.onIconclick(state.value, e);
    };
    return () => {
      return createVNode("div", {
        "class": "d-input-icon-container"
      }, [createVNode("label", null, [createVNode(DInput, mergeProps(restProps, {
        "onChange": onInputChange
      }), null)]), createVNode("span", {
        "onClick": onIconClick,
        "style": {
          backgroundColor: iconBgColor.value
        }
      }, [createVNode(DIcon, {
        "size": "small",
        "name": name.value,
        "color": iconColor.value
      }, null)])]);
    };
  }
});
var InputIconInstall = {
  title: "InputIcon\u8F93\u5165\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "75%",
  install(app) {
    app.component(InputIcon.name, InputIcon);
  }
};
const inputNumberProps = {
  placeholder: {
    type: String
  },
  disabled: {
    type: Boolean,
    default: false
  },
  step: {
    type: Number,
    default: 1
  },
  max: {
    type: Number,
    default: Infinity
  },
  min: {
    type: Number,
    default: -Infinity
  },
  size: {
    type: String
  },
  modelValue: {
    type: Number
  },
  precision: {
    type: Number
  },
  reg: {
    type: [RegExp, String],
    default: ""
  }
};
const ns$d = useNamespace("input-number");
function IncIcon() {
  return createVNode("svg", {
    "class": ns$d.e("icon-arrow"),
    "width": "1em",
    "height": "1em",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M12.1464466,6.85355339 L8.35355339,10.6464466 C8.15829124,10.8417088 7.84170876,10.8417088 7.64644661,10.6464466           L3.85355339,6.85355339 C3.65829124,6.65829124 3.65829124,6.34170876 3.85355339,6.14644661 C3.94732158,6.05267842           4.07449854,6 4.20710678,6 L11.7928932,6 C12.0690356,6 12.2928932,6.22385763 12.2928932,6.5 C12.2928932,6.63260824           12.2402148,6.7597852 12.1464466,6.85355339 Z",
    "fill-rule": "nonzero"
  }, null)])]);
}
function DecIcon() {
  return createVNode("svg", {
    "class": ns$d.e("icon-arrow"),
    "width": "1em",
    "height": "1em",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M12.1464466,6.85355339 L8.35355339,10.6464466 C8.15829124,10.8417088 7.84170876,10.8417088 7.64644661,10.6464466           L3.85355339,6.85355339 C3.65829124,6.65829124 3.65829124,6.34170876 3.85355339,6.14644661 C3.94732158,6.05267842           4.07449854,6 4.20710678,6 L11.7928932,6 C12.0690356,6 12.2928932,6.22385763 12.2928932,6.5 C12.2928932,6.63260824           12.2402148,6.7597852 12.1464466,6.85355339 Z",
    "fill-rule": "nonzero"
  }, null)])]);
}
const ns$c = useNamespace("input-number");
function useRender$1(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const _a = ctx2.attrs, { style, class: customClass } = _a, otherAttrs = __objRest(_a, ["style", "class"]);
  const customStyle = { style };
  const inputNumberSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "md");
  const wrapClass = computed(() => [
    {
      [ns$c.b()]: true,
      [ns$c.m(inputNumberSize.value)]: true
    },
    customClass
  ]);
  const controlButtonsClass = computed(() => ({
    [ns$c.e("control-buttons")]: true,
    disabled: props.disabled
  }));
  const inputWrapClass = computed(() => ({
    [ns$c.e("input-wrap")]: true
  }));
  const inputInnerClass = computed(() => ({
    [ns$c.e("input-box")]: true,
    disabled: props.disabled
  }));
  return { wrapClass, customStyle, otherAttrs, controlButtonsClass, inputWrapClass, inputInnerClass };
}
function useExpose(ctx2) {
  const inputRef = ref();
  const focus = () => {
    inputRef.value.focus();
  };
  const blur2 = () => {
    inputRef.value.blur();
  };
  const select2 = () => {
    inputRef.value.select();
  };
  ctx2.expose({ focus, blur: blur2, select: select2 });
  return { inputRef };
}
function getPrecision(pre) {
  let precision = 0;
  if (isUndefined(pre)) {
    return precision;
  }
  const preString = pre.toString();
  const dotIndex = preString.indexOf(".");
  if (dotIndex !== -1) {
    precision = preString.length - dotIndex - 1;
  }
  return precision;
}
function useEvent$1(props, ctx2, inputRef) {
  const { min, max, step: step2, disabled } = toRefs(props);
  const state = reactive({
    currentValue: props.modelValue || "",
    userInputValue: void 0
  });
  const numPrecision = computed(() => {
    if (!isUndefined(props.precision)) {
      return props.precision;
    } else {
      return Math.max(getPrecision(props.modelValue), getPrecision(step2.value));
    }
  });
  const inputVal = computed(() => {
    if (!isUndefined(state.userInputValue)) {
      return state.userInputValue;
    }
    let currentValue = state.currentValue;
    if (currentValue === "" || isUndefined(currentValue) || Number.isNaN(currentValue)) {
      return "";
    }
    if (isNumber(currentValue)) {
      currentValue = currentValue.toFixed(numPrecision.value);
    }
    return currentValue;
  });
  const toPrecision = (num) => {
    return Number.parseFloat(num.toFixed(numPrecision.value));
  };
  const computeByStep = (val, addOrNot = 1) => {
    if (!isNumber(val)) {
      return state.currentValue;
    }
    return toPrecision(val + step2.value * addOrNot);
  };
  const correctValue = (value) => {
    const valueStr = value + "";
    if (props.reg && !valueStr.match(new RegExp(props.reg))) {
      return void 0;
    }
    let newVal = Number(value);
    if (newVal !== 0 && (!Number(value) || Number.isNaN(newVal))) {
      return void 0;
    }
    if (!isUndefined(props.precision)) {
      newVal = toPrecision(newVal);
    }
    if (newVal > max.value || newVal < min.value) {
      newVal = newVal > max.value ? max.value : min.value;
    }
    return newVal;
  };
  const setCurrentValue = (value) => {
    const oldVal = state.currentValue;
    const newVal = correctValue(value);
    state.userInputValue = void 0;
    if (newVal !== 0 && !newVal) {
      ctx2.emit("update:modelValue", oldVal);
      return;
    }
    if (oldVal === newVal) {
      return;
    }
    ctx2.emit("update:modelValue", newVal);
    ctx2.emit("input", newVal);
    ctx2.emit("change", newVal, oldVal);
    state.currentValue = newVal;
  };
  const minDisabled = computed(() => isNumber(state.currentValue) && computeByStep(state.currentValue, -1) < props.min);
  const maxDisabled = computed(() => isNumber(state.currentValue) && computeByStep(state.currentValue) > props.max);
  const onAdd = () => {
    if (disabled.value || maxDisabled.value) {
      return;
    }
    inputRef.value.focus();
    const newVal = computeByStep(state.currentValue || 0);
    setCurrentValue(newVal);
  };
  const onSubtract = () => {
    if (disabled.value || minDisabled.value) {
      return;
    }
    inputRef.value.focus();
    const newVal = computeByStep(state.currentValue || 0, -1);
    setCurrentValue(newVal);
  };
  watch(() => props.modelValue, (val) => {
    state.currentValue = correctValue(val);
  }, { immediate: true });
  const onInput = (event) => {
    state.userInputValue = event.target.value;
  };
  const onChange = (event) => {
    setCurrentValue(event.target.value);
  };
  return { inputVal, minDisabled, maxDisabled, onAdd, onSubtract, onInput, onChange };
}
var inputNumber = "";
var InputNumber = defineComponent({
  name: "DInputNumber",
  props: inputNumberProps,
  emits: ["update:modelValue", "change", "input"],
  setup(props, ctx2) {
    const {
      disabled
    } = toRefs(props);
    const {
      wrapClass,
      customStyle,
      otherAttrs,
      controlButtonsClass,
      inputWrapClass,
      inputInnerClass
    } = useRender$1(props, ctx2);
    const {
      inputRef
    } = useExpose(ctx2);
    const {
      inputVal,
      minDisabled,
      maxDisabled,
      onAdd,
      onSubtract,
      onInput,
      onChange
    } = useEvent$1(props, ctx2, inputRef);
    return () => createVNode("div", mergeProps({
      "class": wrapClass.value
    }, customStyle), [createVNode("div", {
      "class": controlButtonsClass.value
    }, [createVNode("span", {
      "class": ["control-button control-inc", {
        disabled: maxDisabled.value
      }],
      "onClick": onAdd
    }, [createVNode(IncIcon, null, null)]), createVNode("span", {
      "class": ["control-button control-dec", {
        disabled: minDisabled.value
      }],
      "onClick": onSubtract
    }, [createVNode(DecIcon, null, null)])]), createVNode("div", {
      "class": inputWrapClass.value
    }, [createVNode("input", mergeProps({
      "ref": inputRef,
      "value": inputVal.value,
      "placeholder": props.placeholder,
      "disabled": disabled.value,
      "class": inputInnerClass.value
    }, otherAttrs, {
      "onInput": onInput,
      "onChange": onChange
    }), null)])]);
  }
});
var InputNumberInstall = {
  title: "InputNumber \u6570\u5B57\u8F93\u5165\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "50%",
  install(app) {
    app.component(InputNumber.name, InputNumber);
  }
};
var layout = "";
var Layout = defineComponent({
  name: "DLayout",
  emits: [],
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("layout");
    return () => {
      var _a;
      const slotDefault = (_a = slots.default) == null ? void 0 : _a.call(slots);
      const isAside = slotDefault.some((item) => item.type.name === "DAside");
      const classNames = `${isAside ? ns2.e("aside") : ""} ${ns2.b()}`;
      return createVNode("div", {
        "class": classNames
      }, [slotDefault]);
    };
  }
});
var content = "";
var Content = defineComponent({
  name: "DContent",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("layout");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("content")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var header$1 = "";
var Header$1 = defineComponent({
  name: "DHeader",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("layout");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("header")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var footer = "";
var Footer$1 = defineComponent({
  name: "DFooter",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("layout");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("footer")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var Aside = defineComponent({
  name: "DAside",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("layout");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.em("aside", "inner")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var LayoutInstall = {
  title: "Layout \u5E03\u5C40",
  category: "\u5E03\u5C40",
  status: "100%",
  install(app) {
    app.component(Layout.name, Layout);
    app.component(Content.name, Content);
    app.component(Header$1.name, Header$1);
    app.component(Footer$1.name, Footer$1);
    app.component(Aside.name, Aside);
  }
};
var list = "";
var List = defineComponent({
  name: "DList",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("list");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.b()
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var listItem = "";
var ListItem = defineComponent({
  name: "DListItem",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("list-item");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.b()
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var ListInstall = {
  title: "List \u5217\u8868",
  category: "\u6570\u636E\u5C55\u793A",
  status: "10%",
  install(app) {
    app.component(List.name, List);
    app.component(ListItem.name, ListItem);
  }
};
const loadingConstructor = defineComponent(Loading);
const cacheTarget = /* @__PURE__ */ new WeakMap();
const loading = {
  open(options = {}) {
    var _a, _b, _c;
    const parent = options.target || document.body;
    if (cacheTarget.has(parent)) {
      return cacheTarget.get(parent);
    }
    if (parent.style) {
      parent.style.position = options.positionType;
    }
    const isFull = document.body === parent;
    options = __spreadValues(__spreadValues({}, new LoadingOptions()), options);
    const instance = createComponent$1(loadingConstructor, __spreadProps(__spreadValues({}, options), {
      isFull
    }), options.loadingTemplateRef ? () => options.loadingTemplateRef : null);
    cacheTarget.set(parent, instance);
    (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.open();
    parent.appendChild((_b = instance == null ? void 0 : instance.proxy) == null ? void 0 : _b.$el);
    const close2 = (_c = instance == null ? void 0 : instance.proxy) == null ? void 0 : _c.close;
    if (instance) {
      instance.loadingInstance = instance == null ? void 0 : instance.proxy;
      if (instance.loadingInstance) {
        instance.loadingInstance.close = (...args) => {
          cacheTarget.delete(parent);
          close2 == null ? void 0 : close2(...args);
        };
      }
    }
    return instance;
  }
};
var LoadingInstall = {
  title: "Loading \u52A0\u8F7D\u63D0\u793A",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.directive("loading", LoadingDirective);
    app.config.globalProperties.$loadingService = loading;
  }
};
const mentionProps = {
  position: {
    type: String,
    default: "bottom"
  },
  suggestions: {
    type: Array,
    required: true
  },
  notFoundContent: {
    type: String,
    default: "No suggestion matched"
  },
  loading: {
    type: Boolean,
    default: false
  },
  dmValueParse: {
    type: Object,
    default: { value: "value", id: "id" }
  },
  trigger: {
    type: Array,
    default: ["@"]
  }
};
const textareaProps = {
  autofocus: {
    type: Boolean,
    default: false
  },
  showCount: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: void 0
  },
  modelValue: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  error: {
    type: Boolean,
    default: false
  },
  resize: {
    type: String,
    default: "none"
  },
  autosize: {
    type: [Object, Boolean],
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
};
function useTextareaRender(props) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const ns2 = useNamespace("textarea");
  const isValidateError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const isFocus = ref(false);
  const { error: error2, disabled } = toRefs(props);
  const textareaDisabled = computed(() => disabled.value || (formContext == null ? void 0 : formContext.disabled));
  const wrapClasses = computed(() => ({
    [ns2.b()]: true,
    [ns2.m("focus")]: isFocus.value,
    [ns2.m("disabled")]: textareaDisabled.value,
    [ns2.m("error")]: error2.value || isValidateError.value,
    [ns2.m("feedback")]: Boolean(formItemContext == null ? void 0 : formItemContext.validateState) && (formItemContext == null ? void 0 : formItemContext.showFeedback)
  }));
  return { isFocus, textareaDisabled, wrapClasses };
}
function useTextareaEvent(isFocus, props, ctx2) {
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const onFocus = (e) => {
    isFocus.value = true;
    ctx2.emit("focus", e);
  };
  const onBlur = (e) => {
    isFocus.value = false;
    ctx2.emit("blur", e);
    if (props.validateEvent) {
      formItemContext == null ? void 0 : formItemContext.validate("blur").catch((err) => console.warn(err));
    }
  };
  const onInput = (e) => {
    ctx2.emit("update:modelValue", e.target.value);
    ctx2.emit("update", e.target.value);
  };
  const onChange = (e) => {
    ctx2.emit("change", e.target.value);
  };
  const onKeydown = (e) => {
    ctx2.emit("keydown", e);
  };
  return { onFocus, onBlur, onInput, onChange, onKeydown };
}
let tempTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function getBoxStyle(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function computeTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a;
  if (targetElement === void 0) {
    return {};
  }
  if (!tempTextarea) {
    tempTextarea = document.createElement("textarea");
    document.body.appendChild(tempTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = getBoxStyle(targetElement);
  tempTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  tempTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = tempTextarea.scrollHeight;
  tempTextarea.value = "";
  const result2 = {};
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  const singleRowHeight = tempTextarea.scrollHeight - paddingSize;
  (_a = tempTextarea.parentNode) == null ? void 0 : _a.removeChild(tempTextarea);
  tempTextarea = void 0;
  if (minRows === void 0) {
    result2.height = `${height}px`;
    return result2;
  }
  if (lodash.exports.isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result2.minHeight = `${minHeight}px`;
  }
  if (lodash.exports.isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result2.height = `${height}px`;
  return result2;
}
function useTextareaAutosize(props, textarea2) {
  const textareaHeightStyle = shallowRef("");
  const updateTextareaStyle = () => {
    const { autosize } = props;
    if (autosize) {
      const { minRows, maxRows } = lodash.exports.isObject(autosize) ? autosize : { minRows: void 0, maxRows: void 0 };
      textareaHeightStyle.value = __spreadValues({}, computeTextareaHeight(textarea2.value, minRows, maxRows));
    } else {
      textareaHeightStyle.value = {
        minHeight: computeTextareaHeight(textarea2.value).minHeight
      };
    }
  };
  const textareaStyle = computed(() => [textareaHeightStyle.value, { resize: props.resize }]);
  return { textareaStyle, updateTextareaStyle };
}
var textarea = "";
var Textarea = defineComponent({
  name: "DTextarea",
  inheritAttrs: false,
  props: textareaProps,
  emits: ["update:modelValue", "update", "focus", "blur", "change", "keydown"],
  setup(props, ctx2) {
    const {
      modelValue
    } = toRefs(props);
    const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
    const textarea2 = shallowRef();
    const ns2 = useNamespace("textarea");
    const {
      isFocus,
      textareaDisabled,
      wrapClasses
    } = useTextareaRender(props);
    const {
      onFocus,
      onBlur,
      onInput,
      onChange,
      onKeydown
    } = useTextareaEvent(isFocus, props, ctx2);
    const {
      textareaStyle,
      updateTextareaStyle
    } = useTextareaAutosize(props, textarea2);
    watch(() => props.modelValue, () => {
      if (props.validateEvent) {
        formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
      }
      nextTick(() => updateTextareaStyle());
    });
    onMounted(() => {
      updateTextareaStyle();
    });
    return () => {
      var _a;
      return createVNode("div", {
        "style": "width: 100%"
      }, [createVNode("textarea", mergeProps({
        "ref": textarea2
      }, ctx2.attrs, {
        "value": modelValue.value,
        "autofocus": props.autofocus,
        "placeholder": props.placeholder,
        "disabled": textareaDisabled.value,
        "style": textareaStyle.value,
        "class": wrapClasses.value,
        "onInput": onInput,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "onChange": onChange,
        "onKeydown": onKeydown
      }), null), props.showCount && createVNode("div", {
        "class": ns2.e("show-count")
      }, [modelValue.value.length, !((_a = ctx2.attrs.maxlength) != null ? _a : false) ? "" : " / " + ctx2.attrs.maxlength])]);
    };
  }
});
var mention = "";
var Mention = defineComponent({
  name: "DMention",
  components: {
    DTextarea: Textarea,
    DIcon
  },
  props: mentionProps,
  emits: ["select", "change"],
  setup(props, {
    slots,
    emit
  }) {
    const ns2 = useNamespace("mention");
    const textContext = ref("");
    const showSuggestions = ref(false);
    const currentIndex = ref(0);
    const suggestionsTop = ref();
    const suggestions = ref([]);
    const filteredSuggestions = ref([]);
    const suggestionsDom = ref();
    const loading2 = computed(() => props.loading);
    const instance = getCurrentInstance();
    const handleUpdate = lodash.exports.debounce((val) => {
      if (props.trigger.includes(val[0])) {
        showSuggestions.value = true;
        if (props.position === "top") {
          setTimeout(() => {
            const height = window.getComputedStyle(suggestionsDom.value, null).height;
            suggestionsTop.value = -Number(height.replace("px", ""));
          }, 0);
        }
        filteredSuggestions.value = suggestions.value.filter((item) => String(item[props.dmValueParse.value]).toLocaleLowerCase().includes(val.slice(1).toLocaleLowerCase()));
      } else {
        showSuggestions.value = false;
      }
      emit("change", val.slice(1));
    }, 300);
    const handleBlur = (e) => {
      const {
        target
      } = e;
      const ele = document.querySelector(".devui-mention");
      if (!(ele == null ? void 0 : ele.contains(target))) {
        setTimeout(() => {
          showSuggestions.value = false;
        }, 100);
      }
    };
    const handleFocus = () => {
      if (props.trigger.includes(textContext.value)) {
        showSuggestions.value = true;
      }
    };
    const clickItem = (item, e) => {
      emit("select", item);
      e.stopPropagation();
      e.preventDefault();
      showSuggestions.value = false;
      textContext.value = textContext.value.substring(0, 1) + item[props.dmValueParse.value];
    };
    const arrowKeyDown = (e) => {
      var _a, _b, _c;
      if (showSuggestions.value && filteredSuggestions.value.length) {
        if (e.key === "ArrowDown") {
          currentIndex.value++;
          if (currentIndex.value === filteredSuggestions.value.length) {
            currentIndex.value = 0;
          }
        }
        if (e.key === "ArrowUp") {
          currentIndex.value--;
          if (currentIndex.value === -1) {
            currentIndex.value = filteredSuggestions.value.length - 1;
          }
        }
        const itemDom = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[`devui-suggestions-item-${currentIndex.value}`];
        const itemOffsetTop = itemDom == null ? void 0 : itemDom.offsetTop;
        const clientHeight = (_b = suggestionsDom.value) == null ? void 0 : _b.clientHeight;
        const itemTotal = Math.ceil(clientHeight / itemDom.clientHeight);
        if (e.key === "ArrowDown" && currentIndex.value >= itemTotal || e.key === "ArrowUp") {
          (_c = suggestionsDom.value) == null ? void 0 : _c.scrollTo({
            top: itemOffsetTop
          });
        }
      }
    };
    const enterKeyDown = (e) => {
      if (showSuggestions.value && filteredSuggestions.value.length) {
        if (e.key === "Enter") {
          e.stopPropagation();
          e.preventDefault();
          showSuggestions.value = false;
          textContext.value = textContext.value.substring(0, 1) + filteredSuggestions.value[currentIndex.value][props.dmValueParse.value];
          emit("select", filteredSuggestions.value[currentIndex.value]);
        }
      }
    };
    watch(() => props.suggestions, (val) => {
      suggestions.value = val;
      filteredSuggestions.value = val;
    }, {
      immediate: true,
      deep: true
    });
    onMounted(() => {
      window.addEventListener("keydown", arrowKeyDown);
      window.addEventListener("keydown", enterKeyDown);
      document.addEventListener("click", handleBlur);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", arrowKeyDown);
      window.removeEventListener("keydown", enterKeyDown);
      document.removeEventListener("click", handleBlur);
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.b()
      }, [createVNode(resolveComponent("d-textarea"), {
        "modelValue": textContext.value,
        "onUpdate:modelValue": ($event) => textContext.value = $event,
        "onUpdate": handleUpdate,
        "onFocus": handleFocus
      }, null), showSuggestions.value ? loading2.value ? createVNode("div", {
        "class": [`${ns2.e("suggestions")} ${ns2.e("suggestions-loading")}`]
      }, [createTextVNode("\u52A0\u8F7D\u4E2D... ")]) : createVNode("div", {
        "class": ns2.e("suggestions"),
        "ref": suggestionsDom,
        "style": {
          marginTop: props.position === "top" ? "0px" : "-16px",
          top: suggestionsTop.value ? suggestionsTop.value + "px" : "inherit"
        }
      }, [filteredSuggestions.value.length > 0 ? (_a = filteredSuggestions.value) == null ? void 0 : _a.map((item, index2) => {
        return createVNode("div", {
          "ref": `devui-suggestions-item-${index2}`,
          "class": `${ns2.e("suggestions-item")}
                    ${currentIndex.value === index2 ? `${ns2.e("suggestions-item-active")}` : ""}`,
          "key": item.id,
          "onClick": (e) => clickItem(item, e)
        }, [slots.template ? slots.template({
          item
        }) : item.value]);
      }) : createVNode("div", null, [props.notFoundContent])]) : null]);
    };
  }
});
var MentionInstall = {
  title: "Mention \u63D0\u53CA",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Mention.name, Mention);
  }
};
const elements = [];
let parents = [];
const defaultIndent = ref(24);
const ns$b = useNamespace("menu");
const subNs$2 = useNamespace("submenu");
const menuClass = ns$b.b();
const menuItemHorizontalWrapper = `${ns$b.b()}-item-horizontal-wrapper`;
const menuItemSelect$1 = `${ns$b.b()}-item-select`;
const menuActiveParent = `${ns$b.b()}-active-parent`;
function setDefaultIndent(indent) {
  defaultIndent.value = indent;
}
function pushElement(element) {
  elements.push(element);
}
function addLayer() {
  parents = [];
  elements.forEach((val) => {
    parents.push(val.el.parentElement);
  });
  const stack = [...parents];
  const getLayerFromClass = (className2) => {
    var _a;
    return (_a = /layer_(\d*)/gim.exec(className2)) == null ? void 0 : _a[1];
  };
  while (stack.length) {
    const shiftItem = stack.shift();
    if (shiftItem == null ? void 0 : shiftItem.classList.contains(menuClass)) {
      const children = shiftItem.children;
      stack.unshift(...Array.from(children));
      continue;
    } else {
      if (shiftItem.tagName === "DIV") {
        if (shiftItem.classList.contains(`${ns$b.b()}-item-vertical-wrapper`) || shiftItem.classList.contains(`${subNs$2.b()}-menu-item-vertical-wrapper`)) {
          const parent = shiftItem.parentElement;
          stack.unshift(...Array.from(shiftItem.children));
          if (parent == null ? void 0 : parent.classList.contains(menuClass)) {
            shiftItem.classList.add("layer_1");
          } else {
            let layer = getLayerFromClass((parent == null ? void 0 : parent.classList.value) || "");
            layer = Number(layer);
            shiftItem.classList.add(`layer_${layer}`);
          }
        } else {
          const parent = shiftItem.parentElement;
          let layer = getLayerFromClass((parent == null ? void 0 : parent.classList.value) || "");
          layer = Number(layer);
          shiftItem.classList.add(`layer_${layer}`);
          shiftItem.style.paddingLeft = `${(layer === 2 ? 1 : layer - 1) * defaultIndent.value}px`;
        }
      }
      if (shiftItem.tagName === "UL") {
        const parent = shiftItem.parentElement;
        const children = shiftItem.children;
        for (let i = 0; i < children.length; i++) {
          stack.unshift(children[i]);
        }
        const classList = (parent == null ? void 0 : parent.classList.value) || "";
        let layer = getLayerFromClass(classList);
        if (parent == null ? void 0 : parent.classList.contains(menuClass)) {
          layer = 1;
          shiftItem.classList.add(`layer_${2}`);
        } else {
          shiftItem.classList.add(`layer_${Number(layer) + 1}`);
          layer = Number(layer) + 1;
        }
      }
      if (shiftItem.tagName === "LI") {
        const parent = shiftItem.parentElement;
        const parentClassList = (parent == null ? void 0 : parent.classList.value) || "";
        let layer = getLayerFromClass(parentClassList);
        getLayerFromClass(parentClassList);
        layer = Number(layer);
        shiftItem.style.padding = `0 ${layer * defaultIndent.value}px`;
      }
    }
  }
}
function getRoot(path) {
  var _a;
  const paths = path;
  let rootElement = null;
  for (let i = 0; i < paths.length; i++) {
    const p = paths[i];
    if ((_a = p == null ? void 0 : p.classList) == null ? void 0 : _a.contains(`${ns$b.b()}-horizontal`)) {
      rootElement = p;
    }
  }
  return rootElement;
}
function clearSelect_isHorizontal(ele, event) {
  let element = event.target;
  let stack = [];
  const root2 = getRoot(event.composedPath());
  stack = [...Array.from(root2.children)];
  if (element.tagName === "SPAN") {
    element = element.parentElement;
  }
  while (stack.length) {
    const shiftItem = stack.shift();
    if ((shiftItem == null ? void 0 : shiftItem.tagName) === "UL" || (shiftItem == null ? void 0 : shiftItem.classList.contains(menuItemHorizontalWrapper))) {
      const children = shiftItem == null ? void 0 : shiftItem.children;
      stack.unshift(...Array.from(children));
    }
    if (shiftItem !== element) {
      shiftItem == null ? void 0 : shiftItem.classList.remove(menuItemSelect$1);
      shiftItem == null ? void 0 : shiftItem.classList.remove(menuActiveParent);
    }
  }
}
function clearSelect_notHorizontal(ele, event) {
  const stack = [];
  const path = event.path || event.composedPath && event.composedPath();
  for (let i = 0; i < path.length; i++) {
    const e = path[i];
    if (!e.classList.contains(menuClass)) {
      stack.push(...Array.from(e.children));
    } else {
      stack.push(...Array.from(e.children));
      break;
    }
  }
  while (stack.length) {
    const shiftItem = stack.shift();
    if ((shiftItem == null ? void 0 : shiftItem.tagName) === "UL" || (shiftItem == null ? void 0 : shiftItem.classList.contains(menuItemHorizontalWrapper))) {
      stack.push(...Array.from(shiftItem == null ? void 0 : shiftItem.children));
    }
    if (shiftItem !== ele) {
      if ((shiftItem == null ? void 0 : shiftItem.tagName) === "DIV") {
        stack.unshift(...Array.from(shiftItem == null ? void 0 : shiftItem.children));
      }
      shiftItem == null ? void 0 : shiftItem.classList.remove(menuItemSelect$1);
      shiftItem == null ? void 0 : shiftItem.classList.remove(menuActiveParent);
    }
  }
}
function clearSelect(ele, event, isHorizontal = false) {
  if (isHorizontal) {
    clearSelect_isHorizontal(ele, event);
  } else {
    clearSelect_notHorizontal(ele, event);
  }
}
function getLayer(el) {
  var _a;
  const getLayerReg = /layer_(\d{1,})/gim;
  const className2 = el.className;
  return (_a = getLayerReg.exec(className2)) == null ? void 0 : _a[1];
}
const menuItemProps = {
  disabled: {
    type: Boolean,
    default: false
  },
  href: {
    type: String,
    default: ""
  },
  route: {
    type: [String, Object]
  }
};
const ns$a = useNamespace("menu");
function initSelect(defaultSelectKeys, keys2, isMultiple, disabled) {
  const isSelect = ref(false);
  if (!isMultiple) {
    if (defaultSelectKeys[0] === keys2 && !disabled.value) {
      isSelect.value = true;
    } else {
      isSelect.value = false;
    }
  } else {
    if (defaultSelectKeys.includes(keys2)) {
      isSelect.value = true;
    } else {
      isSelect.value = false;
    }
  }
  return isSelect.value;
}
function addActiveParent(ele) {
  var _a, _b;
  let cur = ele.parentElement;
  while (!cur.classList.contains(ns$a.b())) {
    if (((_a = cur.firstElementChild) == null ? void 0 : _a.tagName) === "DIV") {
      (_b = cur == null ? void 0 : cur.firstElementChild) == null ? void 0 : _b.classList.add(`${ns$a.b()}-active-parent`);
    }
    cur = cur.parentElement;
  }
  return cur;
}
function changeRoute(props, router, useRouter, key) {
  if (useRouter && router) {
    const route = props.route || key;
    const routerResult = router.push(route).then((res) => {
      return res;
    });
    return { route, routerResult };
  }
  return void 0;
}
const ns$9 = useNamespace("menu");
function useClick(e) {
  const paths = e.composedPath();
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path.classList.contains(`${ns$9.b()}-horizontal`)) {
      break;
    } else if (path.classList.contains(`${ns$9.b()}-item-horizontal-wrapper`)) {
      continue;
    } else {
      if (path.tagName !== "SPAN") {
        path.classList.add(`${ns$9.b()}-item-select`);
      }
    }
  }
}
const ns$8 = useNamespace("menu");
const menuItemSelect = `${ns$8.b()}-item-select`;
const menuItemDisabled = `${ns$8.b()}-item-disabled`;
var MenuItem = defineComponent({
  name: "DMenuItem",
  props: menuItemProps,
  setup(props, ctx2) {
    var _a, _b;
    const instance = getCurrentInstance();
    const key = String(instance == null ? void 0 : instance.vnode.key);
    const menuStore = inject("menuStore");
    const mode = inject("mode");
    const multiple = inject("multiple");
    const indent = inject("defaultIndent");
    const isCollapsed = inject("isCollapsed");
    const defaultSelectKey = inject("defaultSelectKey");
    const {
      disabled
    } = toRefs(props);
    const isSelect = ref(initSelect(defaultSelectKey.value, key, multiple, disabled));
    const isLayer1 = ref(true);
    const rootMenuEmit = inject("rootMenuEmit");
    const useRouter = inject("useRouter");
    const router = instance == null ? void 0 : instance.appContext.config.globalProperties.$router;
    const classObject = computed(() => ({
      [`${ns$8.b()}-item`]: true,
      [`${ns$8.b()}-item-isCollapsed`]: isCollapsed.value,
      [menuItemSelect]: isSelect.value,
      [menuItemDisabled]: disabled.value
    }));
    menuStore.on("menuItem:clear:select", () => {
      isSelect.value = false;
    });
    const onClick = (e) => {
      var _a2;
      e.stopPropagation();
      const ele = e.currentTarget;
      let changeRouteResult = void 0;
      props.disabled && e.preventDefault();
      if (!props.disabled) {
        if (!multiple) {
          menuStore.emit("menuItem:clear:select");
          clearSelect(ele, e, mode.value === "horizontal");
          if (mode.value === "horizontal") {
            useClick(e);
          }
          isSelect.value = true;
          changeRouteResult = changeRoute(props, router, useRouter, key);
        } else {
          if (ele.classList.contains(menuItemSelect)) {
            rootMenuEmit("deselect", {
              type: "deselect",
              key,
              el: ele,
              e
            });
            isSelect.value = false;
            return;
          } else {
            isSelect.value = true;
            ele.classList.add(menuItemSelect);
          }
        }
        if (changeRouteResult === void 0) {
          rootMenuEmit("select", {
            type: "select",
            key,
            el: ele,
            e
          });
        } else {
          rootMenuEmit("select", {
            type: "select",
            key,
            el: ele,
            e,
            route: changeRouteResult
          });
        }
      }
      if (mode.value === "vertical") {
        const target = e.currentTarget;
        addActiveParent(target);
      }
      if (mode.value === "horizontal") {
        const ul = (_a2 = ele.parentElement) == null ? void 0 : _a2.parentElement;
        ul == null ? void 0 : ul.classList.add(`${ns$8.b()}-active-parent`);
      }
    };
    const icons = createVNode("span", {
      "class": `${ns$8.b()}-icon`
    }, [(_b = (_a = ctx2.slots).icon) == null ? void 0 : _b.call(_a)]);
    const menuItems = ref(null);
    watch(disabled, () => {
      if (!multiple) {
        classObject.value[menuItemSelect] = false;
      }
    });
    watch(() => [...defaultSelectKey.value], (n) => {
      isSelect.value = initSelect(n, key, multiple, disabled);
      classObject.value[menuItemSelect] = isSelect.value;
    });
    onMounted(() => {
      var _a2, _b2;
      let oldPadding = "";
      const ele = menuItems.value;
      if (mode.value === "vertical") {
        if ((_b2 = (_a2 = ele.parentElement) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b2.classList.contains(ns$8.b())) {
          isLayer1.value = true;
          if (isLayer1.value) {
            ele.style.paddingRight = ``;
            ele.style.paddingLeft = `${indent}px`;
          }
          watch(isCollapsed, (val) => {
            if (val) {
              if (ele.style.padding !== "0") {
                oldPadding = ele.style.padding;
              }
              setTimeout(() => {
                ele.style.padding = "0";
                ele.style.width = "";
                ele.style.textAlign = `center`;
              }, 300);
              ele.style.display = `block`;
            } else {
              ele.style.padding = `${oldPadding}`;
              ele.style.textAlign = ``;
              ele.style.display = `flex`;
            }
          });
        } else {
          isLayer1.value = false;
        }
      }
    });
    return () => {
      return mode.value === "vertical" ? createVNode("div", {
        "class": `${ns$8.b()}-item-vertical-wrapper`
      }, [createVNode("li", {
        "class": classObject.value,
        "onClick": onClick,
        "ref": menuItems
      }, [ctx2.slots.icon !== void 0 && icons, props.href === "" ? createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => {
          var _a2, _b2;
          return [withDirectives(createVNode("span", null, [(_b2 = (_a2 = ctx2.slots).default) == null ? void 0 : _b2.call(_a2)]), [[vShow, !isCollapsed.value]])];
        }
      }) : createVNode("a", {
        "href": props.href
      }, [createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => {
          var _a2, _b2;
          return [(_b2 = (_a2 = ctx2.slots).default) == null ? void 0 : _b2.call(_a2)];
        }
      })])])]) : createVNode("li", {
        "class": classObject.value,
        "onClick": onClick,
        "ref": menuItems
      }, [ctx2.slots.icon !== void 0 && icons, props.href === "" ? createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => {
          var _a2, _b2;
          return [withDirectives(createVNode("span", null, [(_b2 = (_a2 = ctx2.slots).default) == null ? void 0 : _b2.call(_a2)]), [[vShow, !isCollapsed.value]])];
        }
      }) : createVNode("a", {
        "href": props.href
      }, [createVNode(Transition, {
        "name": "fade"
      }, {
        default: () => {
          var _a2, _b2;
          return [(_b2 = (_a2 = ctx2.slots).default) == null ? void 0 : _b2.call(_a2)];
        }
      })])]);
    };
  }
});
function useNearestMenuElement(ele) {
  while (ele && ele.tagName !== "LI" && ele.tagName !== "UL") {
    ele = ele.parentElement;
  }
  return ele;
}
const elTransition = "0.3s height ease-in-out, 0.3s padding-top ease-in-out, 0.3s padding-bottom ease-in-out";
const TransitionObj = {
  "before-enter"(el) {
    el.style.transition = elTransition;
    el.setAttribute("data-oldPadding", el.style.padding);
    el.setAttribute("data-oldMargin", el.style.margin);
    el.style.height = "0";
    el.style.padding = "0";
    el.style.margin = "0";
  },
  enter(el) {
    el.dataset.oldOverflow = el.style.overflow;
    if (el.scrollHeight !== 0) {
      el.style.height = el.scrollHeight + "px";
    } else {
      el.style.height = "";
    }
    el.style.padding = el.getAttribute("data-oldPadding");
    el.style.margin = el.getAttribute("data-oldMargin");
    el.style.overflow = "hidden";
  },
  "after-enter"(el) {
    el.style.transition = "";
    el.style.transition = "";
    el.style.height = "";
    el.style.overflow = el.getAttribute("data-overflow");
  },
  "before-leave"(el) {
    if (!el.dataset) {
      el.dataset = {};
    }
    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;
    el.dataset.oldOverflow = el.style.overflow;
    el.style.height = el.scrollHeight + "px";
    el.style.overflow = "hidden";
  },
  leave(el) {
    if (el.scrollHeight !== 0) {
      el.style.transition = elTransition;
      el.style.height = "0";
      el.style.paddingTop = "0";
      el.style.paddingBottom = "0";
    }
  },
  "after-leave"(el) {
    el.style.transition = "";
    el.style.height = "";
    el.style.overflow = el.dataset.oldOverflow;
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  }
};
var MenuTransition = defineComponent({
  name: "DMenuTransition",
  setup(prop, ctx2) {
    return () => {
      return createVNode(Transition, {
        "onBeforeEnter": (e) => TransitionObj["before-enter"](e),
        "onBeforeLeave": (e) => TransitionObj["before-leave"](e),
        "onEnter": (e) => TransitionObj["enter"](e),
        "onAfterEnter": (e) => TransitionObj["after-enter"](e),
        "onLeave": (e) => TransitionObj["leave"](e),
        "onAfterLeave": (e) => TransitionObj["after-leave"](e)
      }, {
        default: () => {
          var _a, _b;
          return [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)];
        }
      });
    };
  }
});
const subMenuProps = {
  title: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
const ns$7 = useNamespace("menu");
const subNs$1 = useNamespace("submenu");
const menuItemHorizontalWrapperHidden = `${ns$7.b()}-item-horizontal-wrapper-hidden`;
const menuItemHorizontalWrapperShow = `${ns$7.b()}-item-horizontal-wrapper-show`;
function useShowSubMenu(eventName, e, wrapper) {
  const target = e.currentTarget;
  const targetParent = target.parentElement;
  const wrapperChildren = wrapper.children;
  wrapper.style.padding = `0 20px !important`;
  if (eventName === "mouseenter") {
    if ((targetParent == null ? void 0 : targetParent.tagName) === "DIV") {
      wrapper.classList.add(`${ns$7.b()}-item-horizontal-wrapper-level`);
      const { width } = target.getClientRects()[0];
      wrapper.style.top = `0px`;
      wrapper.style.left = `${width}px`;
    } else {
      wrapper.style.top = `26px`;
      wrapper.style.left = `0px`;
    }
    wrapper.classList.remove(menuItemHorizontalWrapperHidden);
    wrapper.classList.add(menuItemHorizontalWrapperShow);
    for (let i = 0; i < wrapperChildren.length; i++) {
      const ul = wrapperChildren[i];
      if (ul.tagName === "UL" && ul.classList.contains(subNs$1.b())) {
        const levelUlWrapper = ul.getElementsByClassName(`${ns$7.b()}-item-horizontal-wrapper`)[0];
        ul.addEventListener("mouseenter", (ev) => {
          ev.stopPropagation();
          useShowSubMenu("mouseenter", ev, levelUlWrapper);
          levelUlWrapper.classList.remove(menuItemHorizontalWrapperHidden);
          levelUlWrapper.classList.add(menuItemHorizontalWrapperShow);
        });
        ul.addEventListener("mouseleave", (ev) => {
          ev.stopPropagation();
          useShowSubMenu("mouseleave", ev, levelUlWrapper);
          levelUlWrapper.classList.remove(menuItemHorizontalWrapperShow);
          levelUlWrapper.classList.add(menuItemHorizontalWrapperHidden);
        });
      }
    }
  }
  if (eventName === "mouseleave") {
    wrapper.classList.remove(menuItemHorizontalWrapperShow);
    wrapper.classList.add(menuItemHorizontalWrapperHidden);
  }
}
const ns$6 = useNamespace("menu");
const subNs = useNamespace("submenu");
const subMenuClass = subNs.b();
var SubMenu = defineComponent({
  name: "DSubMenu",
  props: subMenuProps,
  setup(props, ctx2) {
    const isShow = ref(true);
    const {
      vnode: {
        key
      }
    } = getCurrentInstance();
    let key_ = String(key);
    const defaultOpenKeys = inject("openKeys");
    const isOpen = ref(defaultOpenKeys.value.includes(key_));
    const indent = inject("defaultIndent");
    const isCollapsed = inject("isCollapsed");
    const mode = inject("mode");
    const subMenuItemContainer = ref(null);
    const parentEmit = inject("rootMenuEmit");
    const isHorizontal = mode.value === "horizontal";
    if (key_ === "null") {
      console.warn(`[devui][menu]: Key can not be null`);
      key_ = `randomKey-${randomId(16)}`;
    }
    const clickHandle = (e) => {
      e.stopPropagation();
      const ele = useNearestMenuElement(e.target);
      if (ele.classList.contains(subMenuClass) && isHorizontal) {
        return;
      }
      if (isHorizontal) {
        clearSelect(ele, e, true);
        useClick(e);
      }
      if (!props.disabled && mode.value !== "horizontal") {
        const cur = useNearestMenuElement(e.target);
        const idx = defaultOpenKeys.value.indexOf(key_);
        if (idx >= 0 && cur.tagName === "UL") {
          defaultOpenKeys.value.splice(idx, 1);
        } else {
          if (cur.tagName === "UL") {
            defaultOpenKeys.value.push(key_);
          }
        }
        isOpen.value = defaultOpenKeys.value.indexOf(key_) >= 0;
        parentEmit("submenu-change", {
          type: "submenu-change",
          state: isOpen.value,
          key: key_,
          el: ele
        });
      }
    };
    const wrapper = ref(null);
    let wrapperDom;
    const subMenu = ref(null);
    const title = ref(null);
    let oldPadding = "";
    const class_layer = ref("");
    watchEffect(() => {
      wrapperDom = wrapper.value;
      pushElement({
        el: subMenu.value
      });
    }, {
      flush: "post"
    });
    watch(() => defaultOpenKeys, (n) => {
      if (n.value.includes(key_)) {
        isOpen.value = true;
      } else {
        isOpen.value = false;
      }
    }, {
      deep: true
    });
    onMounted(() => {
      var _a;
      const subMenuTitle = title.value;
      const subMenuWrapper = subMenu.value;
      addLayer();
      class_layer.value = `layer_${(_a = Array.from(subMenuWrapper.classList).at(-1)) == null ? void 0 : _a.replace("layer_", "")}`;
      if (isHorizontal && !props.disabled) {
        subMenu.value.addEventListener("mouseenter", (ev) => {
          ev.stopPropagation();
          useShowSubMenu("mouseenter", ev, wrapperDom);
        });
        subMenu.value.addEventListener("mouseleave", (ev) => {
          ev.stopPropagation();
          useShowSubMenu("mouseleave", ev, wrapperDom);
        });
      }
      watch(isCollapsed, (newValue) => {
        const layer = Number(getLayer(subMenuWrapper));
        if (!Number.isNaN(layer)) {
          layer > 2 && (isShow.value = !isCollapsed.value);
        }
        if (newValue) {
          subMenuTitle.style.padding !== "0" && (oldPadding = subMenuTitle.style.padding);
          setTimeout(() => {
            subMenuTitle.style.padding = "0";
            subMenuTitle.style.width = "";
            subMenuTitle.style.textAlign = `center`;
          }, 300);
          subMenuTitle.style.display = `block`;
        } else {
          subMenuTitle.style.padding = `${oldPadding}`;
          subMenuTitle.style.textAlign = ``;
          subMenuTitle.style.display = `flex`;
        }
      });
    });
    return () => {
      var _a, _b, _c, _d;
      return withDirectives(createVNode("ul", {
        "onClick": clickHandle,
        "class": [subMenuClass, class_layer.value, props["disabled"] && `${subMenuClass}-disabled`],
        "ref": subMenu
      }, [createVNode("div", {
        "class": [`${subMenuClass}-title`],
        "style": `padding: 0 ${indent}px`,
        "ref": title
      }, [createVNode("span", {
        "class": `${ns$6.b()}-icon`
      }, [(_b = (_a = ctx2.slots) == null ? void 0 : _a.icon) == null ? void 0 : _b.call(_a)]), withDirectives(createVNode("span", {
        "class": `${subMenuClass}-title-content`
      }, [props.title]), [[vShow, !isCollapsed.value]]), withDirectives(createVNode("i", {
        "class": {
          "icon icon-chevron-up": class_layer.value !== `layer_${subMenuClass}`,
          "icon icon-chevron-right": class_layer.value === `layer_${subMenuClass}`,
          "is-opened": isOpen.value
        }
      }, null), [[vShow, !isCollapsed.value && key !== "overflowContainer"]])]), isHorizontal ? withDirectives(createVNode("div", {
        "class": `${ns$6.b()}-item-horizontal-wrapper ${ns$6.b()}-item-horizontal-wrapper-hidden`,
        "ref": wrapper
      }, [(_d = (_c = ctx2.slots).default) == null ? void 0 : _d.call(_c)]), [[vShow, !props.disabled]]) : createVNode(MenuTransition, null, {
        default: () => {
          var _a2, _b2;
          return [withDirectives(createVNode("div", {
            "class": [`${subMenuClass}-menu-item-vertical-wrapper`],
            "ref": subMenuItemContainer
          }, [(_b2 = (_a2 = ctx2.slots).default) == null ? void 0 : _b2.call(_a2)]), [[vShow, isOpen.value]])];
        }
      })]), [[vShow, isShow.value]]);
    };
  }
});
const menuProps = {
  width: {
    type: String,
    default: ""
  },
  collapsed: {
    type: Boolean,
    default: false
  },
  collapsedIndent: {
    type: Number,
    default: 24
  },
  indentSize: {
    type: Number,
    default: 24
  },
  multiple: {
    type: Boolean,
    default: false
  },
  openKeys: {
    type: Array,
    default: []
  },
  defaultSelectKeys: {
    type: Array,
    default: []
  },
  mode: {
    type: String,
    default: "vertical"
  },
  router: {
    type: Boolean,
    default: false
  }
};
var menu = "";
const recordTable = {};
class Store$1 {
  constructor(rootName) {
    __publicField(this, "rootMenuName");
    this.rootMenuName = rootName;
  }
  on(eventName, fn) {
    var _a;
    if (!((_a = recordTable == null ? void 0 : recordTable[this.rootMenuName]) == null ? void 0 : _a[eventName])) {
      Reflect.set(recordTable[this.rootMenuName], eventName, []);
    }
    recordTable[this.rootMenuName][eventName].push(fn);
  }
  emit(eventName, ...args) {
    recordTable[this.rootMenuName][eventName].forEach((fn) => fn(...args));
  }
  off(eventName, fn) {
    const idx = recordTable[this.rootMenuName][eventName].indexOf(fn);
    if (idx >= 0) {
      recordTable[this.rootMenuName][eventName].splice(idx, 1);
    }
  }
}
function useStore(rootName) {
  if (!recordTable[rootName]) {
    Reflect.set(recordTable, rootName, {});
  }
  return new Store$1(rootName);
}
var Menu = defineComponent({
  name: "DMenu",
  props: menuProps,
  emits: ["select", "deselect", "submenu-change"],
  setup(props, ctx2) {
    const ns2 = useNamespace("menu");
    const {
      openKeys,
      mode,
      collapsed,
      defaultSelectKeys
    } = toRefs(props);
    const menuId = randomId(16);
    const store = useStore(menuId);
    provide("menuStore", store);
    provide("isCollapsed", collapsed);
    provide("defaultIndent", props["indentSize"]);
    provide("multiple", props["multiple"]);
    provide("openKeys", openKeys);
    provide("defaultSelectKey", defaultSelectKeys);
    provide("mode", mode);
    provide("collapsedIndent", props["collapsedIndent"]);
    provide("rootMenuEmit", ctx2.emit);
    provide("useRouter", props.router);
    setDefaultIndent(props["indentSize"]);
    const menuRoot = ref(null);
    const overflowItemLength = ref(0);
    const overflowContainer = ref(null);
    const selectClassName = `${ns2.b()}-item-select`;
    const rootClassName2 = computed(() => ({
      [`${ns2.b()}`]: true,
      [`${ns2.b()}-vertical`]: mode.value === "vertical",
      [`${ns2.b()}-horizontal`]: mode.value === "horizontal",
      [`${ns2.b()}-collapsed`]: collapsed.value
    }));
    const overflowContainerClassName = reactive({
      [selectClassName]: false,
      [`${ns2.b()}-overflow-container`]: true
    });
    const resetOverflowContainerSelectState = (e) => {
      const children = Array.from(e.children);
      for (const item of children) {
        if (item.classList.contains(selectClassName)) {
          overflowContainerClassName[selectClassName] = true;
          break;
        } else {
          overflowContainerClassName[selectClassName] = false;
        }
      }
    };
    onMounted(() => {
      var _a;
      if (props["mode"] === "horizontal") {
        let flag = false;
        const overflowContainerElement = (_a = overflowContainer.value) == null ? void 0 : _a.$el;
        const root2 = menuRoot.value;
        const children = root2.children;
        const container = overflowContainerElement.children[1];
        const ob = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (!entry.isIntersecting) {
              const cloneNode = entry.target.cloneNode(true);
              if (entry.target.classList.contains(`${ns2.b()}-overflow-container`)) {
                if (flag && entry.target.previousElementSibling && container.children.length) {
                  root2.appendChild(entry.target.previousElementSibling);
                } else {
                  flag = true;
                }
              } else {
                overflowItemLength.value += 1;
                entry.target.style.visibility = "hidden";
                if (overflowContainerElement.nextSibling) {
                  root2.insertBefore(entry.target, overflowContainerElement.nextSibling);
                } else {
                  root2.appendChild(entry.target);
                }
                container.appendChild(cloneNode);
                resetOverflowContainerSelectState(container);
              }
            } else {
              if (!entry.target.classList.contains(`${ns2.b()}-overflow-container`) && entry.target.style.visibility === "hidden") {
                ob.unobserve(entry.target);
                root2.insertBefore(entry.target, overflowContainerElement);
                entry.target.style.visibility = "";
                const obItem = overflowContainerElement.previousElementSibling;
                const canObAgin = obItem && entry.boundingClientRect.width % entry.target.getBoundingClientRect().width === 0;
                if (canObAgin) {
                  ob.observe(obItem);
                }
                if (obItem == null ? void 0 : obItem.classList.contains("devui-submenu")) {
                  const sub = obItem;
                  const wrapper = obItem.children[1];
                  sub.addEventListener("mouseenter", (ev) => {
                    ev.stopPropagation();
                    useShowSubMenu("mouseenter", ev, wrapper);
                  });
                  sub.addEventListener("mouseleave", (ev) => {
                    ev.stopPropagation();
                    useShowSubMenu("mouseleave", ev, wrapper);
                  });
                }
                overflowItemLength.value -= 1;
                ob.observe(entry.target);
                if (container.lastChild) {
                  container.removeChild(container.lastChild);
                }
                resetOverflowContainerSelectState(container);
              }
            }
          });
        }, {
          root: root2,
          threshold: 1,
          rootMargin: "8px"
        });
        for (let i = 0; i < children.length; i++) {
          ob.observe(children[i]);
        }
      }
    });
    return () => {
      var _a, _b;
      return createVNode("ul", {
        "ref": menuRoot,
        "class": rootClassName2.value,
        "style": [props["collapsed"] ? `width:${props["collapsedIndent"] * 2}px` : `width: ${props["width"]}`]
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a), withDirectives(createVNode(SubMenu, {
        "ref": overflowContainer,
        "key": "overflowContainer",
        "title": "...",
        "class": overflowContainerClassName
      }, null), [[vShow, overflowItemLength.value > 0 && mode.value === "horizontal"]])]);
    };
  }
});
var MenuInstall = {
  title: "Menu \u83DC\u5355",
  category: "\u5BFC\u822A",
  status: "100%",
  install(app) {
    app.component(Menu.name, Menu);
    app.component(MenuItem.name, MenuItem);
    app.component(SubMenu.name, SubMenu);
  }
};
var Close$1 = defineComponent({
  emits: ["click"],
  setup(props, {
    emit
  }) {
    const ns2 = useNamespace("message");
    return () => createVNode("div", {
      "class": ns2.e("icon-close"),
      "onClick": (e) => emit("click", e)
    }, [createVNode(DIcon, {
      "name": "close",
      "size": "14px"
    }, null)]);
  }
});
const messageProps = {
  id: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: false
  },
  message: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "normal"
  },
  bordered: {
    type: Boolean,
    default: true
  },
  shadow: {
    type: Boolean,
    default: true
  },
  duration: {
    type: Number,
    default: 3e3
  },
  showClose: {
    type: Boolean,
    default: false
  },
  onClose: {
    type: Function
  }
};
const ns$5 = useNamespace("message");
function SuccessIcon$1() {
  return createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "class": ns$5.e("icon")
  }, [createVNode("path", {
    "fill": "currentColor",
    "d": "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
  }, null)]);
}
function WarningIcon$1() {
  return createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "class": ns$5.e("icon")
  }, [createVNode("path", {
    "fill": "currentColor",
    "d": "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
  }, null)]);
}
function InfoIcon$1() {
  return createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "class": ns$5.e("icon")
  }, [createVNode("path", {
    "fill": "currentColor",
    "d": "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
  }, null)]);
}
function ErrorIcon$1() {
  return createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "class": ns$5.e("icon")
  }, [createVNode("path", {
    "fill": "currentColor",
    "d": "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
  }, null)]);
}
var message$1 = "";
var Message$1 = defineComponent({
  name: "DMessage",
  props: messageProps,
  emits: ["destroy", "close"],
  setup(props, {
    emit,
    slots
  }) {
    const {
      visible,
      message: message2,
      type: type4,
      bordered,
      shadow,
      showClose
    } = toRefs(props);
    const ns2 = useNamespace("message");
    let timer = null;
    let timestamp;
    const handleDestroy = () => {
      emit("destroy");
    };
    const close2 = () => {
      var _a;
      timer && clearTimeout(timer);
      timer = null;
      (_a = props.onClose) == null ? void 0 : _a.call(props);
    };
    const interrupt = () => {
      if (timer && props.duration) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const removeReset = () => {
      if (props.visible && props.duration) {
        const remainTime = props.duration - (Date.now() - timestamp);
        timer = setTimeout(close2, remainTime);
      }
    };
    watch(() => props.visible, (val) => {
      if (val) {
        timestamp = Date.now();
        if (props.duration) {
          timer = setTimeout(close2, props.duration);
        }
      }
    });
    const classes = computed(() => ({
      [ns2.b()]: true,
      [ns2.m(type4.value)]: true
    }));
    const lastOffset = computed(() => getLastOffset(props.id));
    const styles = computed(() => {
      const messageStyles = {};
      if (!bordered.value) {
        messageStyles["border"] = "none";
      }
      if (!shadow.value) {
        messageStyles["box-shadow"] = "none";
      }
      return __spreadProps(__spreadValues({}, messageStyles), {
        top: `${lastOffset.value}px`
      });
    });
    const renderIcon = computed(() => {
      const iconClasses = computed(() => ({
        [ns2.e("image")]: true,
        [ns2.em("image", type4.value)]: true
      }));
      return !(!type4.value || type4.value === "normal") && createVNode("span", {
        "class": iconClasses.value
      }, [type4.value && (type4.value === "success" && createVNode(SuccessIcon$1, null, null) || type4.value === "info" && createVNode(InfoIcon$1, null, null) || type4.value === "warning" && createVNode(WarningIcon$1, null, null) || type4.value === "error" && createVNode(ErrorIcon$1, null, null))]);
    });
    const renderText = computed(() => {
      var _a;
      const textClasses = computed(() => ({
        [ns2.e("content")]: true,
        [ns2.em("content", type4.value)]: true
      }));
      return createVNode("span", {
        "class": textClasses.value
      }, [message2.value ? message2.value : (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    });
    const renderClose = computed(() => {
      return showClose.value && createVNode("span", {
        "class": [ns2.e("close")],
        "onClick": close2
      }, [createVNode(Close$1, null, null)]);
    });
    return () => {
      return createVNode(Transition, {
        "name": "message-fade",
        "onAfterLeave": handleDestroy
      }, {
        default: () => [visible.value && createVNode("div", {
          "class": classes.value,
          "style": __spreadValues({}, styles.value),
          "onMouseenter": interrupt,
          "onMouseleave": removeReset
        }, [renderIcon.value, renderText.value, renderClose.value])]
      });
    };
  }
});
function _isSlot$6(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const instances = shallowReactive([]);
const getLastOffset = (id) => {
  const idx = instances.findIndex((instance) => instance.id === id);
  return idx * 65 + 80;
};
const deleteInstance = (id) => {
  const idx = instances.findIndex((instance) => instance.id === id);
  if (idx !== -1) {
    instances.splice(idx, 1);
  }
  return idx;
};
const initInstance$1 = (id, props, message2) => {
  const container = document.createElement("div");
  container.id = id;
  const app = createApp({
    setup() {
      onUnmounted(() => {
        document.body.removeChild(container);
      });
      return () => createVNode(Message$1, mergeProps(props, {
        "id": id,
        "onDestroy": app.unmount
      }), _isSlot$6(message2) ? message2 : {
        default: () => [message2]
      });
    }
  });
  document.body.appendChild(container);
  app.mount(container);
  return {
    id,
    props
  };
};
const defaultOptions$1 = {
  duration: 3e3,
  type: "normal"
};
const normalizeOptions = (params) => {
  const options = !params || isString$1(params) ? {
    message: params
  } : params;
  const normalized = __spreadValues(__spreadValues({}, defaultOptions$1), options);
  return normalized;
};
let seed = 0;
function open(options) {
  const originOnClose = options.onClose || null;
  const messageContent = options.message;
  delete options.message;
  const props = reactive(__spreadProps(__spreadValues(__spreadValues({}, defaultOptions$1), options), {
    onClose: () => {
      props.visible = false;
      deleteInstance(props.id);
      originOnClose == null ? void 0 : originOnClose();
    }
  }));
  seed++;
  const id = `message_${seed}`;
  props.id = id;
  const messageContext = initInstance$1(id, props, messageContent);
  instances.push(messageContext);
  props.visible = true;
}
function message(params) {
  const options = normalizeOptions(params);
  open(__spreadValues({}, options));
}
function success(params) {
  const options = normalizeOptions(params);
  open(__spreadProps(__spreadValues({}, options), {
    type: "success"
  }));
}
function error(params) {
  const options = normalizeOptions(params);
  open(__spreadProps(__spreadValues({}, options), {
    type: "error"
  }));
}
function warning2(params) {
  const options = normalizeOptions(params);
  open(__spreadProps(__spreadValues({}, options), {
    type: "warning"
  }));
}
function info(params) {
  const options = normalizeOptions(params);
  open(__spreadProps(__spreadValues({}, options), {
    type: "info"
  }));
}
const Message = Object.assign(message, {
  success,
  error,
  warning: warning2,
  info
});
var MessageInstall = {
  title: "Message \u5168\u5C40\u63D0\u793A",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.config.globalProperties.$message = Message;
  }
};
const modalProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: ""
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  draggable: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  },
  beforeClose: {
    type: Function
  },
  escapable: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  showOverlay: {
    type: Boolean,
    default: true
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  type: {
    type: String,
    default: ""
  },
  keepLast: {
    type: Boolean,
    default: false
  }
};
function useModal(props, emit) {
  function close2() {
    emit("update:modelValue", false);
  }
  function execClose() {
    props.beforeClose ? props.beforeClose(close2) : close2();
  }
  function onKeydown(event) {
    if (event.code === "Escape") {
      execClose();
    }
  }
  onMounted(() => {
    if (props.escapable) {
      window.addEventListener("keydown", onKeydown);
    }
  });
  onUnmounted(() => {
    if (props.escapable) {
      window.addEventListener("keydown", onKeydown);
    }
  });
  return { execClose };
}
function useModalRender(props) {
  let lockScrollCb;
  const removeBodyAdditions = () => {
    lockScrollCb == null ? void 0 : lockScrollCb();
  };
  watch(() => props.modelValue, (val) => {
    if (val) {
      props.lockScroll && (lockScrollCb = lockScroll());
    } else {
      removeBodyAdditions();
    }
  }, {
    immediate: true
  });
  onUnmounted(removeBodyAdditions);
}
function addUnit(value, defaultUnit = "px") {
  if (!value) {
    return "";
  }
  if (typeof value === "string") {
    return value;
  } else if (typeof value === "number") {
    return `${value}${defaultUnit}`;
  } else {
    return "";
  }
}
const useDraggable = (targetRef, dragRef, draggable) => {
  const modalPosition = ref("translate(-50%, -50%)");
  let transform = {
    offsetX: 0,
    offsetY: 0
  };
  const onMousedown2 = (e) => {
    const downX = e.clientX;
    const downY = e.clientY;
    const { offsetX, offsetY } = transform;
    const targetRect = targetRef.value.getBoundingClientRect();
    const targetLeft = targetRect.left;
    const targetTop = targetRect.top;
    const targetWidth = targetRect.width;
    const targetHeight = targetRect.height;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const minLeft = -targetLeft + offsetX;
    const minTop = -targetTop + offsetY;
    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
    const maxTop = clientHeight - targetTop - targetHeight + offsetY;
    const onMousemove = (ev) => {
      const moveX = Math.min(Math.max(offsetX + ev.clientX - downX, minLeft), maxLeft);
      const moveY = Math.min(Math.max(offsetY + ev.clientY - downY, minTop), maxTop);
      transform = {
        offsetX: moveX,
        offsetY: moveY
      };
      modalPosition.value = `translate(calc(-50% + ${addUnit(moveX)}), calc(-50% + ${addUnit(moveY)}))`;
    };
    const onMouseup = () => {
      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onMouseup);
    };
    document.addEventListener("mousemove", onMousemove);
    document.addEventListener("mouseup", onMouseup);
  };
  const onDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.addEventListener("mousedown", onMousedown2);
    }
  };
  const offDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.removeEventListener("mousedown", onMousedown2);
    }
  };
  onMounted(() => {
    watchEffect(() => {
      if (draggable.value) {
        onDraggable();
      } else {
        offDraggable();
      }
    });
  });
  onBeforeUnmount(() => {
    offDraggable();
  });
  const clearPosition = () => {
    transform = {
      offsetX: 0,
      offsetY: 0
    };
    modalPosition.value = "translate(-50%, -50%)";
  };
  return {
    clearPosition,
    modalPosition
  };
};
var Header = defineComponent({
  name: "DModalHeader",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("modal");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("header")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var Body = defineComponent({
  name: "DModalBody",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("modal");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("body")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var modal = "";
var Modal = defineComponent({
  name: "DModal",
  inheritAttrs: false,
  props: modalProps,
  emits: ["update:modelValue"],
  setup(props, {
    slots,
    attrs,
    emit
  }) {
    const ns2 = useNamespace("modal");
    const {
      modelValue,
      title,
      showClose,
      showOverlay,
      appendToBody,
      closeOnClickOverlay,
      keepLast
    } = toRefs(props);
    const {
      execClose
    } = useModal(props, emit);
    useModalRender(props);
    const dialogRef = ref();
    const headerRef = ref();
    const draggable = computed(() => props.draggable);
    const {
      clearPosition,
      modalPosition
    } = useDraggable(dialogRef, headerRef, draggable);
    watch(modelValue, (val) => {
      if (val && !keepLast.value) {
        clearPosition();
        nextTick(() => {
          const autofocus = document == null ? void 0 : document.querySelector("[autofocus]");
          if (autofocus) {
            autofocus.focus();
          }
        });
      }
    });
    const renderType = () => {
      const typeList = [{
        type: "success",
        text: "\u6210\u529F",
        icon: "right-o",
        color: "var(--b-success)"
      }, {
        type: "failed",
        text: "\u9519\u8BEF",
        icon: "error-o",
        color: "var(--b-danger)"
      }, {
        type: "warning",
        text: "\u8B66\u544A",
        icon: "warning-o",
        color: "var(--b-warning)"
      }, {
        type: "info",
        text: "\u4FE1\u606F",
        icon: "info-o",
        color: "var(--b-info)"
      }];
      const item = typeList.find((i) => i.type === props.type);
      return createVNode("div", {
        "style": {
          cursor: props.draggable ? "move" : "default"
        },
        "ref": headerRef
      }, [createVNode(Header, null, {
        default: () => [createVNode("div", {
          "class": "type-content"
        }, [createVNode("div", {
          "class": "type-content-icon"
        }, [createVNode(DIcon, {
          "name": item == null ? void 0 : item.icon,
          "color": item == null ? void 0 : item.color
        }, null)]), createVNode("div", {
          "class": "type-content-text"
        }, [item == null ? void 0 : item.text])])]
      })]);
    };
    return () => createVNode(Teleport, {
      "to": "body",
      "disabled": !appendToBody.value
    }, {
      default: () => [showOverlay.value && createVNode(FixedOverlay, mergeProps({
        "modelValue": modelValue.value
      }, {
        "onUpdate:modelValue": execClose
      }, {
        "class": ns2.e("overlay"),
        "lock-scroll": false,
        "close-on-click-overlay": closeOnClickOverlay.value,
        "style": {
          zIndex: "calc(var(--b-z-index-modal, 1050) - 1)"
        }
      }), null), createVNode(Transition, {
        "name": props.showAnimation ? ns2.m("wipe") : ""
      }, {
        default: () => {
          var _a;
          return [modelValue.value && createVNode("div", mergeProps({
            "ref": dialogRef,
            "class": ns2.b()
          }, attrs, {
            "onClick": (e) => e.stopPropagation(),
            "style": {
              transform: modalPosition.value
            }
          }), [showClose.value && createVNode("div", {
            "onClick": execClose,
            "class": "btn-close"
          }, [createVNode(DIcon, {
            "name": "close",
            "size": "20px"
          }, null)]), props.type ? renderType() : createVNode("div", {
            "style": {
              cursor: props.draggable ? "move" : "default"
            },
            "ref": headerRef
          }, [slots.header ? slots.header() : title.value && createVNode(Header, null, {
            default: () => [title.value]
          })]), createVNode(Body, null, {
            default: () => {
              var _a2;
              return [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)];
            }
          }), (_a = slots.footer) == null ? void 0 : _a.call(slots)])];
        }
      })]
    });
  }
});
var Footer = defineComponent({
  name: "DModalFooter",
  setup(props, {
    slots
  }) {
    const ns2 = useNamespace("modal");
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("footer")
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
class CommonModalService {
  constructor(anchorContainer) {
    this.anchorContainer = anchorContainer;
  }
  renderModal(anchor2, props, children) {
    const vnode = h(this.component(), props, children);
    render(vnode, anchor2);
    return vnode;
  }
  renderNull(anchor2) {
    setTimeout(() => {
      render(null, anchor2);
    }, 500);
  }
}
let vm;
class ModalService extends CommonModalService {
  component() {
    return Modal;
  }
  open(props = {}) {
    const anchor2 = document.createElement("div");
    this.anchorContainer.appendChild(anchor2);
    const _a = props, { header: header2, content: content2, footer: footer2 } = _a, resProps = __objRest(_a, ["header", "content", "footer"]);
    const renderOrigin = (propsValue, onUpdateModelValue) => {
      return this.renderModal(anchor2, __spreadProps(__spreadValues({}, propsValue), {
        modelValue: true,
        "onUpdate:modelValue": onUpdateModelValue
      }), { header: header2, default: content2, footer: footer2 });
    };
    const hide = () => {
      var _a2, _b, _c;
      const innerNeedHideOrNot = (value) => {
        if (!value) {
          hide();
        }
      };
      renderOrigin(resProps, (value) => {
        if (!value) {
          this.renderModal(anchor2, __spreadProps(__spreadValues({}, resProps), { modelValue: false }));
          this.renderNull(anchor2);
        } else {
          renderOrigin(resProps, innerNeedHideOrNot);
        }
      });
      (_c = (_b = (_a2 = vm == null ? void 0 : vm.component) == null ? void 0 : _a2.exposed) == null ? void 0 : _b.handleVisibleChange) == null ? void 0 : _c.call(_b, false);
    };
    const needHideOrNot = (value) => {
      if (!value) {
        hide();
      }
    };
    this.renderModal(anchor2, { modelValue: false });
    vm = renderOrigin(resProps, needHideOrNot);
    return { hide };
  }
}
__publicField(ModalService, "token", "MODAL_SERVICE_TOKEN");
var ModalInstall = {
  title: "Modal \u5F39\u7A97",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Modal.name, Modal);
    app.component(Header.name, Header);
    app.component(Body.name, Body);
    app.component(Footer.name, Footer);
    if (!inBrowser) {
      return;
    }
    let anchorsContainer = document.getElementById("d-modal-anchors-container");
    if (!anchorsContainer) {
      anchorsContainer = document.createElement("div");
      anchorsContainer.setAttribute("id", "d-modal-anchors-container");
      document.body.appendChild(anchorsContainer);
    }
    app.provide(ModalService.token, new ModalService(anchorsContainer));
  }
};
const multiAutoCompleteProps = {};
var multiAutoComplete = "";
var MultiAutoComplete = defineComponent({
  name: "DMultiAutoComplete",
  props: multiAutoCompleteProps,
  emits: [],
  setup(props, ctx2) {
    return () => {
      return createVNode("div", {
        "class": "devui-multi-auto-complete"
      }, null);
    };
  }
});
var MultiAutoCompleteInstall = {
  title: "MultiAutoComplete \u591A\u9879\u81EA\u52A8\u8865\u5168",
  category: "\u6570\u636E\u5F55\u5165",
  status: "1%",
  install(app) {
    app.component(MultiAutoComplete.name, MultiAutoComplete);
  }
};
const navSpriteProps = {
  target: {
    type: Object
  },
  scrollTarget: {
    type: Object
  },
  view: {
    type: Object,
    default: { top: 0, bottom: 0 }
  },
  hashSupport: {
    type: Boolean,
    default: false
  },
  mode: {
    type: String,
    default: "default"
  },
  maxLevel: {
    type: Number,
    default: 3
  },
  title: {
    type: String,
    default: "menu"
  },
  indent: {
    type: Number,
    default: 2
  },
  width: {
    type: Number,
    default: 300
  },
  height: {
    type: Number,
    default: 400
  },
  isOpen: {
    type: Boolean,
    default: true
  },
  spriteOption: {
    type: Object
  }
};
var NavSprite = defineComponent({
  name: "DNavSprite",
  props: navSpriteProps,
  emits: ["afterNavInit"],
  setup() {
    return {};
  }
});
var NavSpriteInstall = {
  title: "NavSprite \u5BFC\u822A\u7CBE\u7075",
  category: "\u5BFC\u822A",
  status: "10%",
  install(app) {
    app.component(NavSprite.name, NavSprite);
  }
};
const notificationProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "normal"
  },
  duration: {
    type: Number,
    default: 3e3
  },
  onClose: {
    type: Function
  }
};
var Close = defineComponent({
  emits: ["click"],
  setup(props, {
    emit
  }) {
    const ns2 = useNamespace("notification");
    return () => createVNode("div", {
      "class": ns2.e("icon-close"),
      "onClick": (e) => emit("click", e)
    }, [createVNode(DIcon, {
      "name": "close",
      "size": "14px"
    }, null)]);
  }
});
const ns$4 = useNamespace("notification");
const XLINK = {
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const XLINK_HREF$1 = {
  "xlink:href": "#path-s"
};
function SuccessIcon() {
  return createVNode("svg", mergeProps({
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, XLINK), [createVNode("defs", null, [createVNode("polygon", {
    "id": "path-s",
    "points": "6.53553391 9.77817459 12.1923882 4.12132034 13.6066017 5.53553391            6.53553391 12.6066017 3 9.07106781 4.41421356 7.65685425 6.53553391 9.77817459"
  }, null)]), createVNode("g", {
    "id": "correct",
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("mask", {
    "id": "mask-2",
    "fill": "white"
  }, [createVNode("use", XLINK_HREF$1, null)]), createVNode("use", mergeProps({
    "id": "Mask",
    "class": ns$4.e("image-success-path")
  }, XLINK_HREF$1), null)])]);
}
function WarningIcon() {
  return createVNode("svg", mergeProps({
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, XLINK), [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "class": ns$4.e("warning-outer"),
    "d": "M8.96244623,0.57254229 L15.8714442,13.4101975 C16.1549662,13.9370117            15.9538562,14.5918482 15.4222523,14.8728158 C15.2642579,14.9563203 15.0879506,           15 14.9088903,15 L1.09089441,15 C0.488410063,15 0,14.5159904 0,13.9189343 C0,13.7414873            0.0440768395,13.5667684 0.128340519,13.4101975 L7.03733844,0.57254229 C7.32086049,           0.0457280838 7.98165058,-0.153569987 8.51325441,0.127397589 C8.70423071,           0.228333932 8.8605922,0.383286648 8.96244623,0.57254229 Z"
  }, null), createVNode("path", {
    "class": ns$4.e("warning-inner"),
    "stroke-width": "0.3",
    "fill-rule": "nonzero",
    "d": "M8.87894737,13 L7.08947368,13 L7.08947368,11.2105263 L8.87894737,11.2105263 L8.87894737,13 Z M8.62102372,9.86842105            L7.32800539,9.86842105 L7,4.5 L8.96842105,4.5 L8.62102372,9.86842105 Z"
  }, null)])]);
}
function InfoIcon() {
  return createVNode("svg", mergeProps({
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, XLINK), [createVNode("g", {
    "id": "info",
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "class": ns$4.e("image-info-path"),
    "d": "M7,13 L7,6 L9,6 L9,13 L7,13 Z M7,5 L7,3 L9,3 L9,5 L7,5 Z",
    "id": "info"
  }, null)])]);
}
function ErrorIcon() {
  return createVNode("svg", mergeProps({
    "width": "16px",
    "height": "16px",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, XLINK), [createVNode("defs", null, [createVNode("polygon", {
    "id": "path-e",
    "points": "8.07106781 6.65685425 10.8994949 3.82842712 12.3137085 5.24264069 9.48528137 8.07106781 12.3137085            10.8994949 10.8994949 12.3137085 8.07106781 9.48528137 5.24264069 12.3137085 3.82842712 10.8994949 6.65685425            8.07106781 3.82842712 5.24264069 5.24264069 3.82842712"
  }, null)]), createVNode("g", {
    "id": "error",
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("mask", {
    "id": "mask-2",
    "fill": "white"
  }, [createVNode("use", XLINK_HREF$1, null)]), createVNode("use", mergeProps({
    "id": "Mask",
    "class": ns$4.e("image-error-path")
  }, XLINK_HREF$1), null)])]);
}
var TypeIcon = defineComponent({
  props: {
    type: {
      type: String,
      default: "normal"
    }
  },
  setup(props) {
    const {
      type: type4
    } = toRefs(props);
    const ns2 = useNamespace("notification");
    const classes = computed(() => ({
      [ns2.e("image")]: true,
      [ns2.em("image", type4.value)]: true
    }));
    return () => createVNode("span", {
      "class": classes.value
    }, [type4.value && type4.value !== "normal" && (type4.value === "success" && createVNode(SuccessIcon, null, null) || type4.value === "info" && createVNode(InfoIcon, null, null) || type4.value === "warning" && createVNode(WarningIcon, null, null) || type4.value === "error" && createVNode(ErrorIcon, null, null))]);
  }
});
function useNotification(props) {
  const classes = computed(() => ({
    "devui-notification-item-container": true,
    [`devui-notification-message-${props.type}`]: true
  }));
  return { classes };
}
function useEvent(props, emit) {
  let timer = null;
  let timestamp;
  const close2 = () => {
    var _a;
    timer && clearTimeout(timer);
    timer = null;
    (_a = props.onClose) == null ? void 0 : _a.call(props);
    emit("update:modelValue", false);
  };
  const interrupt = () => {
    if (timer && props.duration) {
      clearTimeout(timer);
      timer = null;
    }
  };
  const removeReset = () => {
    if (props.modelValue && props.duration) {
      const remainTime = props.duration - (Date.now() - timestamp);
      timer = setTimeout(close2, remainTime);
    }
  };
  const handleDestroy = () => {
    emit("destroy");
  };
  watch(() => props.modelValue, (val) => {
    if (val) {
      timestamp = Date.now();
      if (props.duration) {
        timer = setTimeout(close2, props.duration);
      }
    }
  });
  return { interrupt, removeReset, close: close2, handleDestroy };
}
var notification = "";
var Notification = defineComponent({
  name: "DNotification",
  props: notificationProps,
  emits: ["update:modelValue", "destroy"],
  setup(props, {
    emit,
    slots
  }) {
    const {
      modelValue,
      title,
      type: type4
    } = toRefs(props);
    const {
      classes
    } = useNotification(props);
    const {
      interrupt,
      removeReset,
      close: close2,
      handleDestroy
    } = useEvent(props, emit);
    const ns2 = useNamespace("notification");
    return () => createVNode(Transition, {
      "name": "notification-fade",
      "onAfterLeave": handleDestroy
    }, {
      default: () => {
        var _a;
        return [modelValue.value && createVNode("div", {
          "class": ns2.b(),
          "onClick": withModifiers(() => ({}), ["stop"]),
          "onPointerup": withModifiers(() => ({}), ["stop"])
        }, [createVNode("div", {
          "class": classes.value,
          "onMouseenter": interrupt,
          "onMouseleave": removeReset
        }, [createVNode("div", {
          "class": ns2.e("item")
        }, [createVNode(Close, {
          "onClick": close2
        }, null), title.value && createVNode(TypeIcon, {
          "type": type4.value
        }, null), createVNode("div", {
          "class": ns2.e("message")
        }, [createVNode("span", {
          "class": ns2.e("title")
        }, [title.value]), createVNode("span", {
          "class": ns2.e("content")
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])])])])])];
      }
    });
  }
});
function _isSlot$5(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const defaultOptions = {
  modelValue: false,
  duration: 3e3,
  type: "normal"
};
function initInstance(props, content2) {
  const container = document.createElement("div");
  container.classList.add("notification__warpper");
  const lastChild = document.body.lastElementChild;
  let offset_Top = 50;
  if (lastChild == null ? void 0 : lastChild.classList.contains("notification__warpper")) {
    const notification2 = lastChild.lastElementChild;
    const rects = notification2.getBoundingClientRect();
    const height = rects.height;
    const top = rects.top;
    offset_Top = height + top;
  }
  const app = createApp({
    setup() {
      onUnmounted(() => {
        document.body.removeChild(container);
      });
      return () => createVNode(Notification, mergeProps(props, {
        "onDestroy": app.unmount,
        "style": [`top: ${offset_Top}px`]
      }), _isSlot$5(content2) ? content2 : {
        default: () => [content2]
      });
    }
  });
  document.body.appendChild(container);
  app.mount(container);
  return app;
}
function close(props, originOnClose) {
  props.modelValue = false;
  originOnClose == null ? void 0 : originOnClose();
}
class NotificationService {
  static open(options) {
    const originOnClose = options.onClose || null;
    const content2 = options.content;
    delete options.content;
    const props = reactive(__spreadProps(__spreadValues(__spreadValues({}, defaultOptions), options), {
      onClose: () => {
        close(props, originOnClose);
      }
    }));
    initInstance(props, content2);
    props.modelValue = true;
  }
}
var NotificationInstall = {
  title: "Notification \u5168\u5C40\u901A\u77E5",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Notification.name, Notification);
    app.config.globalProperties.$notificationService = NotificationService;
  }
};
function className$1(classStr, classOpt) {
  let classname = classStr;
  if (typeof classOpt === "object") {
    Object.keys(classOpt).forEach((key) => {
      classOpt[key] && (classname += ` ${key}`);
    });
  }
  return classname;
}
function useSelect$2(props, selectRef, ctx2, focus, blur2, isSelectFocus, t) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const ns2 = useNamespace("select");
  const dropdownRef = ref();
  const selectDisabled = computed(() => (formContext == null ? void 0 : formContext.disabled) || props.disabled);
  const selectSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "md");
  const isObjectOption = ref(false);
  const originRef = ref();
  const isOpen = ref(false);
  const toggleChange = (bool) => {
    if (selectDisabled.value) {
      return;
    }
    isOpen.value = bool;
    ctx2.emit("toggle-change", bool);
  };
  onClickOutside(dropdownRef, () => {
    toggleChange(false);
  }, { ignore: [selectRef] });
  const dropdownMenuMultipleNs = useNamespace("dropdown-menu-multiple");
  const selectCls = computed(() => {
    return className$1(ns2.b(), {
      [ns2.m("open")]: isOpen.value,
      [dropdownMenuMultipleNs.b()]: props.multiple,
      [ns2.m("lg")]: selectSize.value === "lg",
      [ns2.m("sm")]: selectSize.value === "sm",
      [ns2.m("underlined")]: props.overview === "underlined",
      [ns2.m("disabled")]: selectDisabled.value,
      [ns2.m("focus")]: isSelectFocus.value
    });
  });
  const cacheOptions = /* @__PURE__ */ new Map();
  const mergeOptions = computed(() => {
    const { multiple, modelValue } = props;
    return props.options.map((item) => {
      let option2;
      if (typeof item === "object") {
        option2 = __spreadValues({
          name: item.name ? item.name : item.value + "",
          _checked: false
        }, item);
      } else {
        option2 = {
          name: item + "",
          value: item,
          _checked: false
        };
      }
      if (multiple) {
        if (Array.isArray(modelValue)) {
          option2._checked = modelValue.includes(option2.value);
        } else {
          option2._checked = false;
        }
      }
      cacheOptions.set(option2.value, option2);
      return option2;
    });
  });
  const getValuesOption = (values) => values.map((value) => cacheOptions.get(value));
  const injectOptions = ref(/* @__PURE__ */ new Map());
  const updateInjectOptions = (item, operation, isObject2) => {
    if (operation === "add") {
      injectOptions.value.set(item.value, item);
    } else if (operation === "delete") {
      if (injectOptions.value.get(item.value)) {
        injectOptions.value.delete(item.value);
      }
    }
    isObjectOption.value = isObject2;
  };
  const updateInjectOptionsStatus = () => {
    if (props.multiple && Array.isArray(props.modelValue)) {
      for (const child of injectOptions.value.values()) {
        if (props.modelValue.includes(child.value)) {
          child._checked = true;
        } else {
          child._checked = false;
        }
      }
    }
  };
  const getInjectOptions = (values) => {
    return values.map((value) => {
      if (props.multiple && props.allowCreate) {
        const option2 = injectOptions.value.get(value);
        if (option2) {
          return option2;
        }
        const newOption = {
          name: value,
          value,
          _checked: true
        };
        return value ? newOption : option2;
      } else {
        return injectOptions.value.get(value);
      }
    });
  };
  const filterQuery = ref("");
  const selectedOptions = computed(() => {
    if (props.multiple && Array.isArray(props.modelValue)) {
      return getInjectOptions(props.modelValue).filter((item) => item ? true : false);
    } else if (!Array.isArray(props.modelValue)) {
      return getInjectOptions([props.modelValue]).filter((item) => item ? true : false);
    }
    return [];
  });
  const isSupportFilter = computed(() => lodash.exports.isFunction(props.filter) || typeof props.filter === "boolean" && props.filter);
  const getMultipleSelected = (items) => {
    if (mergeOptions.value.length) {
      ctx2.emit("value-change", getValuesOption(items).filter((item) => item ? true : false));
    } else if (isObjectOption.value) {
      const selectItems = getInjectOptions(items).filter((item) => item ? true : false);
      ctx2.emit("value-change", selectItems);
    } else {
      ctx2.emit("value-change", items);
    }
  };
  const getSingleSelected = (item) => {
    if (mergeOptions.value.length) {
      ctx2.emit("value-change", getValuesOption([item.value])[0]);
    } else if (isObjectOption.value) {
      ctx2.emit("value-change", item);
    } else {
      ctx2.emit("value-change", item.value);
    }
  };
  const valueChange = (item) => {
    const { multiple } = props;
    let { modelValue } = props;
    if (multiple) {
      const checkedItems = Array.isArray(modelValue) ? modelValue.slice() : [];
      const index2 = checkedItems.indexOf(item.value);
      const option2 = getInjectOptions([item.value])[0];
      if (option2) {
        option2._checked = !option2._checked;
      }
      const mergeOption = getValuesOption([item.value])[0];
      if (mergeOption) {
        mergeOption._checked = !mergeOption._checked;
      }
      if (index2 > -1) {
        checkedItems.splice(index2, 1);
      } else {
        checkedItems.push(item.value);
      }
      modelValue = checkedItems;
      ctx2.emit("update:modelValue", modelValue);
      if (item.create) {
        filterQuery.value = "";
      }
      if (isSupportFilter.value) {
        focus();
      }
      getMultipleSelected(checkedItems);
    } else {
      ctx2.emit("update:modelValue", item.value);
      getSingleSelected(item);
      toggleChange(false);
    }
  };
  const handleClose = () => {
    isOpen.value = false;
    ctx2.emit("toggle-change", false);
  };
  const handleClear = () => {
    if (props.multiple) {
      ctx2.emit("update:modelValue", []);
      ctx2.emit("value-change", []);
    } else {
      ctx2.emit("update:modelValue", "");
      ctx2.emit("value-change", "");
    }
    ctx2.emit("clear");
    if (isOpen.value) {
      handleClose();
      blur2();
    }
  };
  const tagDelete = (data) => {
    let { modelValue } = props;
    const checkedItems = [];
    for (const child of selectedOptions.value) {
      if (data.value === child.value) {
        child._checked = false;
      }
      if (child._checked) {
        checkedItems.push(child.value);
      }
    }
    modelValue = checkedItems;
    ctx2.emit("update:modelValue", modelValue);
    ctx2.emit("remove-tag", data.value);
    getMultipleSelected(checkedItems);
  };
  const onFocus = (e) => {
    ctx2.emit("focus", e);
    if (!selectDisabled.value) {
      isSelectFocus.value = true;
    }
  };
  const onBlur = (e) => {
    ctx2.emit("blur", e);
    if (!selectDisabled.value) {
      isSelectFocus.value = false;
    }
  };
  const queryChange = (query) => {
    filterQuery.value = query;
  };
  const isLoading = computed(() => typeof props.loading === "boolean" && props.loading);
  const debounceTime = computed(() => props.remote ? 300 : 0);
  const handlerQueryFunc = (query) => {
    var _a;
    if (lodash.exports.isFunction(props.filter)) {
      props.filter(query);
    } else {
      queryChange(query);
      (_a = dropdownRef.value) == null ? void 0 : _a.updatePosition();
    }
  };
  const debounceQueryFilter = lodash.exports.debounce((query) => {
    handlerQueryFunc(query);
  }, debounceTime.value);
  const injectOptionsArray = computed(() => Array.from(injectOptions.value.values()));
  const isShowCreateOption = computed(() => {
    const hasCommonOption = injectOptionsArray.value.filter((item) => !item.create).some((item) => item.name === filterQuery.value);
    return typeof props.filter === "boolean" && props.filter && props.allowCreate && !!filterQuery.value && !hasCommonOption;
  });
  watch(isShowCreateOption, () => {
    var _a;
    (_a = dropdownRef.value) == null ? void 0 : _a.updatePosition();
  });
  const emptyText = computed(() => {
    const visibleOptionsCount = injectOptionsArray.value.filter((item) => {
      const label = item.name || item.value;
      return label.toString().toLocaleLowerCase().includes(filterQuery.value.toLocaleLowerCase().trim());
    }).length;
    if (isLoading.value) {
      return props.loadingText || t("loadingText");
    }
    if (isSupportFilter.value && filterQuery.value && injectOptionsArray.value.length > 0 && visibleOptionsCount === 0) {
      return props.noMatchText || t("noMatchText");
    }
    if (injectOptionsArray.value.length === 0) {
      return props.noDataText || t("noDataText");
    }
    return "";
  });
  const isShowEmptyText = computed(() => {
    return !!emptyText.value && (!props.allowCreate || isLoading.value || props.allowCreate && injectOptionsArray.value.length === 0);
  });
  const isDisabled = (item) => {
    const checkOptionDisabledKey = props.optionDisabledKey ? !!item[props.optionDisabledKey] : false;
    if (!props.multiple) {
      return checkOptionDisabledKey;
    } else {
      let tempModelValue = [];
      tempModelValue = props.modelValue;
      return checkOptionDisabledKey || !!props.multipleLimit && props.multipleLimit <= tempModelValue.length && !tempModelValue.includes(item.value);
    }
  };
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
    updateInjectOptionsStatus();
  }, { deep: true });
  watch(injectOptions, () => {
    var _a;
    if (isOpen.value) {
      (_a = dropdownRef.value) == null ? void 0 : _a.updatePosition();
    }
  }, { deep: true });
  watch(isOpen, (val) => {
    var _a;
    if (val) {
      (_a = dropdownRef.value) == null ? void 0 : _a.updatePosition();
    }
  }, { flush: "post" });
  return {
    selectDisabled,
    selectSize,
    originRef,
    dropdownRef,
    isOpen,
    selectCls,
    mergeOptions,
    selectedOptions,
    filterQuery,
    emptyText,
    isLoading,
    isShowEmptyText,
    handleClear,
    valueChange,
    handleClose,
    updateInjectOptions,
    tagDelete,
    onFocus,
    onBlur,
    isDisabled,
    toggleChange,
    debounceQueryFilter,
    isShowCreateOption
  };
}
const selectProps = {
  modelValue: {
    type: [String, Number, Array],
    default: ""
  },
  "onUpdate:modelValue": {
    type: Function,
    default: void 0
  },
  options: {
    type: Array,
    default: () => []
  },
  size: {
    type: String,
    default: ""
  },
  overview: {
    type: String,
    default: "border"
  },
  placeholder: {
    type: String,
    default: ""
  },
  multiple: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  allowClear: {
    type: Boolean,
    default: false
  },
  optionDisabledKey: {
    type: String,
    default: ""
  },
  collapseTags: {
    type: Boolean,
    default: false
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: false
  },
  filter: {
    type: [Boolean, Function],
    default: false
  },
  remote: {
    type: Boolean,
    default: false
  },
  allowCreate: {
    type: Boolean,
    default: false
  },
  noDataText: {
    type: String,
    default: ""
  },
  noMatchText: {
    type: String,
    default: ""
  },
  loading: {
    type: Boolean,
    default: false
  },
  loadingText: {
    type: String,
    default: ""
  },
  onToggleChange: {
    type: Function,
    default: void 0
  },
  onValueChange: {
    type: Function,
    default: void 0
  },
  multipleLimit: {
    type: Number,
    default: 0
  }
};
const optionProps = {
  value: {
    type: [String, Number],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  create: {
    type: Boolean,
    default: false
  }
};
const optionGroupProps = {
  label: {
    type: String
  },
  disabled: {
    type: Boolean,
    default: false
  }
};
const SELECT_TOKEN = Symbol("dSelect");
const OPTION_GROUP_TOKEN = Symbol("dOptionGroup");
function useOption(props) {
  const ns2 = useNamespace("select");
  const select2 = inject(SELECT_TOKEN, null);
  const optionGroup = inject(OPTION_GROUP_TOKEN, null);
  const currentName = computed(() => {
    return props.name || props.value;
  });
  const isOptionSelected = computed(() => {
    if (!(select2 == null ? void 0 : select2.modelValue)) {
      return false;
    }
    if (select2 == null ? void 0 : select2.multiple) {
      return Array.isArray(select2.modelValue) && select2.modelValue.includes(props.value);
    } else {
      return select2.modelValue === props.value;
    }
  });
  const optionItem = computed(() => {
    return {
      name: props.name || props.value + "" || "",
      value: props.value,
      create: props.create,
      _checked: false
    };
  });
  const isDisabled = computed(() => props.disabled || ((optionGroup == null ? void 0 : optionGroup.disabled) ? true : false));
  const isObjectOption = ref(!!props.name);
  const selectOptionCls = computed(() => {
    return className$1(ns2.e("item"), {
      active: isOptionSelected.value,
      disabled: isDisabled.value
    });
  });
  const optionSelect = () => {
    if (!isDisabled.value) {
      select2 == null ? void 0 : select2.valueChange(optionItem.value);
    }
  };
  const isVisible = computed(() => {
    if (select2 == null ? void 0 : select2.filterQuery) {
      const query = select2 == null ? void 0 : select2.filterQuery.toLocaleLowerCase().trim();
      return currentName.value.toString().toLocaleLowerCase().includes(query);
    } else {
      return true;
    }
  });
  onBeforeMount(() => {
    select2 == null ? void 0 : select2.updateInjectOptions(optionItem.value, "add", isObjectOption.value);
  });
  onBeforeUnmount(() => {
    select2 == null ? void 0 : select2.updateInjectOptions(optionItem.value, "delete", isObjectOption.value);
  });
  return {
    currentName,
    selectOptionCls,
    isVisible,
    optionSelect
  };
}
var Option = defineComponent({
  name: "DOption",
  props: optionProps,
  setup(props, ctx2) {
    const {
      currentName,
      selectOptionCls,
      isVisible,
      optionSelect
    } = useOption(props);
    return () => {
      var _a;
      return withDirectives(createVNode("li", {
        "onClick": withModifiers(optionSelect, ["prevent", "stop"]),
        "class": selectOptionCls.value
      }, [((_a = ctx2.slots) == null ? void 0 : _a.default) ? ctx2.slots.default() : currentName.value]), [[vShow, isVisible.value]]);
    };
  }
});
const SelectArrowIcon = () => createVNode("svg", {
  "width": "1em",
  "height": "1em",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("path", {
  "d": "M12.1464466,6.85355339 L8.35355339,10.6464466 C8.15829124,10.8417088 7.84170876,10.8417088         7.64644661,10.6464466 L3.85355339,6.85355339 C3.65829124,6.65829124 3.65829124,6.34170876         3.85355339,6.14644661 C3.94732158,6.05267842 4.07449854,6 4.20710678,6 L11.7928932,6 C12.0690356,6         12.2928932,6.22385763 12.2928932,6.5 C12.2928932,6.63260824 12.2402148,6.7597852 12.1464466,6.85355339 Z",
  "fill-rule": "nonzero"
}, null)])]);
const tagProps = {
  type: {
    type: String,
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  titleContent: {
    type: String,
    default: ""
  },
  checked: {
    type: Boolean,
    default: false
  },
  deletable: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    default: "md"
  }
};
function useClass(props) {
  const ns2 = useNamespace("tag");
  return computed(() => {
    const { type: type4, color: color2, deletable } = props;
    return `${ns2.e("item")} ${ns2.m(type4 || (color2 ? "colorful" : "") || "default")} ${deletable ? ns2.m("deletable") : ""} ${ns2.m(props.size)}`;
  });
}
function useColor(props) {
  return computed(() => {
    const { color: color2, type: type4 } = props;
    const typeMap = {
      primary: "var(--b-primary, #5e7ce0)",
      success: "var(--b-success, #50d4ab)",
      warning: "var(--b-warning, #fac20a)",
      danger: "var(--b-danger, #f66f6a)"
    };
    const colorMap = {
      "blue-w98": "#3383ff",
      "aqua-w98": "#39afcc",
      "olivine-w98": "#2fa898",
      "green-w98": "#4eb15e",
      "yellow-w98": "#b08d1a",
      "orange-w98": "#d47f35",
      "red-w98": "#f66f6a",
      "pink-w98": "#f3689a",
      "purple-w98": "#a97af8"
    };
    if (!color2 && type4) {
      return typeMap[type4];
    }
    const themeColor = colorMap[color2] || color2;
    return themeColor;
  });
}
var tag = "";
var Tag = defineComponent({
  name: "DTag",
  props: tagProps,
  emits: ["click", "tagDelete", "checkedChange"],
  setup(props, {
    slots,
    emit
  }) {
    const ns2 = useNamespace("tag");
    const {
      type: type4,
      color: color2,
      checked,
      titleContent,
      deletable
    } = toRefs(props);
    const tagClass = useClass(props);
    const themeColor = useColor(props);
    const tagTitle = titleContent.value || "";
    const isDefaultTag = () => !type4.value && !color2.value;
    const handleClick = (e) => {
      emit("click", e);
    };
    const handleDelete = (e) => {
      e.stopPropagation();
      emit("tagDelete", e);
    };
    const contentColor = computed(() => {
      return isDefaultTag() ? "" : checked.value ? "#fff" : themeColor.value;
    });
    const closeIconEl = () => {
      const iconName = isDefaultTag() ? "error-o" : "close";
      return deletable.value ? createVNode("a", {
        "class": "remove-button",
        "onClick": handleDelete
      }, [createVNode(resolveComponent("d-icon"), {
        "size": "12px",
        "name": iconName,
        "color": contentColor.value
      }, null)]) : null;
    };
    const unWatch = watch(checked, (newVal) => {
      emit("checkedChange", newVal);
    });
    onUnmounted(() => unWatch());
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.b(),
        "onClick": handleClick
      }, [createVNode("span", {
        "class": tagClass.value,
        "style": {
          display: "block",
          color: contentColor.value,
          backgroundColor: checked.value ? themeColor.value : !color2.value ? "" : "var(--b-base-bg, #ffffff)"
        },
        "title": tagTitle
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots), closeIconEl()])]);
    };
  }
});
var TagInstall = {
  title: "Tag \u6807\u7B7E",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Tag.name, Tag);
  }
};
function useSelectContent() {
  const ns2 = useNamespace("select");
  const select2 = inject(SELECT_TOKEN);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const app = getCurrentInstance();
  const t = createI18nTranslate("DSelect", app);
  const searchQuery = ref("");
  const selectedData = computed(() => {
    return (select2 == null ? void 0 : select2.selectedOptions) || [];
  });
  const isSelectDisable = computed(() => !!(select2 == null ? void 0 : select2.selectDisabled));
  const isSupportCollapseTags = computed(() => !!(select2 == null ? void 0 : select2.collapseTags));
  const isSupportTagsTooltip = computed(() => !!(select2 == null ? void 0 : select2.collapseTagsTooltip));
  const isValidateError = computed(() => (formItemContext == null ? void 0 : formItemContext.validateState) === "error");
  const isReadOnly = computed(() => {
    if (select2) {
      return lodash.exports.isFunction(select2.filter) ? false : !(typeof select2.filter === "boolean" && select2.filter);
    } else {
      return true;
    }
  });
  const displayInputValue = computed(() => {
    var _a;
    if (select2 == null ? void 0 : select2.selectedOptions) {
      return select2.selectedOptions.length > 1 ? select2.selectedOptions.map((item) => (item == null ? void 0 : item.name) || (item == null ? void 0 : item.value) || "").join(",") : ((_a = select2.selectedOptions[0]) == null ? void 0 : _a.name) || "";
    } else {
      return "";
    }
  });
  const mergeClearable = computed(() => {
    return !isSelectDisable.value && !!(select2 == null ? void 0 : select2.allowClear) && (displayInputValue.value ? true : false);
  });
  const isDisabledTooltip = computed(() => {
    return !isSupportTagsTooltip.value || !!(select2 == null ? void 0 : select2.isOpen);
  });
  const selectionCls = computed(() => {
    return className$1(ns2.e("selection"), {
      [ns2.e("clearable")]: mergeClearable.value,
      [ns2.em("selection", "error")]: isValidateError.value
    });
  });
  const inputCls = computed(() => {
    return className$1(ns2.e("input"), {
      [ns2.em("input", "lg")]: (select2 == null ? void 0 : select2.selectSize) === "lg",
      [ns2.em("input", "sm")]: (select2 == null ? void 0 : select2.selectSize) === "sm"
    });
  });
  const tagSize = computed(() => (select2 == null ? void 0 : select2.selectSize) || "sm");
  const placeholder = computed(() => displayInputValue.value ? "" : (select2 == null ? void 0 : select2.placeholder) || t("placeholder"));
  const isMultiple = computed(() => !!(select2 == null ? void 0 : select2.multiple));
  const handleClear = (e) => {
    e.preventDefault();
    e.stopPropagation();
    select2 == null ? void 0 : select2.handleClear();
  };
  const tagDelete = (data) => {
    if (data && (data.value || data.value === 0)) {
      select2 == null ? void 0 : select2.tagDelete(data);
    }
  };
  const onFocus = (e) => {
    select2 == null ? void 0 : select2.onFocus(e);
  };
  const onBlur = (e) => {
    select2 == null ? void 0 : select2.onBlur(e);
  };
  const queryFilter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const query = e.target.value;
    if (!isReadOnly.value && (select2 == null ? void 0 : select2.debounceQueryFilter)) {
      select2 == null ? void 0 : select2.debounceQueryFilter(query);
    }
  };
  return {
    searchQuery,
    selectedData,
    isSelectDisable,
    isSupportCollapseTags,
    isDisabledTooltip,
    isReadOnly,
    selectionCls,
    inputCls,
    tagSize,
    placeholder,
    isMultiple,
    displayInputValue,
    handleClear,
    tagDelete,
    onFocus,
    onBlur,
    queryFilter
  };
}
var SelectContent = defineComponent({
  name: "SelectContent",
  setup() {
    const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
    const ns2 = useNamespace("select");
    const clearCls = computed(() => ({
      [ns2.e("clear")]: true,
      [ns2.em("clear", "feedback")]: Boolean(formItemContext == null ? void 0 : formItemContext.validateState) && (formItemContext == null ? void 0 : formItemContext.showFeedback)
    }));
    const arrowCls = computed(() => ({
      [ns2.e("arrow")]: true,
      [ns2.em("arrow", "feedback")]: Boolean(formItemContext == null ? void 0 : formItemContext.validateState) && (formItemContext == null ? void 0 : formItemContext.showFeedback)
    }));
    const multipleCls = ns2.e("multiple");
    const multipleInputCls = ns2.em("multiple", "input");
    const {
      searchQuery,
      selectedData,
      isSelectDisable,
      isSupportCollapseTags,
      isDisabledTooltip,
      isReadOnly,
      selectionCls,
      inputCls,
      tagSize,
      placeholder,
      isMultiple,
      displayInputValue,
      handleClear,
      tagDelete,
      onFocus,
      onBlur,
      queryFilter
    } = useSelectContent();
    return () => {
      return createVNode("div", {
        "class": selectionCls.value
      }, [isMultiple.value ? createVNode("div", {
        "class": multipleCls
      }, [!isSupportCollapseTags.value && selectedData.value.length >= 1 && selectedData.value.map((item) => createVNode(Tag, {
        "deletable": true,
        "onTagDelete": withModifiers(() => tagDelete(item), ["prevent", "stop"]),
        "key": item.value,
        "size": tagSize.value
      }, {
        default: () => [item.name]
      })), isSupportCollapseTags.value && selectedData.value.length >= 1 && createVNode(Tag, {
        "deletable": true,
        "onTagDelete": withModifiers(() => tagDelete(selectedData.value[0]), ["prevent", "stop"]),
        "size": tagSize.value
      }, {
        default: () => [selectedData.value[0].name]
      }), isSupportCollapseTags.value && selectedData.value.length > 1 && createVNode(Popover, {
        "trigger": "hover",
        "disabled": isDisabledTooltip.value
      }, {
        default: () => createVNode(Tag, {
          "size": tagSize.value
        }, {
          default: () => [`+${selectedData.value.length - 1}`]
        }),
        content: () => createVNode("div", null, [selectedData.value.map((item, index2) => index2 !== 0 && createVNode(Tag, {
          "deletable": true,
          "onTagDelete": withModifiers(() => tagDelete(item), ["prevent", "stop"]),
          "key": item.value,
          "size": tagSize.value
        }, {
          default: () => [item.name]
        }))])
      }), createVNode("div", {
        "class": multipleInputCls
      }, [createVNode("input", {
        "ref": "input",
        "value": searchQuery.value,
        "type": "text",
        "class": inputCls.value,
        "placeholder": placeholder.value,
        "readonly": isReadOnly.value,
        "disabled": isSelectDisable.value,
        "onInput": queryFilter,
        "onFocus": onFocus,
        "onBlur": onBlur
      }, null)])]) : createVNode("input", {
        "ref": "input",
        "value": displayInputValue.value,
        "type": "text",
        "class": inputCls.value,
        "placeholder": placeholder.value,
        "readonly": isReadOnly.value,
        "disabled": isSelectDisable.value,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "onInput": queryFilter
      }, null), createVNode("span", {
        "onClick": handleClear,
        "class": clearCls.value
      }, [createVNode(AlertCloseIcon, null, null)]), createVNode("span", {
        "class": arrowCls.value
      }, [createVNode(SelectArrowIcon, null, null)])]);
    };
  }
});
function useSelectFunction(props, selectRef) {
  const isSelectFocus = ref(false);
  const inputRef = computed(() => {
    var _a;
    const selectContentRefs = (_a = selectRef.value) == null ? void 0 : _a.$refs;
    return selectContentRefs.input;
  });
  const focus = () => {
    var _a;
    if (!props.disabled) {
      isSelectFocus.value = true;
    }
    (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
  };
  const blur2 = () => {
    var _a;
    if (!props.disabled) {
      isSelectFocus.value = false;
    }
    (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
  };
  return { isSelectFocus, focus, blur: blur2 };
}
var select = "";
var Select = defineComponent({
  name: "DSelect",
  props: selectProps,
  emits: ["toggle-change", "value-change", "update:modelValue", "focus", "blur", "remove-tag", "clear"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DSelect", app);
    const selectRef = ref();
    const {
      isSelectFocus,
      focus,
      blur: blur2
    } = useSelectFunction(props, selectRef);
    const {
      selectDisabled,
      selectSize,
      originRef,
      dropdownRef,
      isOpen,
      selectCls,
      mergeOptions,
      selectedOptions,
      filterQuery,
      emptyText,
      isLoading,
      isShowEmptyText,
      valueChange,
      handleClear,
      updateInjectOptions,
      tagDelete,
      onFocus,
      onBlur,
      debounceQueryFilter,
      isDisabled,
      toggleChange,
      isShowCreateOption
    } = useSelect$2(props, selectRef, ctx2, focus, blur2, isSelectFocus, t);
    const scrollbarNs = useNamespace("scrollbar");
    const ns2 = useNamespace("select");
    const dropdownCls = ns2.e("dropdown");
    const listCls = {
      [ns2.e("dropdown-list")]: true,
      [scrollbarNs.b()]: true
    };
    const dropdownEmptyCls = ns2.em("dropdown", "empty");
    ctx2.expose({
      focus,
      blur: blur2,
      toggleChange
    });
    const isRender = ref(false);
    const position = ref(["bottom-start", "top-start"]);
    const dropdownWidth = ref("0");
    const updateDropdownWidth = () => {
      var _a;
      dropdownWidth.value = ((_a = originRef == null ? void 0 : originRef.value) == null ? void 0 : _a.clientWidth) ? originRef.value.clientWidth + "px" : "100%";
    };
    watch(selectRef, (val) => {
      if (val) {
        originRef.value = val.$el;
        updateDropdownWidth();
      }
    });
    onMounted(() => {
      isRender.value = true;
      updateDropdownWidth();
      window.addEventListener("resize", updateDropdownWidth);
    });
    onUnmounted(() => {
      window.removeEventListener("resize", updateDropdownWidth);
    });
    provide(SELECT_TOKEN, reactive(__spreadProps(__spreadValues({}, toRefs(props)), {
      selectDisabled,
      selectSize,
      isOpen,
      selectedOptions,
      filterQuery,
      valueChange,
      handleClear,
      updateInjectOptions,
      tagDelete,
      onFocus,
      onBlur,
      debounceQueryFilter
    })));
    return () => {
      return createVNode("div", {
        "class": selectCls.value,
        "onClick": withModifiers(() => {
          toggleChange(!isOpen.value);
        }, ["stop"])
      }, [createVNode(SelectContent, {
        "ref": selectRef
      }, null), createVNode(Teleport, {
        "to": "body"
      }, {
        default: () => [createVNode(Transition, {
          "name": "fade"
        }, {
          default: () => [createVNode(FlexibleOverlay, {
            "modelValue": isRender.value,
            "onUpdate:modelValue": ($event) => isRender.value = $event,
            "ref": dropdownRef,
            "origin": originRef.value,
            "align": "start",
            "offset": 4,
            "position": position.value,
            "style": {
              visibility: isOpen.value ? "visible" : "hidden",
              "z-index": isOpen.value ? "var(--b-z-index-dropdown, 1052)" : -1
            }
          }, {
            default: () => {
              var _a, _b, _c, _d;
              return [createVNode("div", {
                "class": dropdownCls,
                "style": {
                  width: `${dropdownWidth.value}`,
                  visibility: isOpen.value ? "visible" : "hidden"
                }
              }, [withDirectives(createVNode("ul", {
                "class": listCls
              }, [isShowCreateOption.value && createVNode(Option, {
                "value": filterQuery.value,
                "name": filterQuery.value,
                "create": true
              }, {
                default: () => [props.multiple ? createVNode(Checkbox, {
                  "modelValue": false,
                  "label": filterQuery.value
                }, null) : filterQuery.value]
              }), ((_a = ctx2.slots) == null ? void 0 : _a.default) && ctx2.slots.default(), !((_b = ctx2.slots) == null ? void 0 : _b.default) && mergeOptions.value.length >= 1 && mergeOptions.value.map((item) => createVNode(Option, {
                "key": item.value,
                "value": item.value,
                "name": item.name,
                "disabled": isDisabled(item)
              }, {
                default: () => [props.multiple ? createVNode(Checkbox, {
                  "modelValue": item._checked,
                  "label": item.name,
                  "disabled": isDisabled(item)
                }, null) : item.name || item.value]
              }))]), [[vShow, !isLoading.value]]), isShowEmptyText.value && createVNode("div", null, [((_c = ctx2.slots) == null ? void 0 : _c.empty) && ctx2.slots.empty(), !((_d = ctx2.slots) == null ? void 0 : _d.empty) && createVNode("p", {
                "class": dropdownEmptyCls
              }, [emptyText.value])])])];
            }
          })]
        })]
      })]);
    };
  }
});
var OptionGroup = defineComponent({
  name: "DOptionGroup",
  props: optionGroupProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("select");
    provide(OPTION_GROUP_TOKEN, reactive(__spreadValues({}, toRefs(props))));
    return () => {
      var _a;
      return createVNode("ul", {
        "class": ns2.e("group")
      }, [createVNode("li", {
        "class": ns2.e("group-title")
      }, [props.label || ""]), createVNode("li", null, [createVNode("ul", {
        "class": ns2.e("group-content")
      }, [((_a = ctx2.slots) == null ? void 0 : _a.default) && ctx2.slots.default()])])]);
    };
  }
});
var SelectInstall = {
  title: "Select \u4E0B\u62C9\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Select.name, Select);
    app.component(Option.name, Option);
    app.component(OptionGroup.name, OptionGroup);
  }
};
const paginationProps = {
  pageSize: {
    type: Number,
    default: 10
  },
  total: {
    type: Number,
    default: 0
  },
  pageSizeOptions: {
    type: Array,
    default: () => [5, 10, 20, 50]
  },
  pageSizeDirection: {
    type: Array,
    default: () => ["centerDown", "centerUp"]
  },
  pageIndex: {
    type: Number,
    default: 1
  },
  maxItems: {
    type: Number,
    default: 10
  },
  preLink: {
    type: String,
    default: ""
  },
  nextLink: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: ""
  },
  canJumpPage: {
    type: Boolean,
    default: false
  },
  canChangePageSize: {
    type: Boolean,
    default: false
  },
  canViewTotal: {
    type: Boolean,
    default: false
  },
  totalItemText: {
    type: String
  },
  goToText: {
    type: String
  },
  showJumpButton: {
    type: Boolean,
    default: false
  },
  showTruePageIndex: {
    type: Boolean,
    default: false
  },
  lite: {
    type: Boolean,
    default: false
  },
  showPageSelector: {
    type: Boolean,
    default: true
  },
  haveConfigMenu: {
    type: Boolean,
    default: false
  },
  autoFixPageIndex: {
    type: Boolean,
    default: true
  },
  autoHide: {
    type: Boolean,
    default: false
  },
  "onUpdate:pageIndex": {
    type: Function
  },
  "onUpdate:pageSize": {
    type: Function
  },
  onPageIndexChange: {
    type: Function
  },
  onPageSizeChange: {
    type: Function
  }
};
const paginationInjectionKey = Symbol("d-pagination");
const handlePages = (cursor, maxItems, totalPages) => {
  const currentPage = cursor;
  const maxPages = maxItems;
  if (maxPages >= totalPages) {
    return [2, totalPages];
  }
  const midPages = maxPages - 2;
  let midStart = currentPage - (midPages >> 1);
  let midEnd = currentPage + (midPages - 1 >> 1);
  if (midStart < 2) {
    midStart = 2;
    midEnd = maxPages - 2;
  }
  if (midEnd > totalPages) {
    midStart = totalPages - maxPages + 3;
    midEnd = totalPages;
  }
  return [midStart, midEnd];
};
function liteSelectOptions(total) {
  return new Array(total || 1).fill(0).map((v, index2) => {
    return {
      name: `${index2 + 1}/${total}`,
      value: index2 + 1
    };
  });
}
var ConfigMenu = defineComponent({
  directives: {
    clickoutside: clickoutsideDirective
  },
  props: {
    currentPageSize: Number,
    pageSizeChange: Function,
    pageSizeOptions: Array
  },
  setup() {
    const paginationConfig = ref(null);
    const isShowConfig = ref(false);
    const closeConfigMenu = (e) => {
      isShowConfig.value = isShowConfig.value ? false : !!e;
    };
    onMounted(() => {
      on(paginationConfig.value, "click", closeConfigMenu);
    });
    onUnmounted(() => {
      off(paginationConfig.value, "click", closeConfigMenu);
    });
    return {
      paginationConfig,
      isShowConfig,
      closeConfigMenu
    };
  },
  render() {
    var _a;
    const {
      closeConfigMenu,
      currentPageSize,
      pageSizeChange,
      pageSizeOptions,
      isShowConfig,
      $slots
    } = this;
    const ns2 = useNamespace("pagination");
    return withDirectives(createVNode("div", {
      "class": ns2.e("config"),
      "ref": "paginationConfig"
    }, [createVNode("div", {
      "class": ns2.e("setup-icon")
    }, [createVNode("i", {
      "class": "icon-setting",
      "style": "font-weight: bold;"
    }, null)]), isShowConfig && createVNode("div", {
      "class": ns2.e("config-container")
    }, [(_a = $slots.default) == null ? void 0 : _a.call($slots), createVNode("div", {
      "class": ns2.e("config-item")
    }, [createVNode("div", {
      "class": "config-item-title"
    }, [createTextVNode("\u6BCF\u9875\u6761\u6570")]), createVNode("div", {
      "class": ns2.e("number")
    }, [pageSizeOptions.map((v) => {
      return createVNode("div", {
        "class": {
          choosed: v === currentPageSize
        },
        "key": v,
        "onClick": pageSizeChange.bind(null, {
          value: v
        })
      }, [v]);
    })])])])]), [[resolveDirective("clickoutside"), closeConfigMenu]]);
  }
});
const jumpPageProps = {
  goToText: String,
  size: {
    type: String,
    default: ""
  },
  pageIndex: Number,
  showJumpButton: Boolean,
  totalPages: Number,
  cursor: Number,
  onChangeCursorEmit: Function
};
var JumpPage = defineComponent({
  props: jumpPageProps,
  emits: ["changeCursorEmit"],
  setup(props, {
    emit
  }) {
    const {
      pageIndex,
      totalPages,
      cursor
    } = toRefs(props);
    const inputNum = ref(pageIndex == null ? void 0 : pageIndex.value);
    watch(() => pageIndex == null ? void 0 : pageIndex.value, (val) => {
      inputNum.value = val;
    });
    let curPage = pageIndex == null ? void 0 : pageIndex.value;
    const jumpPageChange = (currentPage) => {
      curPage = +currentPage;
      inputNum.value = currentPage;
      if (isNaN(currentPage)) {
        setTimeout(() => {
          inputNum.value = pageIndex == null ? void 0 : pageIndex.value;
        }, 300);
      }
    };
    const jump = (e) => {
      if (curPage > (totalPages == null ? void 0 : totalPages.value)) {
        return;
      }
      if ((e === "btn" || e.key === "Enter") && (cursor == null ? void 0 : cursor.value) !== curPage) {
        emit("changeCursorEmit", curPage);
      }
    };
    return {
      inputNum,
      jumpPageChange,
      jump
    };
  },
  render() {
    const {
      goToText,
      size,
      inputNum,
      jumpPageChange,
      jump,
      showJumpButton
    } = this;
    const ns2 = useNamespace("pagination");
    const inputProps2 = {
      class: [ns2.e("input"), size ? ns2.em("input", size) : ""],
      size,
      modelValue: String(inputNum),
      "onUpdate:modelValue": jumpPageChange,
      onKeydown: jump
    };
    return createVNode("div", {
      "class": ns2.e("jump-container")
    }, [
      goToText,
      createVNode(resolveComponent("d-input"), inputProps2, null),
      goToText === "\u8DF3\u81F3" && "\u9875",
      showJumpButton && createVNode("div", {
        "class": [ns2.e("jump-button"), size ? ns2.em("jump-size", size) : ns2.em("jump-size", "default")],
        "onClick": jump.bind(null, "btn"),
        "title": goToText
      }, [createVNode("div", {
        "class": ns2.e("go")
      }, null)])
    ]);
  }
});
function PreLinkIcon() {
  return createVNode("svg", {
    "width": "1em",
    "height": "1.5em",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("polygon", {
    "fill": "#293040",
    "fill-rule": "nonzero",
    "points": "10.7071068 12.2928932 9.29289322 13.7071068           3.58578644 8 9.29289322 2.29289322 10.7071068 3.70710678 6.41421356 8"
  }, null)])]);
}
function NextLinkIcon() {
  return createVNode("svg", {
    "width": "1em",
    "height": "1.5em",
    "viewBox": "0 0 16 16",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("polygon", {
    "fill": "#293040",
    "fill-rule": "nonzero",
    "transform": "translate(8.146447, 8.000000) scale(-1, 1) translate(-8.146447, -8.000000) ",
    "points": "11.7071068 12.2928932 10.2928932 13.7071068           4.58578644 8 10.2928932 2.29289322 11.7071068 3.70710678 7.41421356 8"
  }, null)])]);
}
const pageNumBtnProps = {
  size: {
    type: String,
    default: ""
  },
  preLink: String,
  nextLink: String,
  lite: Boolean,
  cursor: Number,
  maxItems: Number,
  totalPages: Number,
  onChangeCursorEmit: Function,
  showTruePageIndex: Boolean
};
var PageNumBtn = defineComponent({
  props: pageNumBtnProps,
  emits: ["changeCursorEmit"],
  setup(props, {
    emit
  }) {
    const showPageNum = computed(() => handlePages(props.cursor, props.maxItems, props.totalPages));
    const changeCursor = (pageSize) => {
      if (isNaN(pageSize)) {
        return;
      }
      const page = pageSize < 1 ? 1 : pageSize > props.totalPages ? props.totalPages : pageSize | 0;
      emit("changeCursorEmit", page);
    };
    const prevChange = (page) => {
      if (props.cursor > 1) {
        const toPage = page === -1 ? props.cursor - 1 : page;
        emit("changeCursorEmit", toPage);
      }
    };
    const nextChange = (page) => {
      if (props.cursor < props.totalPages) {
        const toPage = page === -1 ? props.cursor + 1 : page;
        emit("changeCursorEmit", toPage);
      }
    };
    return {
      showPageNum,
      changeCursor,
      prevChange,
      nextChange
    };
  },
  render() {
    const {
      size,
      preLink,
      nextLink,
      lite,
      changeCursor,
      cursor,
      showPageNum,
      prevChange,
      totalPages,
      nextChange,
      showTruePageIndex
    } = this;
    const ns2 = useNamespace("pagination");
    return createVNode("ul", {
      "class": [ns2.e("list"), size ? ns2.m(size) : ""]
    }, [createVNode("li", {
      "onClick": prevChange.bind(null, -1),
      "class": {
        [ns2.e("item")]: true,
        disabled: cursor <= 1
      }
    }, [preLink && createVNode("a", {
      "innerHTML": preLink,
      "class": ns2.e("link")
    }, null), !preLink && createVNode("a", {
      "class": ns2.e("link")
    }, [createVNode(PreLinkIcon, null, null)])]), !lite && createVNode(Fragment, null, [
      createVNode("li", {
        "onClick": changeCursor.bind(null, 1),
        "class": {
          [ns2.e("item")]: true,
          active: cursor === 1
        }
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [createTextVNode("1")])]),
      showPageNum[0] > 2 && createVNode("li", {
        "onClick": prevChange.bind(null, showPageNum[0] - 1),
        "class": ns2.e("item")
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [createTextVNode("...")])]),
      (() => {
        const list2 = [];
        for (let i = showPageNum[0]; i <= showPageNum[1]; i++) {
          list2.push(createVNode("li", {
            "onClick": changeCursor.bind(null, i),
            "key": i,
            "class": {
              [ns2.e("item")]: true,
              active: cursor === i
            }
          }, [createVNode("a", {
            "class": ns2.e("link")
          }, [i])]));
        }
        return list2;
      })(),
      showPageNum[1] < totalPages - 1 && createVNode("li", {
        "onClick": nextChange.bind(null, showPageNum[1] + 1),
        "class": ns2.e("item")
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [createTextVNode("...")])]),
      showPageNum[1] < totalPages && createVNode("li", {
        "onClick": changeCursor.bind(null, totalPages),
        "class": {
          [ns2.e("item")]: true,
          active: cursor === totalPages
        }
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [totalPages])]),
      showTruePageIndex && cursor > totalPages && totalPages > 0 && createVNode(Fragment, null, [cursor > totalPages + 1 && createVNode("li", {
        "class": [ns2.e("item"), "disabled"]
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [createTextVNode("...")])]), createVNode("li", {
        "class": [ns2.e("item"), "disabled", "active"]
      }, [createVNode("a", {
        "class": ns2.e("link")
      }, [cursor])])])
    ]), createVNode("li", {
      "onClick": nextChange.bind(null, -1),
      "class": {
        [ns2.e("item")]: true,
        disabled: cursor >= totalPages
      }
    }, [nextLink && createVNode("a", {
      "innerHTML": nextLink,
      "class": ns2.e("link")
    }, null), !nextLink && createVNode("a", {
      "class": ns2.e("link")
    }, [createVNode(NextLinkIcon, null, null)])])]);
  }
});
var PageSize = defineComponent({
  setup() {
    const ns2 = useNamespace("pagination");
    const paginationContext = inject(paginationInjectionKey);
    const iconRotate = ref(0);
    const {
      size,
      currentPageSize,
      pageSizeOptions,
      pageSizeChange,
      t
    } = paginationContext;
    const onDropdownToggle = (e) => {
      iconRotate.value = e ? 180 : 0;
    };
    return () => createVNode(Fragment, null, [createVNode(Dropdown$1, {
      "position": ["bottom", "top"],
      "class": ns2.e("size-list"),
      "onToggle": onDropdownToggle
    }, {
      default: () => createVNode("div", {
        "tabindex": "0",
        "class": [ns2.e("size"), size.value ? ns2.em("size", size.value) : ""]
      }, [createVNode(DIcon, {
        "name": "select-arrow",
        "size": "16px",
        "rotate": iconRotate.value
      }, {
        prefix: () => createVNode("span", null, [currentPageSize.value])
      })]),
      menu: () => createVNode("ul", null, [pageSizeOptions.value.map((item, index2) => createVNode("li", {
        "class": {
          active: item === currentPageSize.value
        },
        "onClick": withModifiers(pageSizeChange.bind(null, {
          value: item
        }), ["stop"]),
        "key": index2
      }, [item]))])
    }), createVNode("span", {
      "style": "margin-right:8px"
    }, [t("perPage"), createTextVNode(",")])]);
  }
});
var pagination = "";
var Pagination = defineComponent({
  name: "DPagination",
  components: {
    ConfigMenu,
    JumpPage,
    PageNumBtn
  },
  props: paginationProps,
  emits: ["pageIndexChange", "pageSizeChange", "update:pageSize", "update:pageIndex"],
  setup(props, {
    emit,
    slots
  }) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DPagination", app);
    const {
      autoHide,
      pageSizeOptions,
      total,
      canChangePageSize,
      lite,
      size,
      showPageSelector,
      canViewTotal,
      totalItemText,
      maxItems,
      preLink,
      nextLink,
      showTruePageIndex,
      canJumpPage,
      goToText,
      pageIndex,
      showJumpButton,
      haveConfigMenu
    } = toRefs(props);
    const ns2 = useNamespace("pagination");
    const totalPages = computed(() => Math.ceil(props.total / props.pageSize));
    const litePageOptions = computed(() => liteSelectOptions(totalPages.value));
    const cursor = computed({
      get() {
        if (!props.showTruePageIndex && props.pageIndex > totalPages.value) {
          emit("update:pageIndex", totalPages.value || 1);
          return totalPages.value || 1;
        }
        return props.pageIndex || 1;
      },
      set(val) {
        emit("update:pageIndex", val);
      }
    });
    const currentPageSize = computed({
      get() {
        return props.pageSize;
      },
      set(val) {
        emit("update:pageSize", val);
      }
    });
    const changeCursorEmit = (val) => {
      cursor.value = val;
      emit("pageIndexChange", val);
    };
    const pageSizeChange = (val) => {
      currentPageSize.value = val.value;
      if (props.autoFixPageIndex) {
        nextTick(() => {
          if (cursor.value > totalPages.value) {
            changeCursorEmit(totalPages.value);
          }
        });
      }
      emit("pageSizeChange", val.value);
    };
    const litePageIndexChange = (page) => {
      changeCursorEmit(page.value);
    };
    provide(paginationInjectionKey, {
      size,
      currentPageSize,
      pageSizeOptions,
      pageSizeChange,
      t
    });
    return () => autoHide.value && Math.min(...pageSizeOptions.value) > total.value ? null : createVNode("div", {
      "class": ns2.b()
    }, [
      canChangePageSize.value && !lite.value && createVNode(PageSize, null, null),
      (!lite.value || lite.value && showPageSelector.value) && canViewTotal.value && createVNode("div", {
        "class": ns2.e("total-size")
      }, [(totalItemText == null ? void 0 : totalItemText.value) || t("totalItemText"), createTextVNode(": "), total.value]),
      lite.value && showPageSelector.value && createVNode(Select, {
        "options": litePageOptions.value,
        "disabled": total.value === 0,
        "modelValue": cursor.value,
        "onValueChange": litePageIndexChange,
        "size": size.value,
        "style": "width:100px"
      }, null),
      createVNode(resolveComponent("page-num-btn"), mergeProps({
        cursor: cursor.value,
        totalPages: totalPages.value,
        size: size.value,
        lite: lite.value,
        maxItems: maxItems.value,
        preLink: preLink.value,
        nextLink: nextLink.value,
        showTruePageIndex: showTruePageIndex.value
      }, {
        "onChangeCursorEmit": changeCursorEmit
      }), null),
      canJumpPage.value && !lite.value && createVNode(resolveComponent("jump-page"), mergeProps({
        goToText: goToText.value || t("goToText"),
        size: size.value,
        pageIndex: pageIndex.value,
        totalPages: totalPages.value,
        cursor: cursor.value,
        showJumpButton: showJumpButton.value
      }, {
        "onChangeCursorEmit": changeCursorEmit
      }), null),
      lite.value && haveConfigMenu.value && createVNode(resolveComponent("config-menu"), {
        currentPageSize: currentPageSize.value,
        pageSizeChange,
        pageSizeOptions: pageSizeOptions.value
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      })
    ]);
  }
});
var PaginationInstall = {
  title: "Pagination \u5206\u9875",
  category: "\u5BFC\u822A",
  status: "100%",
  install(app) {
    app.component(Pagination.name, Pagination);
  }
};
const panelProps = {
  type: {
    type: String,
    default: "default"
  },
  cssClass: {
    type: String,
    default: ""
  },
  isCollapsed: {
    type: Boolean,
    default: false
  },
  beforeToggle: {
    type: Function,
    default: null
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  hasLeftPadding: {
    type: Boolean,
    default: true
  }
};
const option = reactive({});
class Store {
  static getByKey(timeStamp) {
    return option[timeStamp];
  }
  static state() {
    return option;
  }
  static setData(key, value) {
    option[key] = ref(value);
  }
}
var panel = "";
var Panel = defineComponent({
  name: "DPanel",
  props: panelProps,
  emits: ["toggle"],
  setup(props, ctx2) {
    provide("beforeToggle", props.beforeToggle);
    provide("showAnimation", computed(() => props.showAnimation));
    provide("hasLeftPadding", computed(() => props.hasLeftPadding));
    const isCollapsed = ref(props.isCollapsed);
    const type4 = computed(() => props.type);
    const cssClass = computed(() => props.cssClass);
    const timeStamp = new Date().getTime().toString() + Math.random();
    const onToggle = () => {
      ctx2.emit("toggle", Store.getByKey(`isCollapsed[${timeStamp}]`));
    };
    Store.setData(`isCollapsed[${timeStamp}]`, isCollapsed.value);
    return () => {
      var _a, _b;
      return createVNode("div", {
        "onClick": onToggle,
        "class": `devui-panel devui-panel-${type4.value} ${cssClass.value}`
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var PanelHeader = defineComponent({
  name: "DPanelHeader",
  props: panelProps,
  emits: ["toggle"],
  setup(props, ctx2) {
    const beforeToggle = inject("beforeToggle");
    const keys2 = Object.keys(Store.state());
    const key = keys2.pop();
    const isCollapsed = ref(Store.state()[key]);
    const changeFlag = ref();
    let header2 = null;
    const res = ref(isCollapsed.value);
    let changeResult = true;
    const done = () => {
      res.value = !res.value;
      if (!changeFlag.value) {
        if (res.value) {
          Store.setData(`${key}`, res.value);
          isCollapsed.value = res.value;
          ctx2.emit("toggle", res.value);
        }
        return;
      }
      if (res.value !== void 0) {
        Store.setData(`${key}`, res.value);
        isCollapsed.value = res.value;
        ctx2.emit("toggle", res.value);
      }
    };
    const canToggle = async () => {
      if (beforeToggle) {
        const tmpRes = beforeToggle(isCollapsed, done);
        if (typeof tmpRes !== "undefined") {
          if (tmpRes instanceof Promise) {
            changeResult = await tmpRes;
          } else {
            changeResult = tmpRes;
          }
        } else {
          changeResult = true;
        }
      }
      return changeResult;
    };
    canToggle().then((val) => changeFlag.value = val);
    const toggleBody = () => {
      canToggle().then((val) => {
        changeFlag.value = val;
        if (!val) {
          if (!isCollapsed.value) {
            Store.setData(`${key}`, !isCollapsed.value);
            isCollapsed.value = !isCollapsed.value;
            ctx2.emit("toggle", isCollapsed.value);
          }
          return;
        }
        if (isCollapsed.value !== void 0) {
          Store.setData(`${key}`, !isCollapsed.value);
          isCollapsed.value = !isCollapsed.value;
          ctx2.emit("toggle", isCollapsed.value);
        }
      });
    };
    return () => {
      var _a, _b;
      if (ctx2.slots.default) {
        header2 = createVNode("div", {
          "class": "devui-panel-heading",
          "onClick": toggleBody,
          "style": {
            cursor: changeFlag.value ? "pointer" : "auto"
          }
        }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
      }
      return header2;
    };
  }
});
var PanelBody = defineComponent({
  name: "DPanelBody",
  props: panelProps,
  setup(props, ctx2) {
    const animationName = inject("showAnimation");
    const hasLeftPadding = inject("hasLeftPadding");
    const keys2 = Object.keys(Store.state());
    const key = keys2.pop();
    const isCollapsed = Store.state();
    const bodyEl = ref();
    onMounted(() => {
      if (bodyEl.value) {
        const dom = bodyEl.value;
        if (isCollapsed[key]) {
          dom.style.height = `${dom.offsetHeight}px`;
        }
      }
    });
    const enter = (element) => {
      const el = element;
      el.style.height = "";
      const height = el.offsetHeight;
      el.style.height = "0px";
      el.offsetHeight;
      el.style.height = `${height}px`;
    };
    const leave = (element) => {
      const el = element;
      el.style.height = "0px";
    };
    return () => {
      return createVNode("div", {
        "class": `devui-panel devui-panel-${props.type} ${props.cssClass}`
      }, [createVNode(Transition, {
        "name": animationName.value ? "devui-panel" : "",
        "onEnter": enter,
        "onLeave": leave
      }, {
        default: () => {
          var _a, _b;
          return [isCollapsed[key] === void 0 || isCollapsed[key] ? createVNode("div", {
            "ref": bodyEl,
            "class": `devui-panel-body ${isCollapsed[key] !== void 0 ? "devui-panel-body-collapse" : ""} ${!hasLeftPadding.value ? "no-left-padding" : ""}`
          }, [createVNode("div", {
            "class": "devui-panel-content"
          }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])]) : null];
        }
      })]);
    };
  }
});
var PanelFooter = defineComponent({
  name: "DPanelFooter",
  setup(props, ctx2) {
    return () => {
      var _a, _b;
      const footerContent = ctx2.slots.default ? createVNode("div", {
        "class": "devui-panel-footer"
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]) : null;
      return footerContent;
    };
  }
});
var PanelInstall = {
  title: "Panel \u9762\u677F",
  category: "\u901A\u7528",
  status: "100%",
  deprecated: {
    value: true,
    reason: "Panel \u662F\u6298\u53E0\u9762\u677F\u7684\u4E00\u79CD\u7279\u6B8A\u5F62\u6001\uFF0C\u5E94\u8BE5\u4F7F\u7528\u66F4\u901A\u7528\u7684 Collapse \u66FF\u4EE3\u3002"
  },
  install(app) {
    app.component(Panel.name, Panel);
    app.component(PanelHeader.name, PanelHeader);
    app.component(PanelBody.name, PanelBody);
    app.component(PanelFooter.name, PanelFooter);
  }
};
const progressProps = {
  height: {
    type: String,
    default: "20px"
  },
  percentage: {
    type: Number,
    default: 0
  },
  percentageText: {
    type: String,
    default: ""
  },
  barBgColor: {
    type: String,
    default: "#5170ff"
  },
  isCircle: {
    type: Boolean,
    default: false
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  showContent: {
    type: Boolean,
    default: true
  },
  percentageTextPlacement: {
    type: String,
    default: "inside"
  },
  percentageTextColor: {
    type: String,
    default: ""
  }
};
var progress = "";
var Progress = defineComponent({
  name: "DProgress",
  props: progressProps,
  setup(props) {
    const {
      height,
      percentage,
      percentageText,
      percentageTextPlacement,
      percentageTextColor,
      barBgColor,
      isCircle,
      strokeWidth,
      showContent
    } = toRefs(props);
    const normalPercentage = ref(0);
    effect(() => {
      normalPercentage.value = middleNum(percentage.value);
    });
    const data = reactive({
      pathString: "",
      trailPath: null,
      strokePath: null
    });
    const setCircleProgress = () => {
      if (!isCircle) {
        return;
      }
      const radius = 50 - strokeWidth.value / 2;
      const beginPositionY = -radius;
      const endPositionY = radius * -2;
      data.pathString = `M 50,50 m 0,${beginPositionY}
      a ${radius},${radius} 0 1 1 0,${-endPositionY}
      a ${radius},${radius} 0 1 1 0,${endPositionY}`;
      const len = Math.PI * 2 * radius;
      data.trailPath = {
        stroke: "var(--b-dividing-line, #dfe1e6)",
        strokeDasharray: `${len}px ${len}px`,
        strokeDashoffset: `0`,
        transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s"
      };
      data.strokePath = {
        stroke: barBgColor || null,
        strokeDasharray: `${normalPercentage.value / 100 * len}px ${len}px`,
        strokeDashoffset: `0`,
        transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s"
      };
    };
    setCircleProgress();
    watch([height, normalPercentage, percentageText, percentageTextPlacement, percentageTextColor, barBgColor, isCircle, strokeWidth, showContent], () => {
      setCircleProgress();
    });
    return {
      data,
      normalPercentage
    };
  },
  render() {
    var _a;
    const {
      height,
      normalPercentage,
      percentageText,
      percentageTextPlacement,
      percentageTextColor,
      barBgColor,
      isCircle,
      strokeWidth,
      showContent,
      data,
      $slots
    } = this;
    const ns2 = useNamespace("progress");
    const isOutside = percentageTextPlacement === "outside";
    const isInsideBg = percentageTextPlacement === "insideBg";
    const createPercentageText = () => {
      return createVNode("span", {
        "style": {
          lineHeight: height,
          color: percentageTextColor
        }
      }, [percentageText]);
    };
    const progressLine = createVNode("div", {
      "class": ns2.e("content")
    }, [createVNode("div", {
      "class": ns2.e("line"),
      "style": {
        height,
        borderRadius: height
      }
    }, [createVNode("div", {
      "class": [ns2.e("bar"), percentageTextPlacement],
      "style": {
        height,
        borderRadius: height,
        width: `${normalPercentage}%`,
        backgroundColor: barBgColor
      }
    }, [!isOutside && !isInsideBg ? createPercentageText() : null]), isInsideBg ? createPercentageText() : null]), isOutside && !!percentageText ? createPercentageText() : null]);
    const textElement = createVNode("span", {
      "class": ns2.e("circle-text"),
      "style": {
        color: percentageTextColor
      }
    }, [normalPercentage, createTextVNode("%")]);
    const progressCircle = createVNode("div", {
      "class": ns2.e("circle")
    }, [createVNode("svg", {
      "class": ns2.e("circle"),
      "viewBox": "0 0 100 100"
    }, [createVNode("path", {
      "fill-opacity": "0",
      "stroke-width": strokeWidth,
      "style": data.trailPath,
      "d": data.pathString
    }, null), createVNode("path", {
      "d": data.pathString,
      "stroke-linecap": "round",
      "fill-opacity": "0",
      "stroke": barBgColor,
      "stroke-width": normalPercentage ? strokeWidth : 0,
      "style": data.strokePath
    }, null)]), showContent && ((_a = $slots.default) == null ? void 0 : _a.call($slots)), showContent && !$slots.default && textElement]);
    return createVNode("div", {
      "class": ns2.b()
    }, [!isCircle ? progressLine : progressCircle]);
  }
});
var ProgressInstall = {
  title: "Progress \u8FDB\u5EA6\u6761",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Progress.name, Progress);
  }
};
const DEFAULT_AXIS_CONFIGS = {
  tickWidth: 10,
  spaceBetweenLabelsAxis: 20,
  xAxisLabel: "\u7D27\u6025\u5EA6",
  yAxisLabel: "\u91CD\u8981\u5EA6",
  xAxisRange: {
    min: 0,
    max: 100,
    step: 10
  },
  yAxisRange: {
    min: 0,
    max: 50,
    step: 5
  },
  originPosition: {
    left: 30,
    bottom: 30
  },
  axisMargin: 35,
  xWeight: 1,
  yWeight: 1
};
const DEFAULT_VIEW_CONFIGS = {
  height: 900,
  width: 950
};
const AXIS_TITLE_SPACE = 15;
const quadrantDiagramProps = {
  diagramId: {
    type: String,
    default: "1"
  },
  axisConfigs: {
    type: Object,
    default: DEFAULT_AXIS_CONFIGS
  },
  view: {
    type: Object,
    default: DEFAULT_VIEW_CONFIGS
  }
};
const quadrantDiagramAxisProps = {
  diagramId: {
    type: String
  },
  axisConfigs: {
    type: Object
  },
  view: {
    type: Object
  }
};
var index$1 = "";
var DQuadrantDiagramAxis = defineComponent({
  name: "DQuadrantDiagramAxis",
  props: quadrantDiagramAxisProps,
  setup(props) {
    const {
      diagramId,
      view,
      axisConfigs
    } = toRefs(props);
    const AXIS_COLOR = ref("#0000ff");
    const AXIS_LABEL_COLOR = ref("#ff0000");
    const quadrantAxis = ref();
    const context = ref();
    const axisInnerAttr = reactive({
      axisOrigin: {
        x: 0,
        y: 0
      },
      axisTop: 0,
      axisRight: 0,
      axisWidth: 0,
      axisHeight: 0,
      yAxisTicksNum: 0,
      xAxisTicksNum: 0,
      xTickSpacing: 0,
      yTickSpacing: 0
    });
    const axisConfigsVal = axisConfigs == null ? void 0 : axisConfigs.value;
    const initAxisData = () => {
      quadrantAxis.value = document.querySelector("#devui-quadrant-axis-" + (diagramId == null ? void 0 : diagramId.value));
    };
    const setAxisData = () => {
      context.value = quadrantAxis.value.getContext("2d");
      axisInnerAttr.axisOrigin = axisConfigsVal.axisOrigin;
      axisInnerAttr.axisTop = axisConfigsVal.axisTop;
      axisInnerAttr.axisRight = axisConfigsVal.axisRight;
      axisInnerAttr.axisWidth = axisConfigsVal.axisWidth;
      axisInnerAttr.axisHeight = axisConfigsVal.axisHeight;
      axisInnerAttr.yAxisTicksNum = axisConfigsVal.yAxisTicksNum;
      axisInnerAttr.xAxisTicksNum = axisConfigsVal.xAxisTicksNum;
      axisInnerAttr.xTickSpacing = axisConfigsVal.xTickSpacing;
      axisInnerAttr.yTickSpacing = axisConfigsVal.yTickSpacing;
    };
    const drawYAxis = () => {
      const axisMargin = axisConfigsVal.axisMargin || 0;
      context.value.beginPath();
      context.value.moveTo(axisInnerAttr.axisOrigin.x, axisInnerAttr.axisOrigin.y);
      context.value.lineTo(axisInnerAttr.axisOrigin.x, axisInnerAttr.axisTop - axisMargin);
      context.value.stroke();
      context.value.moveTo(axisInnerAttr.axisOrigin.x, axisInnerAttr.axisTop - axisMargin);
      context.value.lineTo(axisInnerAttr.axisOrigin.x + 5, axisInnerAttr.axisTop - axisMargin + 10);
      context.value.lineTo(axisInnerAttr.axisOrigin.x - 5, axisInnerAttr.axisTop - axisMargin + 10);
      context.value.fill();
    };
    const drawXAxis = () => {
      const axisMargin = axisConfigsVal.axisMargin || 0;
      context.value.beginPath();
      context.value.moveTo(axisInnerAttr.axisOrigin.x, axisInnerAttr.axisOrigin.y);
      context.value.lineTo(axisInnerAttr.axisRight + axisMargin - 10, axisInnerAttr.axisOrigin.y);
      context.value.stroke();
      context.value.moveTo(axisInnerAttr.axisRight + axisMargin, axisInnerAttr.axisOrigin.y);
      context.value.lineTo(axisInnerAttr.axisRight + axisMargin - 10, axisInnerAttr.axisOrigin.y + 5);
      context.value.lineTo(axisInnerAttr.axisRight + axisMargin - 10, axisInnerAttr.axisOrigin.y - 5);
      context.value.fill();
    };
    const drawXAxisTicks = () => {
      var _a;
      let deltaY = 0;
      for (let i = 1; i < axisInnerAttr.xAxisTicksNum; i++) {
        context.value.beginPath();
        if (i % (((_a = axisConfigsVal.xAxisRange) == null ? void 0 : _a.step) || 0) === 0) {
          deltaY = axisConfigsVal.tickWidth || 0;
        } else {
          deltaY = (axisConfigsVal.tickWidth || 0) / 2;
        }
        context.value.moveTo(axisInnerAttr.axisOrigin.x + i * axisInnerAttr.xTickSpacing, axisInnerAttr.axisOrigin.y - deltaY);
        context.value.lineTo(axisInnerAttr.axisOrigin.x + i * axisInnerAttr.xTickSpacing, axisInnerAttr.axisOrigin.y + deltaY);
        context.value.stroke();
      }
    };
    const drawYAxisTicks = () => {
      var _a;
      let deltaX = 0;
      for (let i = 1; i < axisInnerAttr.yAxisTicksNum; i++) {
        context.value.beginPath();
        if (i % (((_a = axisConfigsVal.xAxisRange) == null ? void 0 : _a.step) || 0) === 0) {
          deltaX = axisConfigsVal.tickWidth || 0;
        } else {
          deltaX = (axisConfigsVal.tickWidth || 0) / 2;
        }
        context.value.moveTo(axisInnerAttr.axisOrigin.x - deltaX, axisInnerAttr.axisOrigin.y - i * axisInnerAttr.yTickSpacing);
        context.value.lineTo(axisInnerAttr.axisOrigin.x + deltaX, axisInnerAttr.axisOrigin.y - i * axisInnerAttr.yTickSpacing);
        context.value.stroke();
      }
    };
    const drawAxis = () => {
      context.value.save();
      context.value.fillStyle = AXIS_COLOR.value;
      context.value.strokeStyle = AXIS_COLOR.value;
      drawXAxis();
      drawYAxis();
      context.value.lineWidth = 0.5;
      drawXAxisTicks();
      drawYAxisTicks();
      context.value.restore();
    };
    const drawXTicksLabels = () => {
      var _a;
      context.value.textAlign = "center";
      context.value.textBaseline = "top";
      for (let i = 0; i <= axisInnerAttr.xAxisTicksNum; i++) {
        if (i % (((_a = axisConfigsVal.xAxisRange) == null ? void 0 : _a.step) || 0) === 0) {
          context.value.fillText(i, axisInnerAttr.axisOrigin.x + i * axisInnerAttr.xTickSpacing, axisInnerAttr.axisOrigin.y + (axisConfigsVal.spaceBetweenLabelsAxis || 0));
        }
      }
    };
    const drawYTicksLabels = () => {
      var _a;
      context.value.textAlign = "center";
      context.value.textBaseline = "middle";
      for (let i = 0; i <= axisInnerAttr.yAxisTicksNum; i++) {
        if (i % (((_a = axisConfigsVal.xAxisRange) == null ? void 0 : _a.step) || 0) === 0) {
          context.value.fillText(i, axisInnerAttr.axisOrigin.x - (axisConfigsVal.spaceBetweenLabelsAxis || 0), axisInnerAttr.axisOrigin.y - i * axisInnerAttr.yTickSpacing);
        }
      }
    };
    const rotateLabel = (name, x, y) => {
      for (let i = 0; i < name.length; i++) {
        const str = name.slice(i, i + 1).toString();
        if (str.match(/[A-Za-z0-9]/)) {
          context.value.save();
          context.value.translate(x, y);
          context.value.rotate(Math.PI / 180 * 90);
          context.value.textBaseline = "bottom";
          context.value.fillText(str, 0, 0);
          context.value.restore();
          y += context.value.measureText(str).width;
        } else if (str.match(/[\u4E00-\u9FA5]/)) {
          context.value.save();
          context.value.textBaseline = "top";
          context.value.fillText(str, x, y);
          context.value.restore();
          y += context.value.measureText(str).width;
        }
      }
    };
    const drawAxisTitle = () => {
      context.value.font = "12px Microsoft YaHei";
      context.value.textAlign = "left";
      context.value.fillStyle = AXIS_LABEL_COLOR.value;
      const xLabelWidth = context.value.measureText(axisConfigsVal.xAxisLabel).width;
      rotateLabel(axisConfigsVal.xAxisLabel || "", axisInnerAttr.axisRight + (axisConfigsVal.axisMargin || 0) / 2, axisInnerAttr.axisOrigin.y - xLabelWidth - AXIS_TITLE_SPACE);
      context.value.fillText(axisConfigsVal.yAxisLabel, axisInnerAttr.axisOrigin.x + AXIS_TITLE_SPACE, axisInnerAttr.axisTop - (axisConfigsVal.axisMargin || 0) / 2);
    };
    const drawAxisLabels = () => {
      context.value.save();
      context.value.fillStyle = AXIS_LABEL_COLOR.value;
      drawXTicksLabels();
      drawYTicksLabels();
      context.value.restore();
      drawAxisTitle();
    };
    const resetAxis = lodash.exports.debounce(() => {
      initAxisData();
      setAxisData();
      drawAxis();
      drawAxisLabels();
    }, 200);
    onMounted(() => {
      resetAxis();
    });
    watch(view == null ? void 0 : view.value, () => {
      resetAxis();
    });
  },
  render() {
    const {
      diagramId,
      view
    } = this;
    return createVNode("div", null, [createVNode("canvas", {
      "id": "devui-quadrant-axis-" + diagramId,
      "height": view == null ? void 0 : view.height,
      "width": view == null ? void 0 : view.width
    }, null)]);
  }
});
var QuadrantDiagram = defineComponent({
  name: "DQuadrantDiagram",
  props: quadrantDiagramProps,
  setup(props) {
    const {
      diagramId,
      axisConfigs,
      view
    } = toRefs(props);
    const calAxisConfig = reactive({
      axisOrigin: {
        x: null,
        y: null
      },
      axisTop: null,
      axisRight: null,
      axisWidth: null,
      axisHeight: null,
      yAxisTicksNum: null,
      xAxisTicksNum: null,
      xTickSpacing: null,
      yTickSpacing: null
    });
    const initAxisData = () => {
      var _a, _b, _c, _d, _e, _f, _g;
      const axisConfigKeys = Object.keys(DEFAULT_AXIS_CONFIGS);
      for (let i = 0; i < axisConfigKeys.length; i++) {
        const curKey = axisConfigKeys[i];
        if (calAxisConfig[curKey] === void 0) {
          calAxisConfig[curKey] = DEFAULT_AXIS_CONFIGS[curKey];
        }
      }
      calAxisConfig.axisOrigin = {
        x: (_a = axisConfigs.value.originPosition) == null ? void 0 : _a.left,
        y: view.value.height - (((_c = (_b = axisConfigs.value) == null ? void 0 : _b.originPosition) == null ? void 0 : _c.bottom) || 0)
      };
      calAxisConfig.axisTop = axisConfigs.value.axisMargin;
      calAxisConfig.axisRight = view.value.width - (axisConfigs.value.axisMargin || 0);
      calAxisConfig.axisWidth = calAxisConfig.axisRight - (calAxisConfig.axisOrigin.x || 0);
      calAxisConfig.axisHeight = (calAxisConfig.axisOrigin.y || 0) - (calAxisConfig.axisTop || 0);
      calAxisConfig.yAxisTicksNum = (((_d = axisConfigs.value.yAxisRange) == null ? void 0 : _d.max) || 0) - (((_e = axisConfigs.value.yAxisRange) == null ? void 0 : _e.min) || 0);
      calAxisConfig.xAxisTicksNum = (((_f = axisConfigs.value.xAxisRange) == null ? void 0 : _f.max) || 0) - (((_g = axisConfigs.value.xAxisRange) == null ? void 0 : _g.min) || 0);
      calAxisConfig.xTickSpacing = calAxisConfig.axisWidth / calAxisConfig.xAxisTicksNum;
      calAxisConfig.yTickSpacing = calAxisConfig.axisHeight / calAxisConfig.yAxisTicksNum;
    };
    initAxisData();
    watch(view.value, () => {
      initAxisData();
    });
    return {
      diagramId,
      calAxisConfig
    };
  },
  render() {
    const {
      diagramId,
      calAxisConfig,
      view
    } = this;
    return createVNode("div", {
      "class": "devui-quadrant-diagram",
      "id": diagramId
    }, [createVNode(DQuadrantDiagramAxis, {
      "diagramId": diagramId,
      "axisConfigs": calAxisConfig,
      "view": view
    }, null)]);
  }
});
var QuadrantDiagramInstall = {
  title: "QuadrantDiagram \u8C61\u9650\u56FE",
  category: "\u6570\u636E\u5C55\u793A",
  status: "10%",
  install(app) {
    app.component(QuadrantDiagram.name, QuadrantDiagram);
  }
};
const radioCommonProps = {
  modelValue: {
    type: [Number, String, Boolean],
    default: null
  },
  name: {
    type: String,
    default: null
  },
  beforeChange: {
    type: Function,
    default: null
  },
  disabled: {
    type: Boolean,
    default: false
  },
  size: {
    type: String
  }
};
const radioProps = __spreadProps(__spreadValues({}, radioCommonProps), {
  value: {
    type: [Number, String, Boolean],
    required: true,
    default: null
  },
  border: {
    type: Boolean,
    default: false
  }
});
const radioGroupProps = __spreadProps(__spreadValues({}, radioCommonProps), {
  values: {
    type: Array,
    default: null
  },
  direction: {
    type: String,
    default: "column"
  },
  border: {
    type: Boolean,
    default: false
  },
  fill: {
    type: String,
    default: ""
  },
  textColor: {
    type: String,
    default: ""
  }
});
const radioGroupInjectionKey = Symbol("DRadioGroup");
function useRadio(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const radioGroupConf = inject(radioGroupInjectionKey, null);
  const isDisabled = computed(() => {
    return (formContext == null ? void 0 : formContext.disabled) || props.disabled || (radioGroupConf == null ? void 0 : radioGroupConf.disabled.value);
  });
  const isChecked = computed(() => {
    const _value = radioGroupConf ? radioGroupConf.modelValue.value : props.modelValue;
    return props.value === _value;
  });
  const radioName = computed(() => {
    return radioGroupConf ? radioGroupConf.name.value : props.name || void 0;
  });
  const judgeCanChange = (_value) => {
    const beforeChange = props.beforeChange || (radioGroupConf ? radioGroupConf.beforeChange : null);
    let flag = Promise.resolve(true);
    if (beforeChange) {
      const canChange = beforeChange(_value);
      if (typeof canChange === "undefined") {
        return flag;
      }
      if (typeof canChange === "boolean") {
        flag = Promise.resolve(canChange);
      } else {
        flag = canChange;
      }
    }
    return flag;
  };
  const handleChange = async (event) => {
    const _value = props.value;
    const canChange = await judgeCanChange(_value);
    if (!canChange) {
      event.preventDefault();
      return;
    }
    radioGroupConf == null ? void 0 : radioGroupConf.emitChange(_value);
    ctx2.emit("update:modelValue", _value);
    ctx2.emit("change", _value);
  };
  const border = computed(() => {
    return (radioGroupConf == null ? void 0 : radioGroupConf.border.value) || props.border;
  });
  const size = computed(() => {
    return props.size || (radioGroupConf == null ? void 0 : radioGroupConf.size.value) || (formContext == null ? void 0 : formContext.size) || "md";
  });
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  });
  return {
    isChecked,
    radioName,
    isDisabled,
    handleChange,
    border,
    size
  };
}
function useRadioGroup(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const formItemContext = inject(FORM_ITEM_TOKEN, void 0);
  const emitChange = (radioValue) => {
    ctx2.emit("update:modelValue", radioValue);
    ctx2.emit("change", radioValue);
  };
  watch(() => props.modelValue, () => {
    formItemContext == null ? void 0 : formItemContext.validate("change").catch((err) => console.warn(err));
  });
  const radioGroupSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "");
  provide(radioGroupInjectionKey, {
    modelValue: toRef(props, "modelValue"),
    name: toRef(props, "name"),
    disabled: toRef(props, "disabled"),
    border: toRef(props, "border"),
    size: radioGroupSize,
    beforeChange: props.beforeChange,
    emitChange,
    fill: toRef(props, "fill"),
    textColor: toRef(props, "textColor")
  });
}
function useRadioButton() {
  const radioGroupConf = inject(radioGroupInjectionKey, null);
  const mergedTextColor = computed(() => {
    var _a;
    return (_a = radioGroupConf == null ? void 0 : radioGroupConf.textColor.value) != null ? _a : void 0;
  });
  const mergedColor = computed(() => {
    var _a;
    return (_a = radioGroupConf == null ? void 0 : radioGroupConf.fill.value) != null ? _a : void 0;
  });
  return {
    mergedTextColor,
    mergedColor
  };
}
var radio = "";
var Radio = defineComponent({
  name: "DRadio",
  props: radioProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("radio");
    const {
      isChecked,
      radioName,
      isDisabled,
      handleChange,
      border,
      size
    } = useRadio(props, ctx2);
    return () => {
      var _a, _b;
      const radioCls = {
        [ns2.e("wrapper")]: true
      };
      const labelCls = {
        active: isChecked.value,
        disabled: isDisabled.value,
        [ns2.b()]: true,
        [ns2.m("bordered")]: border.value,
        [ns2.m(size.value)]: size.value
      };
      return createVNode("div", {
        "class": radioCls
      }, [createVNode("label", {
        "class": labelCls
      }, [createVNode("input", {
        "type": "radio",
        "name": radioName.value,
        "class": ns2.e("input"),
        "disabled": isDisabled.value,
        "onChange": handleChange,
        "value": props.value,
        "checked": isChecked.value
      }, null), createVNode("span", {
        "class": ns2.e("material")
      }, [createVNode("svg", {
        "height": "100%",
        "width": "100%",
        "viewBox": "0 0 1024 1024",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("circle", {
        "class": {
          [ns2.e("material-outer")]: true,
          disabled: isDisabled.value
        },
        "cx": "512",
        "cy": "512",
        "r": "486.5",
        "stroke-width": "51"
      }, null), createVNode("circle", {
        "class": {
          [ns2.e("material-inner")]: true,
          disabled: isDisabled.value
        },
        "cx": "512",
        "fill-rule": "nonzero",
        "cy": "512",
        "r": "320"
      }, null)])]), createVNode("span", {
        "class": ns2.e("label")
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])])]);
    };
  }
});
var radioGroup = "";
function _isSlot$4(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var RadioGroup = defineComponent({
  name: "DRadioGroup",
  props: radioGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("radio-group");
    useRadioGroup(props, ctx2);
    return () => {
      const getContent = () => {
        const defaultSlot = ctx2.slots.default;
        if (defaultSlot) {
          return defaultSlot();
        } else if (Array.isArray(props.values)) {
          return props.values.map((item) => {
            return createVNode(Radio, {
              "key": item,
              "value": item
            }, _isSlot$4(item) ? item : {
              default: () => [item]
            });
          });
        } else {
          return "";
        }
      };
      return createVNode("div", {
        "class": [ns2.b(), {
          "is-row": props.direction === "row",
          "is-column": props.direction === "column"
        }]
      }, [getContent()]);
    };
  }
});
var radioButton = "";
var RadioButton = defineComponent({
  name: "DRadioButton",
  props: radioProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("radio-button");
    const {
      isChecked,
      radioName,
      isDisabled,
      handleChange,
      size
    } = useRadio(props, ctx2);
    const {
      mergedTextColor,
      mergedColor
    } = useRadioButton();
    return () => {
      var _a, _b;
      const labelCls = {
        active: isChecked.value,
        disabled: isDisabled.value,
        [ns2.b()]: true,
        [ns2.m(size.value)]: true
      };
      const spanStyle = [`border-color:${isChecked.value && mergedColor.value ? mergedColor.value : ""}`, `background-color:${isChecked.value && mergedColor.value ? mergedColor.value : ""}`, `color:${isChecked.value && mergedTextColor.value ? mergedTextColor.value : ""}`];
      return createVNode("label", {
        "class": labelCls,
        "style": spanStyle
      }, [createVNode("input", {
        "type": "radio",
        "name": radioName.value,
        "class": ns2.e("input"),
        "disabled": isDisabled.value,
        "onChange": handleChange,
        "value": props.value,
        "checked": isChecked.value
      }, null), createVNode("span", {
        "class": ns2.e("label")
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)])]);
    };
  }
});
var RadioInstall = {
  title: "Radio \u5355\u9009\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Radio.name, Radio);
    app.component(RadioGroup.name, RadioGroup);
    app.component(RadioButton.name, RadioButton);
  }
};
const rateProps = {
  modelValue: {
    type: Number,
    default: 0
  },
  read: {
    type: Boolean,
    default: false
  },
  count: {
    type: Number,
    default: 5
  },
  type: {
    type: String,
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    default: ""
  },
  character: {
    type: String,
    default: ""
  },
  allowHalf: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: void 0
  },
  onTouched: {
    type: Function,
    default: void 0
  }
};
var rate = "";
var Rate = defineComponent({
  name: "DRate",
  props: rateProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const totalLevelArray = ref([]);
    const chooseValue = ref(0);
    const setChange = (start, end, width) => {
      for (let i = start; i < end; i++) {
        totalLevelArray.value[i]["width"] = width;
      }
    };
    const initRating = () => {
      chooseValue.value = props.modelValue;
      const halfStar = chooseValue.value % 1;
      const intCurrentLevel = Math.floor(chooseValue.value);
      setChange(0, intCurrentLevel, "100%");
      if (halfStar > 0) {
        totalLevelArray.value[intCurrentLevel]["width"] = halfStar * 100 + "%";
        setChange(intCurrentLevel + 1, props.count, "0");
      } else {
        setChange(intCurrentLevel, props.count, "0");
      }
    };
    const initLevelArray = () => {
      totalLevelArray.value = [];
      for (let i = 0; i < props.count; i++) {
        totalLevelArray.value.push({
          width: "0"
        });
      }
    };
    watch([() => props.modelValue, () => props.count], () => {
      initLevelArray();
      initRating();
    });
    onMounted(() => {
      initLevelArray();
      initRating();
    });
    const isSemiSelected = (e) => {
      const target = e.target;
      return props.allowHalf && e.offsetX * 2 <= target.clientWidth;
    };
    const hoverToggle = (e, index2) => {
      if (props.read) {
        return;
      }
      setChange(0, index2 + 1, "100%");
      const width = isSemiSelected(e) ? "50%" : "100%";
      setChange(index2, index2 + 1, width);
      setChange(index2 + 1, props.count, "0");
    };
    const onMouseleave = () => {
      initRating();
    };
    const selectValue = (e, index2) => {
      if (props.read) {
        return;
      }
      setChange(0, index2, "100%");
      if (isSemiSelected(e)) {
        setChange(index2, index2 + 1, "50%");
        chooseValue.value = index2 - 0.5;
      } else {
        setChange(index2, index2 + 1, "100%");
        chooseValue.value = index2;
      }
      setChange(index2 + 1, props.count, "0");
      props.onChange && props.onChange(chooseValue.value + 1);
      props.onTouched && props.onTouched();
      ctx2.emit("update:modelValue", chooseValue.value + 1);
    };
    return {
      totalLevelArray,
      chooseValue,
      hoverToggle,
      selectValue,
      onMouseleave
    };
  },
  render() {
    const {
      totalLevelArray,
      icon: icon2,
      character,
      read,
      type: type4,
      color: color2,
      hoverToggle,
      selectValue,
      onMouseleave
    } = this;
    const ns2 = useNamespace("rate");
    return createVNode("div", {
      "class": ns2.b(),
      "onMouseleave": onMouseleave,
      "style": `--star-color: ${color2}`
    }, [totalLevelArray.map((item, index2) => createVNode("div", {
      "class": [ns2.m("align"), ns2.m("pointer"), read ? ns2.m("only-read") : ""],
      "key": index2,
      "onMouseover": (e) => hoverToggle(e, index2),
      "onClick": (e) => selectValue(e, index2)
    }, [icon2 && !character && createVNode("span", {
      "class": ns2.e("color")
    }, [createVNode(resolveComponent("d-icon"), {
      "name": icon2
    }, null)]), character && !icon2 && createVNode("span", {
      "class": ns2.e("color")
    }, [character]), !icon2 && !character && createVNode("span", {
      "class": ns2.e("color")
    }, [createVNode("svg", {
      "width": "16px",
      "height": "16px",
      "viewBox": "0 0 16 16",
      "version": "1.1",
      "xmlns": "http://www.w3.org/2000/svg",
      "xmlns-xlink": "http://www.w3.org/1999/xlink"
    }, [createVNode("g", {
      "stroke": "none",
      "stroke-width": "1",
      "fill": "none",
      "fill-rule": "evenodd"
    }, [createVNode("g", {
      "fill": "#E3E5E9",
      "id": "Mask"
    }, [createVNode("polygon", {
      "points": "8 12.7603585 3.67376208 14.3147912 3.81523437 9.71994835                       1 6.0857977 5.41367261 4.80046131 8 1 10.5863274 4.80046131 15 6.0857977                       12.1847656 9.71994835 12.3262379 14.3147912"
    }, null)])])])]), icon2 && !character && createVNode("span", {
      "class": [ns2.e("color-active"), ns2.e("active-star"), ns2.em("color", type4)],
      "style": {
        width: item.width
      }
    }, [createVNode(resolveComponent("d-icon"), {
      "name": icon2,
      "color": color2
    }, null)]), character && !icon2 && createVNode("span", {
      "class": [ns2.e("color-active"), ns2.e("active-star"), ns2.em("color", type4)],
      "style": {
        color: color2,
        width: item.width
      }
    }, [character]), !character && !icon2 && createVNode("span", {
      "class": [ns2.e("color-active"), ns2.e("active-star"), !color2 ? ns2.em("color", type4) : ns2.em("color", "customize")],
      "style": {
        width: item.width
      }
    }, [createVNode("svg", {
      "width": "16px",
      "height": "16px",
      "viewBox": "0 0 16 16",
      "version": "1.1",
      "xmlns": "http://www.w3.org/2000/svg",
      "xmlns-xlink": "http://www.w3.org/1999/xlink"
    }, [createVNode("g", {
      "stroke": "none",
      "stroke-width": "1",
      "fill": "none",
      "fill-rule": "evenodd"
    }, [createVNode("g", {
      "id": "Mask"
    }, [createVNode("polygon", {
      "points": "8 12.7603585 3.67376208 14.3147912 3.81523437 9.71994835 1                       6.0857977 5.41367261 4.80046131 8 1 10.5863274 4.80046131 15 6.0857977                       12.1847656 9.71994835 12.3262379 14.3147912"
    }, null)])])])])]))]);
  }
});
var RateInstall = {
  title: "Rate \u8BC4\u5206",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Rate.name, Rate);
  }
};
const readTipProps = {
  readTipOptions: {
    type: Object
  },
  defaultTemplateProps: {
    type: Object
  }
};
var readTip = "";
var TipsTemplate = defineComponent({
  name: "DReadTipTemplate",
  props: readTipProps,
  emits: [],
  setup(props, ctx2) {
    const {
      defaultTemplateProps
    } = toRefs(props);
    let rule = defaultTemplateProps.value;
    const query = (rule == null ? void 0 : rule.id) ? `#${rule.id}` : rule.selector;
    const styles = reactive({});
    if (typeof rule.dataFn === "function") {
      const dataFn = rule.dataFn({
        element: document.querySelector(query),
        rule
      });
      rule = __spreadValues(__spreadValues({}, rule), dataFn);
    }
    const temp = ref(null);
    const deviation = (x) => {
      let deviationConstant = x > 24 ? 0 : -(x / 2) + 2;
      if (x <= 10) {
        deviationConstant = -10;
      }
      return deviationConstant;
    };
    onMounted(() => {
      var _a, _b;
      const domBounding = (_a = document.querySelector(query)) == null ? void 0 : _a.getBoundingClientRect();
      const {
        width,
        height
      } = domBounding;
      const distance = 10;
      let positionTop = 0;
      const heightDeviation = deviation(height);
      const widthDeviation = deviation(width);
      let positionLeft = 0;
      const targetDom = (_b = document.querySelector(".read-tip-container")) == null ? void 0 : _b.getBoundingClientRect();
      if (rule.appendToBody) {
        positionTop = domBounding.y + document.documentElement.scrollTop;
        positionLeft = domBounding.x;
      }
      switch (rule.position) {
        case "top":
          styles.top = positionTop - targetDom.height - distance + "px";
          styles.left = positionLeft + widthDeviation + "px";
          break;
        case "left":
          styles.top = positionTop + heightDeviation + "px";
          styles.left = positionLeft - targetDom.width - distance + "px";
          break;
        case "bottom":
          styles.top = positionTop + domBounding.height + distance + "px";
          styles.left = positionLeft + widthDeviation + "px";
          break;
        case "right":
          styles.top = positionTop + heightDeviation + "px";
          styles.left = positionLeft + domBounding.width + distance + "px";
          break;
      }
    });
    return () => {
      return createVNode(Teleport, {
        "to": rule.appendToBody ? "body" : query
      }, {
        default: () => {
          var _a, _b;
          return [createVNode("div", {
            "ref": temp,
            "class": ["read-tip-container", rule.position, rule.overlayClassName],
            "style": styles
          }, [createVNode("span", {
            "class": "after"
          }, null), rule.contentTemplate ? (_b = (_a = ctx2.slots) == null ? void 0 : _a.default) == null ? void 0 : _b.call(_a) : createVNode(Fragment, null, [createVNode("div", {
            "class": "title"
          }, [rule.title]), createVNode("div", {
            "class": "content"
          }, [rule.content])])])];
        }
      });
    };
  }
});
const rules = (ruleList) => {
  if (ruleList === null) {
    return [];
  }
  if (typeof ruleList === "object" && !Array.isArray(ruleList)) {
    ruleList = [ruleList];
  }
  ruleList = [...ruleList];
  Array.isArray(ruleList) && ruleList.map((rule) => {
    rule.status = false;
  });
  return ruleList;
};
var ReadTip = defineComponent({
  name: "DReadTip",
  props: readTipProps,
  emits: [],
  setup(props, ctx2) {
    const defaultOptions2 = {
      trigger: "hover",
      showAnimate: false,
      mouseenterTime: 100,
      mouseleaveTime: 100,
      position: "top",
      overlayClassName: "",
      appendToBody: true,
      rules: {
        selector: null
      }
    };
    const options = __spreadValues(__spreadValues({}, defaultOptions2), props.readTipOptions);
    const defaultSlot = ref(null);
    const refRules = reactive(rules(options.rules));
    const onMouseenter = (rule) => () => {
      setTimeout(() => {
        if (rule.id) {
          const a = refRules.find((u) => u.id === rule.id);
          a.status = true;
        }
        rule.status = true;
      }, rule.mouseenterTime || options.mouseenterTime);
    };
    const onMouseleave = (rule) => () => {
      setTimeout(() => {
        if (rule.id) {
          const a = refRules.find((u) => u.id === rule.id);
          a.status = false;
        }
        rule.status = false;
      }, rule.mouseleaveTime || options.mouseleaveTime);
    };
    const init = (ruleList, trigger = "hover") => {
      ruleList.map((rule) => {
        var _a;
        rule.status = false;
        trigger = rule.trigger || trigger;
        rule.overlayClassName = rule.overlayClassName || options.overlayClassName;
        rule.position = rule.position || options.position;
        rule.contentTemplate = !!ctx2.slots.content;
        if (!("appendToBody" in rule)) {
          rule.appendToBody = options.appendToBody;
        }
        const doms = (_a = defaultSlot.value) == null ? void 0 : _a.querySelectorAll(rule.selector);
        [...doms].map((dom, index2) => {
          if (rule.appendToBody === false) {
            dom.style.position = "relative";
          }
          let newRule = reactive({
            id: null
          });
          const id = rule.selector.slice(rule.selector[0] === "." ? 1 : 0) + index2;
          if (index2 > 0) {
            newRule = __spreadValues({}, rule);
            dom.id = id;
            newRule.id = id;
            ruleList.push(newRule);
          }
          if (trigger === "hover") {
            dom.addEventListener("mouseenter", onMouseenter(newRule.id ? newRule : rule));
            dom.addEventListener("mouseleave", onMouseleave(newRule.id ? newRule : rule));
          }
        });
      });
      return ruleList;
    };
    function show(_, rule) {
      rule.status = true;
    }
    const clickFn = () => {
      refRules.forEach((element) => {
        element.status = false;
      });
    };
    onMounted(() => {
      init(refRules, options.trigger);
      document.addEventListener("click", clickFn, true);
    });
    onUnmounted(() => {
      document.removeEventListener("click", clickFn);
    });
    const onClick = (e) => {
      var _a;
      for (const rule of refRules) {
        const doms = (_a = defaultSlot.value) == null ? void 0 : _a.querySelectorAll(rule.selector);
        for (const dom of doms) {
          if (doms.length > 1) {
            if (dom === e.target && rule.id) {
              show(dom, rule);
              return;
            } else if (dom === e.target && !rule.id && !dom.id) {
              show(dom, rule);
              return;
            }
          } else if (dom === e.target) {
            show(dom, rule);
            return;
          } else {
            rule.status = false;
          }
        }
      }
    };
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": "devui-read-tip"
      }, [createVNode("div", {
        "ref": defaultSlot,
        "onClick": onClick
      }, [(_b = (_a = ctx2.slots) == null ? void 0 : _a.default) == null ? void 0 : _b.call(_a)]), refRules.map((rule) => createVNode("div", {
        "data-test": "todo"
      }, [rule.status && createVNode(TipsTemplate, {
        "defaultTemplateProps": __spreadValues({}, rule)
      }, {
        default: () => {
          var _a2, _b2;
          return [rule.contentTemplate && ((_b2 = (_a2 = ctx2.slots) == null ? void 0 : _a2.content) == null ? void 0 : _b2.call(_a2))];
        }
      })]))]);
    };
  }
});
var ReadTipInstall = {
  title: "ReadTip \u9605\u8BFB\u63D0\u793A",
  category: "\u53CD\u9988",
  status: "90%",
  install(app) {
    app.component(ReadTip.name, ReadTip);
  }
};
const resultProps = {
  icon: {
    type: String,
    default: "info"
  },
  title: {
    type: String,
    default: ""
  },
  desc: {
    type: String,
    default: ""
  }
};
var result = "";
var Result = defineComponent({
  name: "DResult",
  props: resultProps,
  setup(props, ctx2) {
    let IconEnum;
    (function(IconEnum2) {
      IconEnum2["success"] = "right-o";
      IconEnum2["danger"] = "error-o";
      IconEnum2["warning"] = "warning-o";
      IconEnum2["info"] = "info-o";
    })(IconEnum || (IconEnum = {}));
    return () => {
      var _a, _b, _c, _d;
      return createVNode("div", {
        "class": "devui-result"
      }, [ctx2.slots.icon ? createVNode("div", null, [(_a = ctx2.slots) == null ? void 0 : _a.icon()]) : createVNode(DIcon, {
        "name": IconEnum[props.icon] || "",
        "class": `devui-result__icon-${props.icon}`,
        "size": "64px"
      }, null), createVNode("div", {
        "class": "devui-result__title"
      }, [ctx2.slots.title ? (_b = ctx2.slots) == null ? void 0 : _b.title() : props.title]), createVNode("div", {
        "class": "devui-result__desc"
      }, [ctx2.slots.desc ? (_c = ctx2.slots) == null ? void 0 : _c.desc() : props.desc]), createVNode("div", {
        "class": "devui-result__extra"
      }, [ctx2.slots.extra ? (_d = ctx2.slots) == null ? void 0 : _d.extra() : ""])]);
    };
  }
});
var ResultInstall = {
  title: "Result \u7ED3\u679C",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Result.name, Result);
  }
};
const DEFAULT_PLUGIN_OPTIONS = {
  directive: "ripple",
  color: "currentColor",
  initialOpacity: 0.2,
  finalOpacity: 0.1,
  duration: 400,
  easing: "ease-out",
  delay: 75,
  disabled: false
};
const createContainer = ({
  borderTopLeftRadius,
  borderTopRightRadius,
  borderBottomLeftRadius,
  borderBottomRightRadius
}) => {
  const rippleContainer = document.createElement("div");
  rippleContainer.style.top = "0";
  rippleContainer.style.left = "0";
  rippleContainer.style.width = "100%";
  rippleContainer.style.height = "100%";
  rippleContainer.style.position = "absolute";
  rippleContainer.style.borderRadius = `${borderTopLeftRadius} ${borderTopRightRadius} ${borderBottomRightRadius} ${borderBottomLeftRadius}`;
  rippleContainer.style.overflow = "hidden";
  rippleContainer.style.pointerEvents = "none";
  rippleContainer.style.webkitMaskImage = "-webkit-radial-gradient(white, black)";
  return rippleContainer;
};
const createrippleElement = (x, y, size, options) => {
  const rippleElement = document.createElement("div");
  rippleElement.style.position = "absolute";
  rippleElement.style.width = `${size}px`;
  rippleElement.style.height = `${size}px`;
  rippleElement.style.top = `${y}px`;
  rippleElement.style.left = `${x}px`;
  rippleElement.style.background = options.color;
  rippleElement.style.borderRadius = "50%";
  rippleElement.style.opacity = `${options.initialOpacity}`;
  rippleElement.style.transform = `translate(-50%,-50%) scale(0)`;
  rippleElement.style.transition = `transform ${options.duration / 1e3}s ${options.easing}, opacity ${options.duration / 1e3}s ${options.easing}`;
  return rippleElement;
};
function magnitude(x1, y1, x2, y2) {
  const deltaX = x1 - x2;
  const deltaY = y1 - y2;
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}
function getDistanceToFurthestCorner(x, y, { width, height }) {
  const topLeft = magnitude(x, y, 0, 0);
  const topRight = magnitude(x, y, width, 0);
  const bottomLeft = magnitude(x, y, 0, height);
  const bottomRight = magnitude(x, y, width, height);
  return Math.max(topLeft, topRight, bottomLeft, bottomRight);
}
const getRelativePointer = ({ x, y }, { top, left }) => ({
  x: x - left,
  y: y - top
});
const RIPPLE_COUNT = "vRippleCountInternal";
function setRippleCount(el, count) {
  el.dataset[RIPPLE_COUNT] = count.toString();
}
function getRippleCount(el) {
  var _a;
  return parseInt((_a = el.dataset[RIPPLE_COUNT]) != null ? _a : "0", 10);
}
function incrementRippleCount(el) {
  const count = getRippleCount(el);
  setRippleCount(el, count + 1);
}
function decrementRippleCount(el) {
  const count = getRippleCount(el);
  setRippleCount(el, count - 1);
}
function deleteRippleCount(el) {
  delete el.dataset[RIPPLE_COUNT];
}
const MULTIPLE_NUMBER = 2.05;
const ripple = (event, el, options) => {
  const rect = el.getBoundingClientRect();
  const computedStyles = window.getComputedStyle(el);
  const { x, y } = getRelativePointer(event, rect);
  const size = MULTIPLE_NUMBER * getDistanceToFurthestCorner(x, y, rect);
  const rippleContainer = createContainer(computedStyles);
  const rippleEl = createrippleElement(x, y, size, options);
  let originalPositionValue = "";
  let shouldDissolveripple = false;
  let token = null;
  function dissolveripple() {
    rippleEl.style.transition = "opacity 150ms linear";
    rippleEl.style.opacity = "0";
    setTimeout(() => {
      rippleContainer.remove();
      decrementRippleCount(el);
      if (getRippleCount(el) === 0) {
        deleteRippleCount(el);
        el.style.position = originalPositionValue;
      }
    }, 150);
  }
  function releaseripple(e) {
    if (typeof e !== "undefined") {
      document.removeEventListener("pointerup", releaseripple);
      document.removeEventListener("pointercancel", releaseripple);
    }
    if (shouldDissolveripple) {
      dissolveripple();
    } else {
      shouldDissolveripple = true;
    }
  }
  function cancelripple() {
    clearTimeout(token);
    rippleContainer.remove();
    document.removeEventListener("pointerup", releaseripple);
    document.removeEventListener("pointercancel", releaseripple);
    document.removeEventListener("pointercancel", cancelripple);
  }
  incrementRippleCount(el);
  if (computedStyles.position === "static") {
    if (el.style.position) {
      originalPositionValue = el.style.position;
    }
    el.style.position = "relative";
  }
  rippleContainer.appendChild(rippleEl);
  el.appendChild(rippleContainer);
  document.addEventListener("pointerup", releaseripple);
  document.addEventListener("pointercancel", releaseripple);
  token = setTimeout(() => {
    document.removeEventListener("pointercancel", cancelripple);
    requestAnimationFrame(() => {
      rippleEl.style.transform = `translate(-50%,-50%) scale(1)`;
      rippleEl.style.opacity = `${options.finalOpacity}`;
      setTimeout(() => releaseripple(), options.duration);
    });
  }, options.delay);
  document.addEventListener("pointercancel", cancelripple);
};
const optionMap = /* @__PURE__ */ new WeakMap();
const globalOptions = __spreadValues({}, DEFAULT_PLUGIN_OPTIONS);
var RippleDirective = {
  mounted(el, binding) {
    var _a;
    optionMap.set(el, (_a = binding.value) != null ? _a : {});
    el.addEventListener("pointerdown", (event) => {
      const options = optionMap.get(el);
      if (binding.value && binding.value.disabled) {
        return;
      }
      if (options === false) {
        return;
      }
      ripple(event, el, __spreadValues(__spreadValues({}, globalOptions), options));
    });
  },
  updated(el, binding) {
    var _a;
    optionMap.set(el, (_a = binding.value) != null ? _a : {});
  }
};
var RippleInstall = {
  title: "Ripple \u6C34\u6CE2\u7EB9",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.directive("Ripple", RippleDirective);
  }
};
const searchProps = {
  size: {
    type: String
  },
  placeholder: {
    type: String,
    default: ""
  },
  maxLength: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  delay: {
    type: Number,
    default: 300
  },
  disabled: {
    type: Boolean,
    default: false
  },
  autoFocus: {
    type: Boolean,
    default: false
  },
  isKeyupSearch: {
    type: Boolean,
    default: false
  },
  iconPosition: {
    type: String,
    default: "right"
  },
  noBorder: {
    type: Boolean,
    default: false
  },
  cssClass: {
    type: String,
    default: ""
  },
  modelValue: {
    type: String,
    default: ""
  },
  "onUpdate:modelValue": {
    type: Function,
    default: void 0
  }
};
const useSearchClass = (props, isFocus) => {
  const formContext = inject(FORM_TOKEN, void 0);
  const ICON_POSITION = {
    right: "right",
    left: "left"
  };
  const ns2 = useNamespace("search");
  const searchSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "md");
  const rootClass = computed(() => ({
    [ns2.b()]: true,
    [ns2.m("focus")]: isFocus.value,
    [ns2.m("disabled")]: props.disabled,
    [ns2.m("no-border")]: props.noBorder,
    [ns2.m(searchSize.value)]: !!searchSize.value,
    [ns2.m(props.iconPosition)]: ICON_POSITION[props.iconPosition]
  }));
  return {
    rootClass,
    searchSize
  };
};
const keywordsHandles = (ctx2, props) => {
  const keywords = ref("");
  watch(() => props.modelValue, (val) => {
    keywords.value = val;
  }, { immediate: true });
  const onClearHandle = () => {
    keywords.value = "";
    ctx2.emit("update:modelValue", "");
    ctx2.emit("search", "");
  };
  const clearIconShow = computed(() => keywords.value.length > 0);
  return {
    keywords,
    clearIconShow,
    onClearHandle
  };
};
const keydownHandles = (ctx2, keywords, props) => {
  const useEmitKeyword = lodash.exports.debounce((value) => {
    ctx2.emit("search", value);
  }, props.delay);
  const handleEnter = ($event) => {
    if ($event.target instanceof HTMLInputElement) {
      const value = $event.target.value;
      useEmitKeyword(value);
    }
  };
  const onClickHandle = () => {
    if (!props.disabled) {
      ctx2.emit("search", keywords.value);
    }
  };
  const KEYS_MAP = {
    Enter: handleEnter
  };
  const onInputKeydown = ($event) => {
    var _a;
    (_a = KEYS_MAP[$event.key]) == null ? void 0 : _a.call(KEYS_MAP, $event);
  };
  return {
    onInputKeydown,
    useEmitKeyword,
    onClickHandle
  };
};
var search = "";
const SearchCloseIcon = () => createVNode("svg", {
  "viewBox": "0 0 1024 1024",
  "width": "12px",
  "height": "12px"
}, [createVNode("path", {
  "d": "M940.8 207.530667L818.602667 85.333333l-305.493334 305.493334L207.616 85.333333       85.333333 207.530667l305.493334 305.493333L85.333333 818.517333l122.282667 122.282667       305.493333-305.493333 305.493334 305.493333 122.197333-122.282667-305.493333-305.493333z",
  "p-id": "30810"
}, null)]);
const SearchIcon = () => createVNode("svg", {
  "viewBox": "0 0 1024 1024",
  "version": "1.1",
  "width": "12px",
  "height": "12px"
}, [createVNode("path", {
  "d": "M1005.312 914.752l-198.528-198.464A448 448 0 1 0 0 448a448 448 0 0 0 716.288       358.784l198.4 198.4a64 64 0 1 0 90.624-90.432zM448 767.936A320 320 0 1 1 448 128a320 320 0 0 1 0 640z",
  "fill": "#262626",
  "p-id": "32547"
}, null)]);
var DSearch = defineComponent({
  name: "DSearch",
  props: searchProps,
  emits: ["update:modelValue", "search"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DSearch", app);
    const ns2 = useNamespace("search");
    const isFocus = ref(false);
    const {
      rootClass,
      searchSize
    } = useSearchClass(props, isFocus);
    const {
      keywords,
      clearIconShow,
      onClearHandle
    } = keywordsHandles(ctx2, props);
    const {
      onInputKeydown,
      onClickHandle,
      useEmitKeyword
    } = keydownHandles(ctx2, keywords, props);
    const onInputUpdate = (event) => {
      if (props.isKeyupSearch) {
        useEmitKeyword(event);
      }
      keywords.value = event;
      ctx2.emit("update:modelValue", event);
    };
    const onFocus = () => {
      isFocus.value = true;
    };
    const onBlur = () => {
      isFocus.value = false;
    };
    return () => {
      const inputProps2 = {
        size: searchSize.value,
        disabled: props.disabled,
        autoFocus: props.autoFocus,
        maxlength: props.maxLength,
        modelValue: keywords.value,
        placeholder: props.placeholder || t("placeholder"),
        onKeydown: onInputKeydown,
        "onUpdate:modelValue": onInputUpdate,
        onFocus,
        onBlur
      };
      return createVNode("label", {
        "class": rootClass.value
      }, [props.iconPosition === "left" && createVNode("div", {
        "class": ns2.e("icon"),
        "onClick": onClickHandle
      }, [createVNode(SearchIcon, null, null)]), createVNode(DInput, inputProps2, null), clearIconShow.value && createVNode("div", {
        "class": ns2.e("clear"),
        "onClick": onClearHandle
      }, [createVNode(SearchCloseIcon, null, null)]), props.iconPosition === "right" && createVNode("div", {
        "class": ns2.e("icon"),
        "onClick": onClickHandle
      }, [createVNode(SearchIcon, null, null)])]);
    };
  }
});
var SearchInstall = {
  title: "Search \u641C\u7D22\u6846",
  category: "\u901A\u7528",
  status: "100%",
  install(app) {
    app.component(DSearch.name, DSearch);
  }
};
const skeletonItemProps = {
  variant: {
    type: String,
    default: "square"
  },
  size: {
    type: String,
    default: "md"
  }
};
const skeletonProps = {
  rows: {
    type: Number,
    default: 3
  },
  round: {
    type: Boolean,
    default: false
  },
  loading: {
    type: Boolean,
    default: true
  },
  showAnimation: {
    type: Boolean,
    default: true
  }
};
const roundInjectionKey = Symbol("round");
const animationInjectionKey = Symbol("showAnimation");
function useSkeletonItem(props) {
  const ns2 = useNamespace("skeleton-item");
  const { variant, size } = toRefs(props);
  const round = inject(roundInjectionKey, void 0);
  const showAnimation = inject(animationInjectionKey, void 0);
  const classes = computed(() => ({
    [ns2.b()]: true,
    [ns2.m(variant.value)]: true,
    [ns2.m(size.value)]: variant.value !== "square",
    [ns2.m("round")]: variant.value !== "circle" && Boolean(round == null ? void 0 : round.value),
    [ns2.m("animation")]: Boolean(showAnimation == null ? void 0 : showAnimation.value)
  }));
  return { classes };
}
function ImageIcon() {
  return createVNode("svg", {
    "width": "24px",
    "height": "24px",
    "viewBox": "0 0 24 24",
    "version": "1.1",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("g", {
    "stroke": "none",
    "stroke-width": "1",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", null, [createVNode("rect", {
    "fill": "#d8d8d8",
    "opacity": "0",
    "x": "0",
    "y": "0",
    "width": "24",
    "height": "24"
  }, null), createVNode("path", {
    "d": "M17.9783341,3.022 C19.5705758,3.022 20.8816065,4.27616494 20.9732206,5.84628917 L20.9783341,6.022 L20.9783341,15.4777069           L20.9783775,15.4946187 C20.9778434,15.509964 20.9768409,15.525296 20.9753698,15.5405914 L20.9783341,15.4777069           C20.9783341,15.8919205 20.6425477,16.2277069 20.2283341,16.2277069 C19.9841207,16.2277069 19.7671693,16.1109847           19.630224,15.9302845 L16.3835041,12.6846982 C15.9279377,12.2291319 15.2084078,12.1987608 14.7176463,12.593585           L14.6161642,12.6846982 L9.05907272,18.2417898 C8.76083183,18.5400306 8.28304152,18.5577535 7.96352506,18.2824274           C7.67269311,18.0318186 7.64008582,17.5928941 7.89069464,17.3020621 L7.9253008,17.2647549 L7.9253008,17.2647549           L13.5555041,11.6240381 C14.5846517,10.5948904 16.2263561,10.5520093 17.3065502,11.4953946 L17.4441642,11.6240381           L19.4783341,13.658 L19.4783341,6.022 C19.4783341,5.24761276 18.8784495,4.6021759 18.1219124,4.52892169 L17.9783341,4.522           L6.02133414,4.522 C5.24694691,4.522 4.60151004,5.12188468 4.52825583,5.87842174 L4.52133414,6.022 L4.52133414,17.978           C4.52133414,18.7529555 5.12086774,19.397891 5.87769393,19.4710842 L6.02133414,19.478 L17.9783341,19.478 C18.7530944,19.478           19.3982021,18.8786501 19.4714163,18.1216726 L19.4783341,17.978 C19.4783341,17.5637864 19.8141206,17.208 20.2283341,17.228           C20.6425477,17.228 20.9783341,17.5637864 20.9783341,17.978 C20.9783341,19.5709231 19.724442,20.881321 18.1540742,20.9728891           L17.9783341,20.978 L6.02133414,20.978 C4.42880954,20.978 3.11804157,19.7244922 3.02644657,18.1537812 L3.02133414,17.978           L3.02133414,6.022 C3.02133414,4.42975835 4.27549908,3.11872764 5.84562331,3.02711351 L6.02133414,3.022 L17.9783341,3.022 Z           M8.99983414,7.7505 C9.6900477,7.7505 10.2498341,8.31028644 10.2498341,9.0005 C10.2498341,9.69071356 9.6900477,10.2505           8.99983414,10.3505 C8.30962058,10.2505 7.74983414,9.69071356 7.74983414,9.0005 C7.74983414,8.31028644 8.30962058,7.7505           8.99983414,7.7505 Z",
    "fill": "#bfbfbf"
  }, null)])])]);
}
var skeletonItem = "";
var SkeletonItem = defineComponent({
  name: "DSkeletonItem",
  props: skeletonItemProps,
  setup(props) {
    const {
      variant
    } = toRefs(props);
    const {
      classes
    } = useSkeletonItem(props);
    return () => createVNode("div", {
      "class": classes.value
    }, [variant.value === "image" && createVNode(ImageIcon, null, null)]);
  }
});
var skeleton = "";
var Skeleton = defineComponent({
  name: "DSkeleton",
  props: skeletonProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("skeleton");
    const {
      loading: loading2,
      rows,
      showAnimation,
      round
    } = toRefs(props);
    const paragraphs = computed(() => new Array(rows.value).fill(""));
    provide(animationInjectionKey, showAnimation);
    provide(roundInjectionKey, round);
    return () => {
      var _a, _b;
      return loading2.value ? ctx2.slots.placeholder ? ctx2.slots.placeholder() : createVNode("div", {
        "class": ns2.b()
      }, [createVNode(SkeletonItem, {
        "class": ns2.e("title")
      }, null), paragraphs.value.map(() => createVNode(SkeletonItem, {
        "class": ns2.e("paragraph")
      }, null))]) : (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a);
    };
  }
});
var SkeletonInstall = {
  title: "Skeleton \u9AA8\u67B6\u5C4F",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Skeleton.name, Skeleton);
    app.component(SkeletonItem.name, SkeletonItem);
  }
};
const sliderProps = {
  disabled: {
    type: Boolean,
    default: false
  },
  max: {
    type: Number,
    default: 100
  },
  min: {
    type: Number,
    default: 0
  },
  modelValue: {
    type: Number,
    default: 0
  },
  step: {
    type: Number,
    default: 1
  },
  tipsRenderer: {
    type: [Function, null],
    default: () => (value) => `${value}`
  }
};
function useSliderEvent(props, ctx2) {
  let isClick = true;
  let startPosition = 0;
  let startX = 0;
  const sliderRunway = ref();
  const currentValue = ref(Number(props.modelValue));
  const currentPosition = ref(0);
  const percentDisplay = ref("");
  const popoverShow = ref(false);
  const newPosition = ref(0);
  function getSliderWidth() {
    var _a;
    return Boolean(sliderRunway.value) ? ((_a = sliderRunway.value) == null ? void 0 : _a.clientWidth) || 0 : 0;
  }
  function initCurrentPosition() {
    const sliderWidth = getSliderWidth();
    currentPosition.value = sliderWidth * (currentValue.value - props.min) / (props.max - props.min);
  }
  function setPosition(position) {
    const clientWidth = getSliderWidth();
    const sliderWidth = Math.round(clientWidth);
    if (position < 0) {
      position = 0;
    }
    const LengthPerStep = sliderWidth / ((props.max - props.min) / props.step);
    const steps2 = Math.round(position / LengthPerStep);
    const value = steps2 * LengthPerStep;
    if (Math.round(value) >= sliderWidth) {
      currentPosition.value = sliderWidth;
      currentValue.value = props.max;
      percentDisplay.value = "100%";
      ctx2.emit("update:modelValue", props.max);
      return;
    }
    percentDisplay.value = Math.round(value * 100 / sliderWidth) + "%";
    currentValue.value = Math.round(value * (props.max - props.min) / sliderWidth) + props.min;
    currentPosition.value = position;
    ctx2.emit("update:modelValue", currentValue.value);
  }
  function dragStart(event) {
    isClick = false;
    startX = event.clientX;
    startPosition = currentPosition.value;
    newPosition.value = startPosition;
  }
  function onDragging(event) {
    popoverShow.value = true;
    const currentX = event.clientX;
    const pxOffset = currentX - startX;
    newPosition.value = startPosition + pxOffset;
    setPosition(newPosition.value);
  }
  function onDragEnd() {
    popoverShow.value = false;
    setTimeout(() => {
      isClick = true;
    }, 100);
    window.removeEventListener("mousemove", onDragging);
    window.removeEventListener("mouseup", onDragEnd);
  }
  function handleButtonMousedown(event) {
    popoverShow.value = true;
    if (!props.disabled) {
      event.preventDefault();
      dragStart(event);
      window.addEventListener("mousemove", onDragging);
      window.addEventListener("mouseup", onDragEnd);
    }
  }
  function handleRunwayMousedown(event) {
    if (!props.disabled && isClick) {
      const _e = event.target;
      startX = _e.getBoundingClientRect().left;
      const currentX = event.clientX;
      setPosition(currentX - startX);
      handleButtonMousedown(event);
    }
  }
  watch(() => props.modelValue, () => {
    currentValue.value = Number(props.modelValue);
    if (currentValue.value > props.max) {
      percentDisplay.value = "100%";
    } else if (currentValue.value < props.min) {
      percentDisplay.value = "0%";
    } else {
      percentDisplay.value = (currentValue.value - props.min) * 100 / (props.max - props.min) + "%";
    }
    initCurrentPosition();
  }, { immediate: true });
  onMounted(initCurrentPosition);
  return { sliderRunway, popoverShow, percentDisplay, currentValue, handleRunwayMousedown, handleButtonMousedown };
}
var slider = "";
var Slider = defineComponent({
  name: "DSlider",
  props: sliderProps,
  emits: ["update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("slider");
    const {
      sliderRunway,
      popoverShow,
      percentDisplay,
      currentValue,
      handleRunwayMousedown,
      handleButtonMousedown
    } = useSliderEvent(props, ctx2);
    const disableClass = computed(() => {
      return props.disabled ? " disabled" : "";
    });
    const tipsContent = computed(() => isFunction$3(props.tipsRenderer) ? props.tipsRenderer(currentValue.value) : "");
    return () => createVNode("div", {
      "class": ns2.b()
    }, [createVNode("div", {
      "ref": sliderRunway,
      "class": [ns2.e("runway"), disableClass.value],
      "onMousedown": handleRunwayMousedown,
      "onMouseout": () => popoverShow.value = false
    }, [createVNode("div", {
      "class": [ns2.e("bar"), disableClass.value],
      "style": {
        width: percentDisplay.value
      }
    }, null), createVNode("div", {
      "class": [ns2.e("button"), disableClass.value],
      "style": {
        left: percentDisplay.value
      },
      "onMousedown": handleButtonMousedown,
      "onMouseenter": () => popoverShow.value = true,
      "onMouseout": () => popoverShow.value = false
    }, null), props.tipsRenderer === null ? null : popoverShow.value ? createVNode("div", {
      "class": ns2.e("popover"),
      "style": {
        left: percentDisplay.value
      }
    }, [createVNode("div", {
      "class": ns2.e("popover-arrow")
    }, null), createVNode("div", {
      "class": ns2.e("popover-content")
    }, [tipsContent.value])]) : null])]);
  }
});
var SliderInstall = {
  title: "Slider \u6ED1\u5757",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Slider.name, Slider);
  }
};
const tooltipProps = {
  content: {
    type: String,
    default: ""
  },
  position: {
    type: [String, Array],
    default: "top"
  },
  showAnimation: {
    type: Boolean,
    default: true
  },
  mouseEnterDelay: {
    type: Number,
    default: 150
  },
  mouseLeaveDelay: {
    type: Number,
    default: 100
  },
  enterable: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  hideAfter: {
    type: Number,
    default: 0
  }
};
const transformOriginMap = {
  top: "50% calc(100% + 8px)",
  bottom: "50% -8px",
  left: "calc(100% + 8px)",
  right: "-8px 50%"
};
function useTooltip(origin, props) {
  const { position, mouseEnterDelay, mouseLeaveDelay, enterable, disabled, hideAfter } = toRefs(props);
  const visible = ref(false);
  const isEnter = ref(false);
  const positionArr = computed(() => typeof position.value === "string" ? [position.value] : position.value);
  const placement = ref(positionArr.value[0]);
  const overlayStyles = computed(() => ({
    transformOrigin: transformOriginMap[placement.value]
  }));
  const enter = lodash.exports.debounce(() => {
    isEnter.value && (visible.value = true);
  }, mouseEnterDelay.value);
  const leave = lodash.exports.debounce(() => {
    !isEnter.value && (visible.value = false);
  }, mouseLeaveDelay.value);
  const onMouseenter = () => {
    if (disabled.value) {
      return;
    }
    isEnter.value = true;
    enter();
  };
  const onMouseleave = () => {
    isEnter.value = false;
    leave();
  };
  const onPositionChange = (pos) => {
    placement.value = pos;
  };
  const quickLeave = () => {
    isEnter.value = false;
    visible.value = false;
  };
  const onMouseenterOverlay = () => {
    if (!enterable.value) {
      quickLeave();
    } else {
      onMouseenter();
    }
  };
  onMounted(() => {
    origin.value.addEventListener("mouseenter", onMouseenter);
    origin.value.addEventListener("mouseleave", onMouseleave);
  });
  let timer;
  watch(visible, (newVal) => {
    if (newVal && hideAfter.value) {
      timer && clearTimeout(timer);
      timer = setTimeout(quickLeave, hideAfter.value);
    }
  });
  return {
    visible,
    placement,
    positionArr,
    overlayStyles,
    onPositionChange,
    onMouseenter,
    onMouseleave,
    onMouseenterOverlay
  };
}
var tooltip = "";
var Tooltip = defineComponent({
  name: "DTooltip",
  props: tooltipProps,
  setup(props, {
    slots
  }) {
    const {
      showAnimation,
      content: content2
    } = toRefs(props);
    const origin = ref();
    const tooltipRef = ref();
    const {
      visible,
      placement,
      positionArr,
      overlayStyles,
      onPositionChange,
      onMouseleave,
      onMouseenterOverlay
    } = useTooltip(origin, props);
    const ns2 = useNamespace("tooltip");
    const className2 = computed(() => {
      return [ns2.b(), ns2.m(placement.value)].join(" ");
    });
    provide(POPPER_TRIGGER_TOKEN, origin);
    return () => createVNode(Fragment, null, [createVNode(PopperTrigger, null, {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    }), createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode(Transition, {
        "name": showAnimation.value ? ns2.m(`fade-${placement.value}`) : ""
      }, {
        default: () => [createVNode(FlexibleOverlay, {
          "modelValue": visible.value,
          "onUpdate:modelValue": ($event) => visible.value = $event,
          "ref": tooltipRef,
          "class": className2.value,
          "origin": origin.value,
          "position": positionArr.value,
          "offset": 6,
          "show-arrow": true,
          "style": overlayStyles.value,
          "onPositionChange": onPositionChange,
          "onMouseenter": onMouseenterOverlay,
          "onMouseleave": onMouseleave
        }, {
          default: () => [createVNode("span", {
            "innerHTML": content2.value
          }, null)]
        })]
      })]
    })]);
  }
});
function normalizeEvent(evt) {
  return {
    pageX: evt.pageX,
    pageY: evt.pageY,
    clientX: evt.clientX,
    clientY: evt.clientY,
    offsetX: evt.offsetX,
    offsetY: evt.offsetY,
    type: evt.type,
    originalEvent: evt
  };
}
function bind(el, eventName, callback) {
  el.addEventListener && el.addEventListener(eventName, callback);
}
function unbind(el, eventName, callback) {
  el.removeEventListener && el.removeEventListener(eventName, callback);
}
function onMousedown(e) {
  var _a;
  const resizeProps = (_a = e == null ? void 0 : e.target) == null ? void 0 : _a.resizeProps;
  if (!resizeProps) {
    return;
  }
  function onMousemove(evt) {
    resizeProps.onDragEvent(normalizeEvent(evt));
  }
  function onMouseup(evt) {
    unbind(document, "mousemove", onMousemove);
    unbind(document, "mouseup", onMouseup);
    resizeProps.onReleaseEvent(normalizeEvent(evt));
  }
  bind(document, "mousemove", onMousemove);
  bind(document, "mouseup", onMouseup);
  resizeProps.onPressEvent(normalizeEvent(e));
}
function bindEvent(el) {
  bind(el, "mousedown", onMousedown);
}
const resize = {
  mounted(el, { value }) {
    el.resizeProps = value;
    if (value.enableResize) {
      bindEvent(el);
    }
  },
  unmounted(el, { value }) {
    if (value.enableResize) {
      unbind(el, "mousedown", onMousedown);
    }
  }
};
const splitterBarProps = {
  index: {
    type: Number
  },
  orientation: {
    type: String,
    required: true
  },
  splitBarSize: {
    type: String,
    required: true
  },
  disabledBarSize: {
    type: String,
    default: "1px"
  },
  showCollapseButton: {
    type: Boolean
  }
};
var splitterBar = "";
var DSplitterBar = defineComponent({
  name: "DSplitterBar",
  components: {
    DToolTip: Tooltip
  },
  props: splitterBarProps,
  setup(props) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DSplitterBar", app);
    const ns2 = useNamespace("splitter");
    const store = inject("splitterStore");
    const state = reactive({
      wrapperClass: `${ns2.e("bar")} ${ns2.em("bar", props.orientation)} `
    });
    const domRef = ref();
    watch([() => props.splitBarSize, domRef], ([curSplitBarSize, ele]) => {
      if (!isHTMLElement(ele)) {
        return;
      }
      setStyle(ele, {
        flexBasis: curSplitBarSize
      });
    }, {
      immediate: true
    });
    watch([() => store == null ? void 0 : store.state.panes, domRef], ([, ele]) => {
      if (!store || !props || props.index === void 0) {
        return;
      }
      if (!store.isStaticBar(props.index)) {
        state.wrapperClass += " resizable";
      } else if (ele) {
        setStyle(ele, {
          flexBasis: props.disabledBarSize
        });
      }
    }, {
      deep: true
    });
    const queryPanes = (index2, nearIndex) => {
      if (!store) {
        return {};
      }
      const pane = store.getPane(index2);
      const nearPane = store.getPane(nearIndex);
      return {
        pane,
        nearPane
      };
    };
    const generateCollapseClass = (pane, nearPane, showIcon) => {
      var _a, _b, _c, _d;
      const isCollapsible = ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapsible) && showIcon;
      const isCollapsed = (_d = (_c = pane == null ? void 0 : pane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.collapsed;
      const isNearPaneCollapsed = nearPane == null ? void 0 : nearPane.collapsed;
      return {
        [ns2.e("collapse")]: isCollapsible,
        collapsed: isCollapsed,
        hidden: isNearPaneCollapsed
      };
    };
    const prevClass = computed(() => {
      var _a, _b;
      if (!props || props.index === void 0) {
        return {};
      }
      const {
        pane,
        nearPane
      } = queryPanes(props.index, props.index + 1);
      const showIcon = ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapseDirection) !== "after" || props.index === 0;
      return generateCollapseClass(pane, nearPane, showIcon);
    });
    const nextClass = computed(() => {
      var _a, _b;
      if (!store || !props || props.index === void 0) {
        return {};
      }
      const {
        pane,
        nearPane
      } = queryPanes(props.index + 1, props.index);
      const showIcon = ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapseDirection) !== "before" || props.index + 1 === store.state.paneCount - 1;
      return generateCollapseClass(pane, nearPane, showIcon);
    });
    const toggleResize = () => {
      var _a, _b, _c, _d;
      if (!domRef.value || !props || props.index === void 0) {
        return;
      }
      const {
        pane,
        nearPane
      } = queryPanes(props.index, props.index + 1);
      const isCollapsed = ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapsed) || ((_d = (_c = nearPane == null ? void 0 : nearPane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.collapsed);
      if (isCollapsed) {
        addClass(domRef.value, "none-resizable");
      } else {
        removeClass(domRef.value, "none-resizable");
      }
    };
    const handleCollapsePrePane = (lockStatus) => {
      if (!store || !props || props.index === void 0) {
        return;
      }
      store.tooglePane(props.index, props.index + 1, lockStatus);
      toggleResize();
    };
    const handleCollapseNextPane = (lockStatus) => {
      if (!store || !props || props.index === void 0) {
        return;
      }
      store.tooglePane(props.index + 1, props.index, lockStatus);
      toggleResize();
    };
    const initialCollapseStatus = () => {
      handleCollapsePrePane(true);
      handleCollapseNextPane(true);
    };
    const coordinate = {
      pageX: 0,
      pageY: 0,
      originalX: 0,
      originalY: 0
    };
    let initState;
    const resizeProp = {
      enableResize: true,
      onPressEvent: function({
        originalEvent
      }) {
        originalEvent.stopPropagation();
        if (!store || !props || props.index === void 0) {
          return;
        }
        if (!store.isResizable(props.index)) {
          return;
        }
        initState = store.dragState(props.index);
        coordinate.originalX = originalEvent.pageX;
        coordinate.originalY = originalEvent.pageY;
      },
      onDragEvent: function({
        originalEvent
      }) {
        originalEvent.stopPropagation();
        if (!store || !props || props.index === void 0) {
          return;
        }
        if (!store.isResizable(props.index)) {
          return;
        }
        coordinate.pageX = originalEvent.pageX;
        coordinate.pageY = originalEvent.pageY;
        let distance;
        if (props.orientation === "vertical") {
          distance = coordinate.pageY - coordinate.originalY;
        } else {
          distance = coordinate.pageX - coordinate.originalX;
        }
        store.setSize(initState, distance);
      },
      onReleaseEvent: function({
        originalEvent
      }) {
        originalEvent.stopPropagation();
        if (!store || !props || props.index === void 0) {
          return;
        }
        if (!store.isResizable(props.index)) {
          return;
        }
        coordinate.pageX = originalEvent.pageX;
        coordinate.pageY = originalEvent.pageY;
        let distance;
        if (props.orientation === "vertical") {
          distance = coordinate.pageY - coordinate.originalY;
        } else {
          distance = coordinate.pageX - coordinate.originalX;
        }
        store.setSize(initState, distance);
      }
    };
    onMounted(() => {
      initialCollapseStatus();
    });
    const renderCollapsedTip = () => {
      var _a, _b, _c, _d;
      if (!props || props.index === void 0) {
        return t("collapse");
      }
      const {
        pane,
        nearPane
      } = queryPanes(props.index, props.index + 1);
      const isCollapsed = ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapsed) || ((_d = (_c = nearPane == null ? void 0 : nearPane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.collapsed);
      return isCollapsed ? t("expand") : t("collapse");
    };
    return () => {
      return withDirectives(createVNode("div", {
        "class": state.wrapperClass,
        "ref": domRef
      }, [props.showCollapseButton && createVNode(Tooltip, {
        "content": renderCollapsedTip()
      }, {
        default: () => [createVNode("div", {
          "class": ["prev", prevClass.value],
          "onClick": () => {
            handleCollapsePrePane();
          }
        }, null)]
      }), props.showCollapseButton && createVNode(Tooltip, {
        "content": renderCollapsedTip()
      }, {
        default: () => [createVNode("div", {
          "class": ["next", nextClass.value],
          "onClick": () => handleCollapseNextPane()
        }, null)]
      })]), [[resize, resizeProp]]);
    };
  }
});
class SplitterStore {
  constructor() {
    __publicField(this, "state");
    this.state = reactive({
      panes: [],
      splitterContainerSize: 0,
      paneCount: 0
    });
  }
  setPanes({ panes }) {
    this.state.panes = panes.map((pane, index2) => {
      var _a;
      if (pane.component) {
        pane.component.exposed.order.value = index2 * 2;
      }
      pane.getPaneSize = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.exposed.getPaneSize;
      return pane;
    });
    this.state.paneCount = panes.length;
  }
  setSplitter({ containerSize }) {
    this.state.splitterContainerSize = containerSize;
  }
  getPane(index2) {
    if (!this.state.panes || index2 < 0 || index2 >= this.state.panes.length) {
      throw new Error("no pane can return.");
    }
    return this.state.panes[index2];
  }
  dragState(splitbarIndex) {
    const prev = this.getPane(splitbarIndex);
    const next = this.getPane(splitbarIndex + 1);
    const total = prev.getPaneSize() + next.getPaneSize();
    return {
      prev: {
        index: splitbarIndex,
        initialSize: prev.getPaneSize(),
        minSize: this.toPixels(prev.component.props.minSize) || total - this.toPixels(next.component.props.maxSize) || 0,
        maxSize: this.toPixels(prev.component.props.maxSize) || total - this.toPixels(next.component.props.minSize) || total
      },
      next: {
        index: splitbarIndex + 1,
        initialSize: next.getPaneSize(),
        minSize: this.toPixels(next.component.props.minSize) || total - this.toPixels(prev.component.props.maxSize) || 0,
        maxSize: this.toPixels(next.component.props.maxSize) || total - this.toPixels(prev.component.props.minSize) || total
      }
    };
  }
  clamp(minSize, maxSize, initialSize) {
    return Math.min(maxSize, Math.max(minSize, initialSize));
  }
  resize(paneState, moveSize) {
    const pane = this.getPane(paneState.index);
    const splitterSize = this.state.splitterContainerSize;
    const newSize = this.clamp(paneState.minSize, paneState.maxSize, paneState.initialSize + moveSize);
    let size = "";
    if (this.isPercent(pane.component.props.size)) {
      size = newSize / splitterSize * 100 + "%";
    } else {
      size = newSize + "px";
    }
    pane.component.props.size = size;
    pane.component.emit("sizeChange", size);
  }
  isResizable(splitBarIndex) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const prevPane = this.getPane(splitBarIndex);
    const nextPane = this.getPane(splitBarIndex + 1);
    const paneCollapsed = ((_b = (_a = prevPane == null ? void 0 : prevPane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapsed) || ((_d = (_c = nextPane == null ? void 0 : nextPane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.collapsed);
    return ((_f = (_e = prevPane == null ? void 0 : prevPane.component) == null ? void 0 : _e.props) == null ? void 0 : _f.resizable) && ((_h = (_g = nextPane == null ? void 0 : nextPane.component) == null ? void 0 : _g.props) == null ? void 0 : _h.resizable) && !paneCollapsed;
  }
  isStaticBar(splitBarIndex) {
    var _a, _b, _c, _d;
    const prevPane = this.getPane(splitBarIndex);
    const nextPane = this.getPane(splitBarIndex + 1);
    return !(((_b = (_a = prevPane == null ? void 0 : prevPane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.resizable) && ((_d = (_c = nextPane == null ? void 0 : nextPane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.resizable));
  }
  isPercent(size) {
    return /%$/.test(size);
  }
  toPixels(size) {
    let result2 = parseFloat(size);
    if (this.isPercent(size)) {
      result2 = this.state.splitterContainerSize * result2 / 100;
    }
    return result2;
  }
  tooglePane(paneIndex, nearPaneIndex, lockStatus) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const pane = this.getPane(paneIndex);
    const nearPane = this.getPane(nearPaneIndex);
    if ((_b = (_a = pane == null ? void 0 : pane.component) == null ? void 0 : _a.props) == null ? void 0 : _b.collapsible) {
      pane.component.props.collapsed = lockStatus ? (_d = (_c = pane == null ? void 0 : pane.component) == null ? void 0 : _c.props) == null ? void 0 : _d.collapsed : !((_f = (_e = pane == null ? void 0 : pane.component) == null ? void 0 : _e.props) == null ? void 0 : _f.collapsed);
      (_j = (_g = nearPane == null ? void 0 : nearPane.component) == null ? void 0 : _g.exposed) == null ? void 0 : _j.toggleNearPaneFlexGrow((_i = (_h = pane == null ? void 0 : pane.component) == null ? void 0 : _h.props) == null ? void 0 : _i.collapsed);
      (_m = pane == null ? void 0 : pane.component) == null ? void 0 : _m.emit("collapsedChange", (_l = (_k = pane == null ? void 0 : pane.component) == null ? void 0 : _k.props) == null ? void 0 : _l.collapsed);
    }
  }
  setSize(state, distance) {
    const prev = this.getPane(state.prev.index);
    const next = this.getPane(state.next.index);
    if (prev.component.props.size && next.component.props.size) {
      this.resize(state.prev, distance);
      this.resize(state.next, -distance);
    } else if (next.component.props.size) {
      this.resize(state.next, -distance);
    } else {
      this.resize(state.prev, distance);
    }
  }
}
const splitterProps = {
  orientation: {
    type: String,
    default: "horizontal"
  },
  splitBarSize: {
    type: String,
    default: "2px"
  },
  disabledBarSize: {
    type: String,
    default: "1px"
  },
  showCollapseButton: {
    type: Boolean,
    default: true
  }
};
var splitter = "";
var Splitter = defineComponent({
  name: "DSplitter",
  components: {
    DSplitterBar
  },
  props: splitterProps,
  emits: [],
  setup(props, ctx2) {
    var _a, _b;
    const store = new SplitterStore();
    const state = reactive({
      panes: []
    });
    const ns2 = useNamespace("splitter");
    state.panes = ((_b = (_a = ctx2.slots).DSplitterPane) == null ? void 0 : _b.call(_a)) || [];
    store.setPanes({
      panes: state.panes
    });
    provide("orientation", props.orientation);
    provide("splitterStore", store);
    const domRef = ref();
    const refreshSplitterContainerSize = () => {
      if (!domRef.value) {
        return;
      }
      let containerSize = 0;
      if (props.orientation === "vertical") {
        containerSize = domRef.value.clientHeight;
      } else {
        containerSize = domRef.value.clientWidth;
      }
      store.setSplitter({
        containerSize
      });
    };
    useResizeObserver(domRef, refreshSplitterContainerSize);
    return () => {
      const {
        splitBarSize,
        orientation,
        showCollapseButton
      } = props;
      const wrapperClass = [ns2.b(), ns2.m(orientation)];
      return createVNode("div", {
        "class": wrapperClass,
        "ref": domRef
      }, [state.panes, state.panes.filter((pane, index2, arr) => index2 !== arr.length - 1).map((pane, index2) => {
        return createVNode(resolveComponent("d-splitter-bar"), {
          "key": index2,
          "style": `order: ${index2 * 2 + 1}`,
          "splitBarSize": splitBarSize,
          "orientation": orientation,
          "index": index2,
          "showCollapseButton": showCollapseButton
        }, null);
      })]);
    };
  }
});
const splitterPaneProps = {
  size: {
    type: String
  },
  minSize: {
    type: String
  },
  maxSize: {
    type: String
  },
  resizable: {
    type: Boolean,
    default: true
  },
  collapsible: {
    type: Boolean,
    default: false
  },
  collapsed: {
    type: Boolean,
    default: false
  },
  collapseDirection: {
    type: String,
    default: "both"
  },
  shrink: {
    type: Boolean,
    default: false
  },
  shrinkWidth: {
    type: Number,
    default: 36
  }
};
var splitterPane = "";
var SplitterPane = defineComponent({
  name: "DSplitterPane",
  props: splitterPaneProps,
  emits: ["sizeChange", "collapsedChange"],
  setup(props, {
    slots,
    expose
  }) {
    const store = inject("splitterStore");
    const domRef = ref();
    const orderRef = ref();
    const ns2 = useNamespace("splitter");
    watch([orderRef, domRef], ([order, ele]) => {
      if (!ele) {
        return;
      }
      setStyle(ele, {
        order
      });
    });
    const setSizeStyle = (curSize, ele) => {
      if (!ele) {
        return;
      }
      ele.style.flexBasis = curSize;
      const paneFixedClass = ns2.em("pane", "fixed");
      if (curSize) {
        addClass(ele, paneFixedClass);
      } else {
        removeClass(ele, paneFixedClass);
      }
    };
    watch([() => props.size, domRef], ([size, ele]) => {
      if (size && ele) {
        setSizeStyle(size, ele);
      }
    }, {
      immediate: true
    });
    const orientation = inject("orientation");
    let initialSize = "";
    onMounted(() => {
      if (props.size) {
        initialSize = props.size;
      }
      if (store) {
        store.setPanes({
          panes: store.state.panes
        });
      }
    });
    onUpdated(() => {
      if (store) {
        store.setPanes({
          panes: store.state.panes
        });
      }
    });
    const getPaneSize = () => {
      const ele = domRef.value;
      if (!ele) {
        return 0;
      }
      if (orientation === "vertical") {
        return ele.offsetHeight;
      } else {
        return ele.offsetWidth;
      }
    };
    watch([() => props.collapsed, domRef], ([collapsed, ele]) => {
      if (!ele) {
        return;
      }
      const paneHiddenClass = ns2.em("pane", "hidden");
      if (!collapsed) {
        removeClass(ele, paneHiddenClass);
      } else {
        addClass(ele, paneHiddenClass);
      }
      if (collapsed && props.shrink) {
        removeClass(ele, paneHiddenClass);
        setStyle(ele, {
          flexBasis: `${props.shrinkWidth}px`
        });
      } else {
        setStyle(ele, {
          flexBasis: initialSize
        });
      }
    }, {
      immediate: true
    });
    const toggleNearPaneFlexGrow = (collapsed) => {
      const ele = domRef.value;
      if (!isHTMLElement(ele)) {
        return;
      }
      const flexGrowClass = ns2.em("pane", "grow");
      if (hasClass(ele, flexGrowClass)) {
        removeClass(ele, flexGrowClass);
      } else if (collapsed) {
        addClass(ele, flexGrowClass);
      }
    };
    expose({
      order: orderRef,
      getPaneSize,
      toggleNearPaneFlexGrow
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": ns2.e("pane"),
        "ref": domRef
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var SplitterInstall = {
  title: "Splitter \u5206\u5272\u5668",
  category: "\u5E03\u5C40",
  status: "100%",
  install(app) {
    app.component(Splitter.name, Splitter);
    app.component(SplitterPane.name, SplitterPane);
  }
};
const statisticProps = {
  title: {
    type: String,
    default: ""
  },
  value: {
    type: [Number, String]
  },
  prefix: {
    type: String
  },
  suffix: {
    type: String
  },
  precision: {
    type: Number
  },
  groupSeparator: {
    type: String,
    default: ""
  },
  animationDuration: {
    type: Number,
    default: 2e3
  },
  valueFrom: {
    type: Number
  },
  animation: {
    type: Boolean,
    default: false
  },
  start: {
    type: Boolean,
    default: true
  },
  extra: {
    type: String,
    default: ""
  }
};
const separator = (SeparatorString, groupSeparator) => {
  const res = SeparatorString.replace(/\d+/, function(n) {
    return n.replace(/(\d)(?=(\d{3})+$)/g, function($1) {
      return $1 + `${groupSeparator}`;
    });
  });
  return res;
};
const isHasDot = (value) => {
  if (!isNaN(value)) {
    return (value + "").indexOf(".") !== -1;
  }
  return false;
};
const analysisValueType = (value, propsValue, groupSeparator, splitPrecisionNumber) => {
  const fixedNumber = (propsValue == null ? void 0 : propsValue.toString().indexOf(".")) !== -1 ? (propsValue == null ? void 0 : propsValue.toString().length) - (propsValue == null ? void 0 : propsValue.toString().indexOf(".")) - 1 : 0;
  if (typeof value === "number") {
    if (isHasDot(value)) {
      return splitPrecisionNumber ? separator(value.toFixed(splitPrecisionNumber).toString(), groupSeparator) : separator(value.toFixed(fixedNumber).toString(), groupSeparator);
    } else {
      return splitPrecisionNumber ? separator(value.toFixed(splitPrecisionNumber).toString(), groupSeparator) : separator(value.toString(), groupSeparator);
    }
  } else {
    return value;
  }
};
const pow = Math.pow;
const sqrt = Math.sqrt;
const easeOutCubic = function(x) {
  return 1 - pow(1 - x, 3);
};
const linear = (x) => x;
const easeOutExpo = function(x) {
  return x === 1 ? 1 : 1 - pow(2, -10 * x);
};
const easeInOutExpo = function(x) {
  return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2;
};
const easeInExpo = function(x) {
  return x === 0 ? 0 : pow(2, 10 * x - 10);
};
const easeInOutCirc = function(x) {
  return x < 0.5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;
};
var easing = { easeOutCubic, linear, easeOutExpo, easeInOutExpo, easeInExpo, easeInOutCirc };
class Tween {
  constructor(options) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "duration");
    __publicField(this, "delay");
    __publicField(this, "easing");
    __publicField(this, "onStart");
    __publicField(this, "onUpdate");
    __publicField(this, "onFinish");
    __publicField(this, "startTime");
    __publicField(this, "started");
    __publicField(this, "finished");
    __publicField(this, "timer");
    __publicField(this, "time");
    __publicField(this, "elapsed");
    __publicField(this, "keys");
    const { from, to, duration, delay, easing: easingValue, onStart, onUpdate, onFinish } = options;
    for (const key in from) {
      if (to[key] === void 0) {
        to[key] = from[key];
      }
    }
    for (const key in to) {
      if (from[key] === void 0) {
        from[key] = to[key];
      }
    }
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.delay = delay;
    this.easing = easingValue;
    this.onStart = onStart;
    this.onUpdate = onUpdate;
    this.onFinish = onFinish;
    this.startTime = Date.now() + this.delay;
    this.started = false;
    this.finished = false;
    this.timer = null;
    this.keys = {};
  }
  update() {
    this.time = Date.now();
    if (this.time < this.startTime) {
      return;
    }
    if (this.finished) {
      return;
    }
    if (this.elapsed === this.duration) {
      if (!this.finished) {
        this.finished = true;
        this.onFinish && this.onFinish(this.keys);
      }
      return;
    }
    this.elapsed = this.time - this.startTime;
    this.elapsed = this.elapsed > this.duration ? this.duration : this.elapsed;
    for (const key in this.to) {
      this.keys[key] = this.from[key] + (this.to[key] - this.from[key]) * easing[this.easing](this.elapsed / this.duration);
    }
    if (!this.started) {
      this.onStart && this.onStart(this.keys);
      this.started = true;
    }
    this.onUpdate(this.keys);
  }
  start() {
    this.startTime = Date.now() + this.delay;
    const tick = () => {
      this.update();
      this.timer = requestAnimationFrame(tick);
      if (this.finished) {
        cancelAnimationFrame(this.timer);
        this.timer = null;
      }
    };
    tick();
  }
  stop() {
    cancelAnimationFrame(this.timer);
    this.timer = null;
  }
}
var statistic = "";
var Statistic = defineComponent({
  name: "DStatistic",
  props: statisticProps,
  setup(props, ctx2) {
    var _a;
    const innerValue = ref((_a = props.valueFrom) != null ? _a : props.value);
    const tween = ref(null);
    const ns2 = useNamespace("statistic");
    const animation = (from = ((_b) => (_b = props.valueFrom) != null ? _b : 0)(), to = typeof props.value === "number" ? props.value : Number(props.value)) => {
      if (from !== to) {
        tween.value = new Tween({
          from: {
            value: from
          },
          to: {
            value: to
          },
          delay: 0,
          duration: props.animationDuration,
          easing: "easeOutCubic",
          onUpdate: (keys2) => {
            innerValue.value = keys2.value;
          },
          onFinish: () => {
            innerValue.value = to;
          }
        });
        tween.value.start();
      }
    };
    const statisticValue = computed(() => {
      return analysisValueType(innerValue.value, props.value, props.groupSeparator, props.precision);
    });
    onMounted(() => {
      if (props.animation && props.start) {
        animation();
      }
    });
    watch(() => props.start, (value) => {
      if (value && !tween.value) {
        animation();
      }
    });
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      return createVNode("div", {
        "class": ns2.b()
      }, [createVNode("div", {
        "class": ns2.e("title")
      }, [((_b = (_a2 = ctx2.slots).title) == null ? void 0 : _b.call(_a2)) || props.title]), createVNode("div", {
        "class": ns2.e("content")
      }, [props.prefix || ((_d = (_c = ctx2.slots).prefix) == null ? void 0 : _d.call(_c)) ? createVNode("span", {
        "class": ns2.e("prefix")
      }, [((_f = (_e = ctx2.slots).prefix) == null ? void 0 : _f.call(_e)) || props.prefix]) : null, createVNode("span", {
        "class": ns2.e("value")
      }, [statisticValue.value]), props.suffix || ((_h = (_g = ctx2.slots).suffix) == null ? void 0 : _h.call(_g)) ? createVNode("span", {
        "class": ns2.e("suffix")
      }, [((_j = (_i = ctx2.slots).suffix) == null ? void 0 : _j.call(_i)) || props.suffix]) : null]), props.extra || ((_l = (_k = ctx2.slots).extra) == null ? void 0 : _l.call(_k)) ? createVNode("div", {
        "class": ns2.e("extra")
      }, [createTextVNode(" "), ((_n = (_m = ctx2.slots).extra) == null ? void 0 : _n.call(_m)) || props.extra]) : null]);
    };
  }
});
var StatisticInstall = {
  title: "Statistic \u7EDF\u8BA1\u6570\u503C",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Statistic.name, Statistic);
  }
};
var status = "";
var Status = defineComponent({
  name: "DStatus",
  props: {
    type: {
      default: "invalid",
      type: String
    }
  },
  setup(props, ctx2) {
    const ns2 = useNamespace("status");
    const typeClass = computed(() => {
      const {
        type: type4
      } = props;
      const typeStatus = ["success", "error", "initial", "warning", "waiting", "running", "invalid"];
      let typeClassStr = `${ns2.b()} ${ns2.em("bg", "invalid")}`;
      if (typeStatus.includes(type4)) {
        typeClassStr = `${ns2.b()} ${ns2.em("bg", type4)}`;
      }
      return typeClassStr;
    });
    return () => {
      var _a, _b;
      return createVNode("span", {
        "class": typeClass.value
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var StatusInstall = {
  title: "Status \u72B6\u6001",
  category: "\u901A\u7528",
  status: "100%",
  deprecated: {
    value: true,
    reason: "Status \u662F\u65E0\u5185\u5BB9\u5305\u88F9\u72B6\u6001\u4E0B\u7684 Badge \u7EC4\u4EF6\uFF0C\u5E94\u8BE5\u4F7F\u7528 Badge \u66FF\u4EE3\u3002"
  },
  install(app) {
    app.component(Status.name, Status);
  }
};
const stepsProps = {
  modelValue: {
    type: Number,
    default: 0
  },
  space: {
    type: Number
  },
  alignCenter: {
    type: Boolean,
    default: false
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  simple: {
    type: Boolean,
    default: false
  }
};
var steps = "";
const ACTIVE_STEP = "active-step";
const STEPS = "steps";
const STEPS_PROPS = "steps-props";
var Steps = defineComponent({
  name: "DSteps",
  props: stepsProps,
  emits: ["update:modelValue"],
  setup(props, {
    slots
  }) {
    const {
      modelValue,
      direction,
      simple
    } = toRefs(props);
    const ns2 = useNamespace("steps");
    const activeStep = ref(modelValue.value);
    provide(ACTIVE_STEP, activeStep);
    provide(STEPS_PROPS, props);
    const steps2 = ref([]);
    provide(STEPS, steps2);
    watch(modelValue, (newVal) => {
      activeStep.value = newVal;
    });
    const stepsClass = computed(() => {
      const directionClass = direction.value === "vertical" ? " vertical" : "";
      const simpleClass = simple.value ? " simple" : "";
      return `${ns2.b()}${directionClass}${simpleClass}`;
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": stepsClass.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
const stepProps = {
  title: {
    type: String,
    required: true
  },
  description: {
    type: String
  },
  icon: {
    type: String
  },
  status: {
    type: String
  }
};
var step = "";
var Step = defineComponent({
  name: "DStep",
  props: stepProps,
  setup(props, {
    slots
  }) {
    const {
      title,
      description,
      icon: icon2,
      status: status2
    } = toRefs(props);
    const ns2 = useNamespace("step");
    const instance = getCurrentInstance();
    const activeStep = inject(ACTIVE_STEP);
    const steps2 = inject(STEPS);
    steps2.value.push(instance);
    const stepsProps2 = inject(STEPS_PROPS);
    const currentStepIndex = steps2.value.indexOf(instance);
    const stepClass = computed(() => {
      const activeClass = activeStep.value === currentStepIndex ? " active" : "";
      const finishedClass = activeStep.value > currentStepIndex ? " finished" : "";
      const centerClass = stepsProps2.alignCenter ? " center" : "";
      const statusClass = (status2 == null ? void 0 : status2.value) ? ` ${status2 == null ? void 0 : status2.value}` : "";
      const simpleClass = stepsProps2.simple ? ` ${ns2.m("simple")}` : "";
      return `${ns2.b()}${activeClass}${finishedClass}${centerClass}${statusClass}${simpleClass}`;
    });
    const stepStyle = computed(() => {
      const styleObj = {};
      if (stepsProps2.space) {
        styleObj.width = `${stepsProps2.space}px`;
      } else {
        styleObj.flexBasis = stepsProps2.alignCenter || stepsProps2.simple ? `${100 / steps2.value.length}%` : `${100 / (steps2.value.length - 1)}%`;
      }
      return styleObj;
    });
    const iconColor = computed(() => {
      const isActive = activeStep.value === currentStepIndex;
      const isFinished = activeStep.value > currentStepIndex;
      return isActive ? "var(--b-brand)" : isFinished ? "var(--b-success)" : "var(--b-placeholder)";
    });
    const statusMap = {
      finish: createVNode(DIcon, {
        "name": "right-o",
        "color": "var(--b-success)",
        "size": "24px"
      }, null),
      success: createVNode(DIcon, {
        "name": "right-o",
        "color": "var(--b-success)",
        "size": "24px"
      }, null),
      error: createVNode(DIcon, {
        "name": "error-o",
        "color": "var(--b-danger)",
        "size": "24px"
      }, null)
    };
    const renderDot = () => {
      var _a;
      return slots.icon ? (_a = slots.icon) == null ? void 0 : _a.call(slots, iconColor.value) : icon2.value ? createVNode(DIcon, {
        "name": icon2.value,
        "color": iconColor.value,
        "size": "24px"
      }, null) : status2.value && statusMap[status2.value] ? statusMap[status2.value] : activeStep.value > steps2.value.indexOf(instance) ? createVNode(DIcon, {
        "name": "right-o",
        "color": "var(--b-success)",
        "size": "24px"
      }, null) : createVNode("span", {
        "class": ns2.e("dot")
      }, [currentStepIndex + 1]);
    };
    return () => {
      return createVNode(Fragment, null, [stepsProps2.simple ? createVNode("div", {
        "class": stepClass.value,
        "style": stepStyle.value
      }, [title.value]) : createVNode("div", {
        "class": stepClass.value,
        "style": stepStyle.value
      }, [createVNode("div", {
        "class": ns2.e("dot-container")
      }, [renderDot(), createVNode("div", {
        "class": ns2.e("line")
      }, null)]), createVNode("div", {
        "class": ns2.e("content")
      }, [createVNode("span", {
        "class": ns2.e("title")
      }, [title.value]), description.value && createVNode("span", {
        "class": ns2.e("description")
      }, [description.value])])])]);
    };
  }
});
var StepsInstall = {
  title: "Steps \u6B65\u9AA4\u6761",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Steps.name, Steps);
    app.component(Step.name, Step);
  }
};
const stepsGuideProps = {
  steps: Array,
  stepIndex: {
    type: Number,
    default: void 0
  },
  showClose: {
    type: Boolean,
    default: true
  },
  showDots: {
    type: Boolean,
    default: true
  },
  scrollToTargetSwitch: {
    type: Boolean,
    default: true
  },
  zIndex: {
    type: Number,
    default: 1100
  },
  stepChange: {
    type: Function,
    default() {
      return true;
    }
  }
};
function useStepsGuidePosition(props, currentStep) {
  const guideClassList = reactive([useNamespace("steps-guide").b()]);
  const stepsRef = ref(null);
  const guidePosition = reactive({
    left: "",
    top: "",
    zIndex: props.zIndex
  });
  const updateGuidePosition = () => {
    if (!currentStep.value || !stepsRef.value) {
      return;
    }
    const baseTop = window.pageYOffset - document.documentElement.clientTop;
    const baseLeft = window.pageXOffset - document.documentElement.clientLeft;
    const currentStepPosition = currentStep.value.position;
    const stepGuideElement = stepsRef.value;
    let _left, _top;
    if (typeof currentStepPosition !== "string") {
      const { top = 0, left = 0, type: type4 = "top" } = currentStepPosition;
      guideClassList.splice(1, 1, type4);
      _left = left;
      _top = top;
    } else {
      guideClassList.splice(1, 1, currentStepPosition);
      const triggerSelector = currentStep.value.target || currentStep.value.trigger;
      const triggerElement = document.querySelector(triggerSelector);
      if (!triggerElement) {
        console.warn(`${triggerSelector} \u4E0D\u5B58\u5728!`);
        return false;
      }
      const targetRect = triggerElement.getBoundingClientRect();
      _left = targetRect.left + triggerElement.clientWidth / 2 - stepGuideElement.clientWidth / 2 + baseLeft;
      _top = targetRect.top + triggerElement.clientHeight / 2 - stepGuideElement.clientHeight / 2 + baseTop;
      const positionTypes = currentStepPosition.split("-");
      switch (positionTypes[0]) {
        case "top":
          _top += -stepGuideElement.clientHeight / 2 - triggerElement.clientHeight;
          break;
        case "bottom":
          _top += stepGuideElement.clientHeight / 2 + triggerElement.clientHeight;
          break;
        case "left":
          _top += stepGuideElement.clientHeight / 2 - triggerElement.clientHeight;
          _left += -stepGuideElement.clientWidth / 2 - triggerElement.clientWidth / 2;
          break;
        case "right":
          _top += stepGuideElement.clientHeight / 2 - triggerElement.clientHeight;
          _left += stepGuideElement.clientWidth / 2 + triggerElement.clientWidth / 2;
          break;
      }
      switch (positionTypes[1]) {
        case "left":
          _left += stepGuideElement.clientWidth / 2 - triggerElement.clientWidth / 2;
          break;
        case "right":
          _left += -stepGuideElement.clientWidth / 2 + triggerElement.clientWidth / 2;
          break;
      }
    }
    guidePosition.left = _left + "px";
    guidePosition.top = _top + "px";
    if (props.scrollToTargetSwitch && typeof stepGuideElement.scrollIntoView === "function") {
      nextTick(() => {
        stepGuideElement.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
      });
    }
  };
  return {
    stepsRef,
    guidePosition,
    guideClassList,
    updateGuidePosition
  };
}
function useStepsGuideCtrl(props, ctx2, updateGuidePosition, stepIndex) {
  const stepsCount = computed(() => props.steps.length);
  const closeGuide = () => {
    const _index = stepIndex.value;
    stepIndex.value = -1;
    nextTick(() => {
      ctx2.emit("guide-close", _index);
    });
  };
  const setCurrentIndex = (index2) => {
    if (index2 !== -1 && props.stepChange()) {
      if (index2 > -1 && index2 < stepsCount.value) {
        stepIndex.value = index2;
        nextTick(() => {
          updateGuidePosition();
        });
      } else {
        console.error(`stepIndex is not within the value range`);
      }
    }
    if (index2 === -1) {
      closeGuide();
    }
  };
  return {
    stepsCount,
    closeGuide,
    setCurrentIndex
  };
}
var stepsGuide = "";
var StepsGuide = defineComponent({
  name: "DStepsGuide",
  props: stepsGuideProps,
  emits: ["guide-close", "update:stepIndex"],
  setup(props, ctx2) {
    var _a;
    const app = getCurrentInstance();
    const t = createI18nTranslate("DStepsGuide", app);
    const ns2 = useNamespace("steps-guide");
    const stepIndexData = ref((_a = props.stepIndex) != null ? _a : 0);
    const stepIndex = computed({
      set: (val) => {
        if (props.stepIndex != null) {
          ctx2.emit("update:stepIndex", val);
        }
        stepIndexData.value = val;
      },
      get: () => stepIndexData.value
    });
    const currentStep = computed(() => {
      const _step = props.steps[stepIndex.value];
      if (_step) {
        _step.position = _step.position || "top";
      }
      return _step;
    });
    const {
      stepsRef,
      guidePosition,
      guideClassList,
      updateGuidePosition
    } = useStepsGuidePosition(props, currentStep);
    const {
      stepsCount,
      closeGuide,
      setCurrentIndex
    } = useStepsGuideCtrl(props, ctx2, updateGuidePosition, stepIndex);
    onMounted(() => {
      updateGuidePosition();
    });
    ctx2.expose({
      closeGuide,
      setCurrentIndex
    });
    return () => stepIndex.value > -1 && stepsCount.value > 0 ? createVNode(Teleport, {
      "to": "body"
    }, {
      default: () => [createVNode("div", {
        "style": guidePosition,
        "class": guideClassList,
        "ref": stepsRef
      }, [createVNode("div", {
        "class": ns2.e("shining-dot")
      }, null), createVNode("div", {
        "class": ns2.e("shining-plus")
      }, null), createVNode("div", {
        "class": ns2.e("arrow")
      }, null), createVNode("div", {
        "class": ns2.e("container")
      }, [createVNode("p", {
        "class": ns2.e("title")
      }, [currentStep.value.title]), props.showClose ? createVNode("div", {
        "class": "icon icon-close",
        "onClick": closeGuide
      }, null) : null, createVNode("div", null, [currentStep.value.content]), createVNode("div", {
        "class": ns2.e("ctrl")
      }, [props.showDots ? createVNode("div", {
        "class": ns2.e("dots")
      }, [props.steps.map((step2, index2) => {
        return createVNode("em", {
          "class": ["icon icon-dot-status", currentStep.value === step2 ? ns2.e("active") : ""],
          "key": index2
        }, null);
      })]) : null, createVNode("div", {
        "class": ns2.e("btn")
      }, [stepIndex.value > 0 ? createVNode("div", {
        "class": ns2.e("prev-step"),
        "onClick": () => setCurrentIndex(stepIndex.value - 1)
      }, [t("previous")]) : null, stepIndex.value === stepsCount.value - 1 ? createVNode("div", {
        "onClick": closeGuide
      }, [t("ok")]) : createVNode("div", {
        "onClick": () => {
          setCurrentIndex(stepIndex.value + 1);
        }
      }, [t("continue")])])])])])]
    }) : null;
  }
});
var StepsGuideDirective = {
  mounted(el, binding, vNode) {
  },
  updated(el, binding) {
  }
};
var StepsGuideInstall = {
  title: "StepsGuide \u64CD\u4F5C\u6307\u5F15",
  category: "\u5BFC\u822A",
  status: "80%",
  install(app) {
    app.component(StepsGuide.name, StepsGuide);
    app.directive("StepsGuide", StepsGuideDirective);
  }
};
var Sticky = defineComponent({
  name: "DSticky",
  props: {
    zIndex: {
      type: Number
    },
    container: {
      type: Object
    },
    view: {
      type: Object,
      default: () => {
        return {
          top: 0,
          bottom: 0
        };
      }
    },
    scrollTarget: {
      type: Object
    }
  },
  emits: ["statusChange"],
  setup(props, ctx2) {
    const {
      slots
    } = ctx2;
    let container;
    let scrollTarget;
    let scrollTimer;
    let scrollPreStart;
    const THROTTLE_DELAY = 16;
    const THROTTLE_TRIGGER = 100;
    let parentNode;
    let containerLeft = 0;
    const state = reactive({
      status: "normal"
    });
    watch(() => props.zIndex, () => {
      init();
    });
    watch(() => props.container, () => {
      init();
    });
    watch(() => props.scrollTarget, () => {
      init();
    });
    watch(() => state.status, () => {
      ctx2.emit("statusChange", state.status);
    }, {
      immediate: true
    });
    const init = () => {
      parentNode = stickyRef.value.parentElement;
      if (!props.container) {
        container = parentNode;
      } else {
        container = props.container;
      }
      stickyRef.value.style.zIndex = props.zIndex;
      scrollTarget = props.scrollTarget || window;
      scrollTarget.addEventListener("scroll", throttle);
      initScrollStatus(scrollTarget);
    };
    const initScrollStatus = (target) => {
      const scrollTargets = target === window ? [document.documentElement, document.body] : [target];
      let flag = false;
      scrollTargets.forEach((scrollTarget2) => {
        if (scrollTarget2.scrollTop && scrollTarget2.scrollTop > 0) {
          flag = true;
        }
      });
      if (flag) {
        setTimeout(scrollHandler);
      }
    };
    const statusProcess = (status2) => {
      const wrapper = stickyRef.value || document.createElement("div");
      switch (status2) {
        case "normal":
          wrapper.style.top = "auto";
          wrapper.style.left = "auto";
          wrapper.style.position = "static";
          break;
        case "follow":
          const scrollTargetElement = scrollTarget;
          const viewOffset = scrollTarget && scrollTarget !== window ? scrollTargetElement.getBoundingClientRect().top : 0;
          wrapper.style.top = +viewOffset + (props.view && props.view.top || 0) + "px";
          wrapper.style.left = wrapper.getBoundingClientRect().left + "px";
          wrapper.style.position = "fixed";
          break;
        case "stay":
          wrapper.style.top = calculateRelativePosition(wrapper, parentNode, "top") + "px";
          wrapper.style.left = "auto";
          wrapper.style.position = "relative";
          break;
        case "remain":
          if (wrapper.style.position !== "fixed" && wrapper.style.position !== "absolute") {
            wrapper.style.top = calculateRelativePosition(wrapper, parentNode, "top") + "px";
            wrapper.style.left = "auto";
            wrapper.style.position = "absolute";
          }
          wrapper.style.top = calculateRemainPosition(wrapper, parentNode, container) + "px";
          wrapper.style.left = calculateRelativePosition(wrapper, parentNode, "left") + "px";
          wrapper.style.position = "relative";
          break;
      }
    };
    const throttle = () => {
      const fn = scrollAndResizeHock;
      const time = Date.now();
      if (scrollTimer) {
        clearTimeout(scrollTimer);
      }
      if (!scrollPreStart) {
        scrollPreStart = time;
      }
      if (time - scrollPreStart > THROTTLE_TRIGGER) {
        fn();
        scrollPreStart = null;
        scrollTimer = null;
      } else {
        scrollTimer = setTimeout(() => {
          fn();
          scrollPreStart = null;
          scrollTimer = null;
        }, THROTTLE_DELAY);
      }
    };
    const scrollAndResizeHock = () => {
      if (container.getBoundingClientRect().left - (containerLeft || 0) !== 0) {
        state.status = "stay";
        containerLeft = container.getBoundingClientRect().left;
      } else {
        scrollHandler();
      }
    };
    const scrollHandler = () => {
      const scrollTargetElement = scrollTarget;
      const wrapper = stickyRef.value || document.createElement("div");
      const viewOffsetTop = scrollTarget && scrollTarget !== window ? scrollTargetElement.getBoundingClientRect().top : 0;
      const computedStyle = window.getComputedStyle(container);
      if (parentNode.getBoundingClientRect().top - viewOffsetTop > (props.view && props.view.top || 0)) {
        state.status = "normal";
        statusProcess(state.status);
      } else if (container.getBoundingClientRect().top + parseInt(computedStyle.paddingTop, 10) + parseInt(computedStyle.borderTopWidth, 10) - viewOffsetTop >= (props.view && props.view.top || 0)) {
        state.status = "normal";
        statusProcess(state.status);
      } else if (container.getBoundingClientRect().bottom - parseInt(computedStyle.paddingBottom, 10) - parseInt(computedStyle.borderBottomWidth, 10) < viewOffsetTop + (props.view && props.view.top || 0) + wrapper.getBoundingClientRect().height + (props.view && props.view.bottom || 0)) {
        state.status = "remain";
        statusProcess(state.status);
      } else if (container.getBoundingClientRect().top + parseInt(computedStyle.paddingTop, 10) - viewOffsetTop < (props.view && props.view.top || 0)) {
        state.status = "follow";
        statusProcess(state.status);
      }
    };
    const calculateRelativePosition = (element, relativeElement, direction) => {
      const key = {
        left: ["left", "Left"],
        top: ["top", "Top"]
      };
      if (window && window.getComputedStyle) {
        const computedStyle = window.getComputedStyle(relativeElement);
        return element.getBoundingClientRect()[key[direction][0]] - relativeElement.getBoundingClientRect()[key[direction][0]] - parseInt(computedStyle[direction === "left" ? "paddingLeft" : "paddingTop"], 10) - parseInt(computedStyle[direction === "left" ? "borderLeftWidth" : "borderTopWidth"], 10);
      }
    };
    const calculateRemainPosition = (element, relativeElement, container2) => {
      if (window && window.getComputedStyle) {
        const computedStyle = window.getComputedStyle(container2);
        const result2 = container2.getBoundingClientRect().height - element.getBoundingClientRect().height + container2.getBoundingClientRect().top - relativeElement.getBoundingClientRect().top - parseInt(computedStyle["paddingTop"], 10) - parseInt(computedStyle["borderTopWidth"], 10) - parseInt(computedStyle["paddingBottom"], 10) - parseInt(computedStyle["borderBottomWidth"], 10);
        return result2 < 0 ? 0 : result2;
      }
    };
    onMounted(() => {
      init();
    });
    const stickyRef = ref();
    return () => {
      return createVNode("div", {
        "ref": stickyRef
      }, [slots.default ? slots.default() : ""]);
    };
  }
});
Sticky.install = function(app) {
  app.component(Sticky.name, Sticky);
};
var StickyInstall = {
  title: "Sticky \u4FBF\u8D34",
  category: "\u901A\u7528",
  status: "50%",
  install(app) {
    app.use(Sticky);
  }
};
const switchProps = {
  modelValue: {
    type: [String, Number, Boolean],
    default: false
  },
  size: {
    type: String
  },
  color: {
    type: String,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: false
  },
  beforeChange: {
    type: Function,
    default: void 0
  },
  change: {
    type: Function,
    default: void 0
  },
  activeValue: {
    type: [String, Number, Boolean],
    default: true
  },
  inactiveValue: {
    type: [String, Number, Boolean],
    default: false
  }
};
function useSwitch(props, ctx2) {
  const formContext = inject(FORM_TOKEN, void 0);
  const switchDisabled = computed(() => (formContext == null ? void 0 : formContext.disabled) || props.disabled);
  const switchSize = computed(() => props.size || (formContext == null ? void 0 : formContext.size) || "md");
  const canChange = () => {
    if (switchDisabled.value) {
      return Promise.resolve(false);
    }
    if (props.beforeChange) {
      const res = props.beforeChange(!props.modelValue);
      return typeof res === "boolean" ? Promise.resolve(res) : res;
    }
    return Promise.resolve(true);
  };
  const checked = computed(() => {
    return props.modelValue === props.activeValue;
  });
  watch(checked, () => {
    if (![props.activeValue, props.inactiveValue].includes(props.modelValue)) {
      ctx2.emit("update:modelValue", props.inactiveValue);
    }
  });
  const toggle = () => {
    canChange().then((res) => {
      if (!res) {
        return;
      }
      const val = !checked.value ? props.activeValue : props.inactiveValue;
      ctx2.emit("update:modelValue", val);
      ctx2.emit("change", val);
    });
  };
  return { toggle, checked, switchDisabled, switchSize };
}
var _switch = "";
var Switch = defineComponent({
  name: "DSwitch",
  props: switchProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("switch");
    const {
      toggle,
      checked,
      switchDisabled,
      switchSize
    } = useSwitch(props, ctx2);
    return () => {
      const switchCls = {
        [ns2.b()]: true,
        [ns2.m(switchSize.value)]: true
      };
      const switchWrapperCls = {
        [ns2.e("wrapper")]: true,
        [ns2.m("checked")]: checked.value,
        [ns2.m("disabled")]: switchDisabled.value
      };
      const switchWrapperStyle = [`background: ${checked.value && !switchDisabled.value ? props.color : ""}`, `border-color: ${checked.value && !switchDisabled.value ? props.color : ""}`];
      const checkedContent = renderSlot(useSlots(), "checkedContent");
      const uncheckedContent = renderSlot(useSlots(), "uncheckedContent");
      return createVNode("div", {
        "class": switchCls
      }, [createVNode("span", {
        "class": switchWrapperCls,
        "style": switchWrapperStyle,
        "onClick": toggle
      }, [createVNode("span", {
        "class": ns2.e("inner-wrapper")
      }, [createVNode("div", {
        "class": ns2.e("inner")
      }, [checked.value ? checkedContent : uncheckedContent])]), createVNode("small", null, null)])]);
    };
  }
});
var SwitchInstall = {
  title: "Switch \u5F00\u5173",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Switch.name, Switch);
  }
};
const tableProps = {
  data: {
    type: Array,
    default: []
  },
  striped: {
    type: Boolean,
    default: false
  },
  scrollable: {
    type: Boolean,
    default: false
  },
  maxWidth: {
    type: String
  },
  maxHeight: {
    type: String
  },
  tableWidth: {
    type: String
  },
  tableHeight: {
    type: String
  },
  size: {
    type: String,
    validator(value) {
      return value === "sm" || value === "md" || value === "lg";
    },
    default: "sm"
  },
  rowHoveredHighlight: {
    type: Boolean,
    default: true
  },
  fixHeader: {
    type: Boolean,
    default: false
  },
  checkable: {
    type: Boolean,
    default: false
  },
  tableLayout: {
    type: String,
    default: "fixed",
    validator(v) {
      return v === "fixed" || v === "auto";
    }
  },
  showLoading: {
    type: Boolean,
    default: false
  },
  headerBg: {
    type: Boolean,
    default: false
  },
  spanMethod: {
    type: Function
  },
  borderType: {
    type: String,
    default: ""
  },
  empty: {
    type: String,
    default: "No Data"
  },
  showHeader: {
    type: Boolean,
    default: true
  },
  rowKey: {
    type: [Function, String],
    default: "id"
  },
  defaultExpandAll: {
    type: Boolean,
    default: false
  },
  expandRowKeys: {
    type: Array
  },
  indent: {
    type: Number,
    default: 16
  },
  lazy: {
    type: Boolean,
    default: false
  }
};
const TABLE_TOKEN = Symbol();
function useTable(props, tableWidth) {
  const ns2 = useNamespace("table");
  const classes = computed(() => ({
    [ns2.e("view")]: true,
    [ns2.m("striped")]: props.striped,
    [ns2.m("header-bg")]: props.headerBg,
    [ns2.m("layout-auto")]: props.tableLayout === "auto",
    [ns2.m(`${props.size}`)]: true,
    [ns2.m(`${props.borderType}`)]: Boolean(props.borderType)
  }));
  const styles = computed(() => ({
    maxHeight: props.maxHeight,
    maxWidth: props.maxWidth,
    height: props.tableHeight,
    width: tableWidth.value ? `${tableWidth.value}px` : props.tableWidth
  }));
  return { classes, styles };
}
const useFixedColumn = (column2) => {
  const ns2 = useNamespace("table");
  const stickyClass = computed(() => ({
    [ns2.e("checkable-cell")]: column2.value.type === "checkable",
    [ns2.m("sticky-cell")]: Boolean(column2.value.fixedLeft) || Boolean(column2.value.fixedRight),
    left: Boolean(column2.value.fixedLeft),
    right: Boolean(column2.value.fixedRight),
    [`is-${column2.value.align}`]: true
  }));
  const stickyStyle = computed(() => ({
    left: column2.value.fixedLeft,
    right: column2.value.fixedRight
  }));
  return { stickyClass, stickyStyle };
};
function useTableLayout(table2) {
  const tableWidth = ref();
  const updateColgroupWidth = () => {
    var _a, _b;
    const cols = ((_b = (_a = table2 == null ? void 0 : table2.vnode) == null ? void 0 : _a.el) == null ? void 0 : _b.querySelectorAll("colgroup > col")) || [];
    if (!cols.length) {
      return;
    }
    const flatColumns = table2.store.states.flatColumns;
    const columnMap = {};
    flatColumns.value.forEach((column2) => {
      columnMap[column2.id] = column2;
    });
    for (let i = 0, len = cols.length; i < len; i++) {
      const col2 = cols[i];
      const columnId = col2.getAttribute("column-id");
      const column2 = columnMap[columnId];
      if (column2) {
        col2.setAttribute("width", column2.realWidth);
      }
    }
  };
  const updateColumnWidth = () => {
    var _a, _b;
    const tableClientWidth = (_b = (_a = table2 == null ? void 0 : table2.vnode) == null ? void 0 : _a.el) == null ? void 0 : _b.clientWidth;
    let tableMinWidth = 0;
    const flatColumns = table2.store.states.flatColumns;
    const flexColumns = flatColumns.value.filter((column2) => typeof column2.width !== "number");
    if (flexColumns.length) {
      flatColumns.value.forEach((column2) => {
        tableMinWidth += Number(column2.width || 80);
      });
      if (tableMinWidth <= tableClientWidth) {
        const totalFlexWidth = tableClientWidth - tableMinWidth;
        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].width || 80) + totalFlexWidth;
        } else {
          const allFlexColumnWidth = flexColumns.reduce((pre, column2) => pre + Number(column2.width || 80), 0);
          const flexWidthPercent = totalFlexWidth / allFlexColumnWidth;
          let exceptFistWidth = 0;
          flexColumns.forEach((column2, index2) => {
            if (index2 === 0) {
              return;
            }
            const perFlexWidth = Math.floor(Number(column2.width || 80) * flexWidthPercent);
            exceptFistWidth += perFlexWidth;
            column2.realWidth = Number(column2.width || 80) + perFlexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].width || 80) + totalFlexWidth - exceptFistWidth;
        }
      } else {
        flexColumns.forEach((column2) => {
          column2.realWidth = Number(column2.width || 80);
        });
      }
      tableWidth.value = Math.max(tableMinWidth, tableClientWidth);
    } else {
      flatColumns.value.forEach((column2) => {
        column2.realWidth = column2.width || 80;
        tableMinWidth += Number(column2.realWidth);
      });
      tableWidth.value = tableMinWidth;
    }
    updateColgroupWidth();
  };
  return { tableWidth, updateColumnWidth };
}
function useTableWatcher(props, store) {
  watchEffect(() => {
    if (props.expandRowKeys) {
      store.setExpandRows(props.expandRowKeys);
    }
  });
  watch(() => props.data, () => {
    store.updateRows();
    store.updateColumns();
  }, { deep: true });
}
function useHorizontalScroll(table2) {
  const ns2 = useNamespace("table");
  const setScrollViewClass = (position) => {
    const element = table2.vnode.el;
    const className2 = ns2.m(`scroll-${position}`);
    const elClassList = element.classList;
    if (!elClassList.contains(className2)) {
      for (let i = 0; i < elClassList.length; i++) {
        const clName = elClassList[i];
        if (clName.startsWith(ns2.m("scroll-"))) {
          elClassList.remove(clName);
        }
      }
      elClassList.add(className2);
    }
  };
  const onTableScroll = (e) => {
    const target = e.currentTarget;
    const scrollLeft = target.scrollLeft;
    if (scrollLeft === 0) {
      if (target.clientWidth === target.scrollWidth) {
        setScrollViewClass("none");
      } else {
        setScrollViewClass("left");
      }
    } else if (scrollLeft + target.clientWidth === target.scrollWidth) {
      setScrollViewClass("right");
    } else {
      setScrollViewClass("middle");
    }
  };
  return { onTableScroll };
}
function formatWidth(width) {
  if (width === "") {
    return width;
  }
  if (typeof width === "number") {
    return width;
  }
  return parseInt(width, 10) || 80;
}
function getRowIdentity(row2, rowKey, index2) {
  if (isFunction$3(rowKey)) {
    return rowKey(row2, index2);
  } else if (isString$2(rowKey)) {
    const paths = rowKey.split(".");
    let obj = row2;
    for (const p of paths) {
      obj = obj[p];
    }
    return `${obj}`;
  }
  return "";
}
function getRowKeysMap(data, rowKey) {
  const rowKeyMap = {};
  (data || []).forEach((row2, index2) => {
    rowKeyMap[getRowIdentity(row2, rowKey)] = { row: row2, index: index2 };
  });
  return rowKeyMap;
}
function toggleRowExpandStatus(rowsArr, row2, status2) {
  let isChanged = false;
  const index2 = rowsArr.indexOf(row2);
  const isIncluded = index2 !== -1;
  const addRow = () => {
    rowsArr.push(row2);
    isChanged = true;
  };
  const deleteRow = () => {
    rowsArr.splice(index2, 1);
    isChanged = true;
  };
  if (isBoolean(status2)) {
    if (status2 && !isIncluded) {
      addRow();
    } else if (!status2 && isIncluded) {
      deleteRow();
    }
  } else {
    if (isIncluded) {
      deleteRow();
    } else {
      addRow();
    }
  }
  return isChanged;
}
function toggleRowVisible(expand, table2, key) {
  const rowLevelMap = (table2 == null ? void 0 : table2.store.states.rowLevelMap.value) || {};
  const levelKeys = Object.keys(rowLevelMap);
  const hiddenRowKeys = table2 == null ? void 0 : table2.store.states.hiddenRowKeys;
  let start = false;
  for (let index2 = 0; index2 < levelKeys.length; index2++) {
    if (levelKeys[index2] === key) {
      start = true;
      index2++;
    }
    if (start && rowLevelMap[levelKeys[index2]] !== rowLevelMap[key] + 1) {
      break;
    }
    if (start && rowLevelMap[levelKeys[index2]] === rowLevelMap[key] + 1) {
      if (expand) {
        hiddenRowKeys.value = hiddenRowKeys.value.filter((rowKey) => rowKey !== levelKeys[index2]);
      } else {
        if (!hiddenRowKeys.value.includes(levelKeys[index2])) {
          hiddenRowKeys.value.push(levelKeys[index2]);
        }
      }
    }
  }
}
function useExpand(dataSource, table2) {
  const tableInstance = getCurrentInstance();
  const rowKey = tableInstance.props.rowKey || "";
  const defaultExpandAll = ref(tableInstance.props.defaultExpandAll);
  const _expandedRows = ref([]);
  const updateExpandRows = () => {
    if (defaultExpandAll.value) {
      _expandedRows.value = dataSource.value.slice();
    } else {
      _expandedRows.value = [];
    }
  };
  const setExpandRows = (rowKeys) => {
    const data = dataSource.value || [];
    const rowKeysMap = getRowKeysMap(data, rowKey);
    _expandedRows.value = rowKeys.reduce((pre, cur) => {
      const currentRow = rowKeysMap[cur];
      if (currentRow) {
        pre.push(currentRow.row);
      }
      return pre;
    }, []);
  };
  const isRowExpanded = (row2) => {
    return _expandedRows.value.includes(row2);
  };
  const doToggleRowVisible = (expand, row2) => {
    var _a;
    if ((_a = row2.children) == null ? void 0 : _a.length) {
      const key = getRowIdentity(row2, rowKey);
      if (expand && isRowExpanded(row2)) {
        toggleRowVisible(true, table2, key);
      }
      if (!expand) {
        toggleRowVisible(false, table2, key);
      }
      row2.children.forEach((child) => {
        doToggleRowVisible(expand, child);
      });
    }
  };
  const toggleRowExpansion = (row2, expanded) => {
    const isChanged = toggleRowExpandStatus(_expandedRows.value, row2, expanded);
    if (isChanged) {
      tableInstance.emit("expand-change", row2, _expandedRows.value.slice());
    }
    if (!table2.store.states.flatColumns.value.some((column2) => column2.type === "expand")) {
      doToggleRowVisible(isRowExpanded(row2), row2);
    }
  };
  return {
    isRowExpanded,
    updateExpandRows,
    setExpandRows,
    toggleRowExpansion
  };
}
function useEditTableCell() {
  const tableInstance = getCurrentInstance();
  const rowKey = tableInstance.props.rowKey || "";
  const tableCellModeMap = ref(/* @__PURE__ */ new Map());
  const setCellMode = (row2, rowIndex, fields, cellMode) => {
    if (Array.isArray(fields)) {
      fields.forEach((item) => {
        const cellKey = `${getRowIdentity(row2, rowKey, rowIndex)}-${item}-cell`;
        tableCellModeMap.value.set(cellKey, cellMode);
      });
    } else {
      const cellKey = `${getRowIdentity(row2, rowKey, rowIndex)}-${fields}-cell`;
      tableCellModeMap.value.set(cellKey, cellMode);
    }
  };
  const resetCellMode = () => {
    for (const item of tableCellModeMap.value.keys()) {
      tableCellModeMap.value.set(item, "readonly");
    }
  };
  return {
    tableCellModeMap,
    setCellMode,
    resetCellMode
  };
}
function useSort$1(dataSource, _data) {
  const thList = [];
  const sortData = (direction, sortMethod) => {
    if (direction === "ASC") {
      _data.value = _data.value.sort((a, b) => sortMethod ? sortMethod(a, b) ? 1 : -1 : 0);
    } else if (direction === "DESC") {
      _data.value = _data.value.sort((a, b) => sortMethod ? sortMethod(a, b) ? -1 : 1 : 0);
    } else {
      _data.value = [...dataSource.value];
    }
  };
  const collectTh = (th) => {
    thList.push(th);
  };
  return { thList, collectTh, sortData };
}
function replaceColumn(array4, column2) {
  return array4.map((item) => {
    var _a;
    if (item.id === column2.id) {
      return column2;
    } else if ((_a = item.children) == null ? void 0 : _a.length) {
      item.children = replaceColumn(item.children, column2);
    }
    return item;
  });
}
function doFlattenColumns(columns) {
  const result2 = [];
  columns.forEach((column2) => {
    if (column2.children) {
      result2.push.apply(result2, doFlattenColumns(column2.children));
    } else {
      result2.push(column2);
    }
  });
  return result2;
}
function createColumnGenerator() {
  const _columns = ref([]);
  const flatColumns = ref([]);
  const sortColumn = () => {
    _columns.value.sort((a, b) => {
      var _a, _b;
      return ((_a = a.order) != null ? _a : 0) - ((_b = b.order) != null ? _b : 0);
    });
  };
  const insertColumn = (column2, parent) => {
    var _a;
    const array4 = unref(_columns);
    let newColumns = [];
    if (!parent) {
      array4.push(column2);
      newColumns = array4;
    } else {
      if (parent && !parent.children) {
        parent.children = [];
      }
      (_a = parent == null ? void 0 : parent.children) == null ? void 0 : _a.push(column2);
      newColumns = replaceColumn(array4, parent);
    }
    sortColumn();
    _columns.value = newColumns;
  };
  const removeColumn = (column2) => {
    const i = _columns.value.findIndex((v) => v === column2);
    if (i === -1) {
      return;
    }
    _columns.value.splice(i, 1);
  };
  const updateColumns = () => {
    flatColumns.value = [].concat(doFlattenColumns(_columns.value));
  };
  return {
    _columns,
    flatColumns,
    insertColumn,
    removeColumn,
    sortColumn,
    updateColumns
  };
}
function doFlattenRows(dataList, level, rowKey, rowLevelMap, hiddenRowKeys) {
  const result2 = [];
  dataList.forEach((data) => {
    result2.push(data);
    if (level > 0) {
      const key = getRowIdentity(data, rowKey);
      rowLevelMap.value[key] = level;
      hiddenRowKeys.value.push(key);
    }
    if (data.children) {
      rowLevelMap.value[getRowIdentity(data, rowKey)] = level;
      result2.push.apply(result2, doFlattenRows(data.children, level + 1, rowKey, rowLevelMap, hiddenRowKeys));
    }
  });
  return result2;
}
function createRowGenerator(dataSource, rowKey, flatColumns) {
  const flatRows = ref([]);
  const hiddenRowKeys = ref([]);
  const rowLevelMap = ref({});
  const firstDefaultColumn = ref("");
  const updateRows = () => {
    const hasExpand = flatColumns.value.some((column2) => column2.type === "expand");
    const result2 = hasExpand ? dataSource.value : doFlattenRows(dataSource.value, 0, rowKey, rowLevelMap, hiddenRowKeys);
    flatRows.value = [].concat(result2);
  };
  const updateFirstDefaultColumn = () => {
    const index2 = flatColumns.value.findIndex((column2) => column2.type === "");
    firstDefaultColumn.value = index2 !== -1 ? flatColumns.value[index2].id : "";
  };
  return {
    flatRows,
    hiddenRowKeys,
    rowLevelMap,
    updateRows,
    firstDefaultColumn,
    updateFirstDefaultColumn
  };
}
function createSelection(dataSource, rowKey, flatRows) {
  const _checkSet = ref(/* @__PURE__ */ new Set());
  const checkRow = (toggle, row2, index2) => {
    const key = getRowIdentity(row2, rowKey, index2);
    if (toggle) {
      _checkSet.value.add(key);
    } else {
      _checkSet.value.delete(key);
    }
  };
  const toggleRowSelection = (row2, checked, index2) => {
    const key = getRowIdentity(row2, rowKey, index2);
    const isIncluded = _checkSet.value.has(key);
    const addRow = () => {
      _checkSet.value.add(key);
    };
    const deleteRow = () => {
      _checkSet.value.delete(key);
    };
    if (isBoolean(checked)) {
      if (checked && !isIncluded) {
        addRow();
      } else if (!checked && isIncluded) {
        deleteRow();
      }
    } else {
      if (isIncluded) {
        deleteRow();
      } else {
        addRow();
      }
    }
  };
  const isRowChecked = (row2, index2) => {
    return _checkSet.value.has(getRowIdentity(row2, rowKey, index2));
  };
  const getCheckedRows = () => {
    return flatRows.value.filter((item, index2) => isRowChecked(item, index2));
  };
  const _checkAllRecord = ref(false);
  const _checkAll = computed({
    get: () => _checkAllRecord.value,
    set: (val) => {
      _checkAllRecord.value = val;
      dataSource.value.forEach((item, index2) => {
        checkRow(val, item, index2);
      });
    }
  });
  const _halfChecked = ref(false);
  watch(_checkSet, (set) => {
    if (set.size === 0) {
      return;
    }
    let allTrue = true;
    let allFalse = true;
    const items = flatRows.value;
    for (let i = 0; i < items.length; i++) {
      const checked = isRowChecked(items[i], i);
      allTrue && (allTrue = checked);
      allFalse && (allFalse = !checked);
    }
    _checkAllRecord.value = allTrue;
    _halfChecked.value = !(allFalse || allTrue);
  }, { immediate: true, deep: true });
  watch(dataSource, (value) => {
    _checkAllRecord.value = value.findIndex((item, index2) => !isRowChecked(item, index2)) === -1;
  });
  return {
    _checkSet,
    _checkAll,
    _halfChecked,
    getCheckedRows,
    checkRow,
    isRowChecked,
    toggleRowSelection
  };
}
function createFixedLogic(columns) {
  const isFixedLeft = computed(() => {
    return columns.value.reduce((prev, current) => prev || !!current.fixedLeft, false);
  });
  return { isFixedLeft };
}
function createStore(dataSource, table2, ctx2) {
  const _data = ref([]);
  const { _columns, flatColumns, insertColumn, removeColumn, sortColumn, updateColumns } = createColumnGenerator();
  const { flatRows, hiddenRowKeys, rowLevelMap, updateRows, firstDefaultColumn, updateFirstDefaultColumn } = createRowGenerator(dataSource, table2.props.rowKey, flatColumns);
  const { _checkAll, _checkSet, _halfChecked, getCheckedRows, isRowChecked, checkRow, toggleRowSelection } = createSelection(_data, table2.props.rowKey, flatRows);
  const { thList, collectTh, sortData } = useSort$1(dataSource, flatRows);
  const { isFixedLeft } = createFixedLogic(_columns);
  const { isRowExpanded, updateExpandRows, setExpandRows, toggleRowExpansion } = useExpand(_data, table2);
  const { tableCellModeMap, setCellMode, resetCellMode } = useEditTableCell();
  const emitTableEvent = (eventName, ...params) => {
    ctx2.emit.apply(ctx2, [eventName, ...params]);
  };
  watch(dataSource, (value) => {
    _data.value = [...value];
    updateExpandRows();
  }, { deep: true, immediate: true });
  return {
    states: {
      _data,
      flatRows,
      hiddenRowKeys,
      rowLevelMap,
      _columns,
      flatColumns,
      _checkSet,
      _checkAll,
      _halfChecked,
      isFixedLeft,
      thList,
      firstDefaultColumn,
      tableCellModeMap
    },
    insertColumn,
    sortColumn,
    removeColumn,
    updateColumns,
    updateRows,
    getCheckedRows,
    collectTh,
    sortData,
    isRowChecked,
    checkRow,
    isRowExpanded,
    setExpandRows,
    toggleRowExpansion,
    toggleRowSelection,
    updateFirstDefaultColumn,
    setCellMode,
    resetCellMode,
    emitTableEvent
  };
}
var ColGroup = defineComponent({
  name: "DColGroup",
  setup() {
    const parent = inject(TABLE_TOKEN);
    const columns = parent == null ? void 0 : parent.store.states.flatColumns;
    const isFixed = computed(() => (parent == null ? void 0 : parent.props.tableLayout) === "fixed");
    return () => createVNode("colgroup", null, [columns == null ? void 0 : columns.value.map((column2, index2) => {
      return createVNode("col", {
        "key": index2,
        "column-id": isFixed.value ? column2.id : "",
        "width": column2.type === "expand" ? 60 : isFixed.value ? column2.realWidth : column2.width || ""
      }, null);
    })]);
  }
});
const sortProps = {
  sortDirection: {
    type: String,
    default: ""
  }
};
var sort = "";
const XLINK_HREF = {
  "xlink:href": "#sort-svg-path-1"
};
var Sort = defineComponent({
  props: sortProps,
  emits: ["sort"],
  setup(props, ctx2) {
    const directionMap = {
      ASC: "DESC",
      DESC: "",
      default: "ASC"
    };
    const changeDirection = () => {
      ctx2.emit("sort", directionMap[props.sortDirection || "default"]);
    };
    const ns2 = useNamespace("table");
    return () => createVNode("span", {
      "onClick": changeDirection,
      "class": ns2.e("sort-clickable")
    }, [createVNode("i", {
      "class": [{
        [ns2.e("sort-default")]: !props.sortDirection,
        [ns2.e("sort-asc")]: props.sortDirection === "ASC",
        [ns2.e("sort-desc")]: props.sortDirection === "DESC"
      }]
    }, [createVNode("svg", {
      "width": "16px",
      "height": "16px",
      "viewBox": "0 0 16 16",
      "version": "1.1",
      "xmlns": "http://www.w3.org/2000/svg"
    }, [createVNode("defs", null, [createVNode("circle", {
      "id": "sort-svg-path-1",
      "cx": "8",
      "cy": "8",
      "r": "8"
    }, null), createVNode("filter", {
      "x": "-34.4%",
      "y": "-21.9%",
      "width": "168.8%",
      "height": "168.8%",
      "filterUnits": "objectBoundingBox",
      "id": "filter-2"
    }, [createVNode("feOffset", {
      "dx": "0",
      "dy": "2",
      "in": "SourceAlpha",
      "result": "shadowOffsetOuter1"
    }, null), createVNode("feGaussianBlur", {
      "stdDeviation": "1.5",
      "in": "shadowOffsetOuter1",
      "result": "shadowBlurOuter1"
    }, null), createVNode("feColorMatrix", {
      "values": "0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.085309222 0",
      "type": "matrix",
      "in": "shadowBlurOuter1"
    }, null)])]), createVNode("g", {
      "stroke": "none",
      "stroke-width": "1",
      "fill": "none",
      "fill-rule": "evenodd"
    }, [createVNode("use", mergeProps({
      "fill-rule": "evenodd"
    }, XLINK_HREF), null), createVNode("polygon", {
      "points": "8 4 11 7 5 7"
    }, null), createVNode("polygon", {
      "points": "8 12 5 9 11 9"
    }, null)])])])]);
  }
});
const filterProps = {
  filterList: {
    type: Array,
    default: () => []
  },
  multiple: {
    type: Boolean,
    default: true
  }
};
function useFilterRender(ctx2) {
  const showMenu = ref(false);
  const filterMenuRef = ref(null);
  const filterIconRef = ref(null);
  const singleVal = ref(null);
  const multipleVal = ref(null);
  const handleIconClick = () => {
    showMenu.value = !showMenu.value;
  };
  const handleConfirm = (val) => {
    showMenu.value = false;
    multipleVal.value = val;
    ctx2.emit("filter", val);
  };
  const handleSelect = (val) => {
    showMenu.value = false;
    singleVal.value = val;
    ctx2.emit("filter", val);
  };
  const iconClasses = computed(() => {
    var _a;
    return {
      "filter-icon": true,
      "filter-icon-active": Boolean(singleVal.value || ((_a = multipleVal.value) == null ? void 0 : _a.length))
    };
  });
  onClickOutside(filterMenuRef, () => {
    showMenu.value = false;
  }, {
    ignore: [filterIconRef]
  });
  return { showMenu, filterMenuRef, filterIconRef, iconClasses, handleIconClick, handleConfirm, handleSelect };
}
function useFilterMultiple(filterList, ctx2) {
  const _checkList = ref([]);
  const _checkAllRecord = ref(false);
  const _checkAll = computed({
    get: () => _checkAllRecord.value,
    set: (val) => {
      _checkAllRecord.value = val;
      for (let i = 0; i < _checkList.value.length; i++) {
        _checkList.value[i].checked = val;
      }
    }
  });
  const _halfChecked = ref(false);
  filterList == null ? void 0 : filterList.forEach((item) => {
    _checkList.value.push(__spreadValues({ checked: false }, item));
  });
  watch(_checkList, (list2) => {
    if (!list2.length) {
      return;
    }
    let allTrue = true;
    let allFalse = true;
    for (let i = 0; i < list2.length; i++) {
      allTrue && (allTrue = Boolean(list2[i].checked));
      allFalse && (allFalse = Boolean(!list2[i].checked));
    }
    _checkAllRecord.value = allTrue;
    _halfChecked.value = !(allFalse || allTrue);
  }, { immediate: true, deep: true });
  const getCheckedItems = () => {
    return _checkList.value.filter((item) => item.checked);
  };
  const handleConfirm = () => {
    ctx2.emit("confirm", getCheckedItems());
  };
  return { _checkList, _checkAll, _halfChecked, handleConfirm };
}
function useFilterSingle(ctx2) {
  const selectedItem = ref(null);
  const handleSelect = (val) => {
    selectedItem.value = val;
    ctx2.emit("select", val);
  };
  return { selectedItem, handleSelect };
}
function _isSlot$3(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var MultipleFilter = defineComponent({
  props: {
    filterList: {
      type: Array,
      default: () => []
    }
  },
  emits: ["confirm"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTable", app);
    const {
      _checkList,
      _checkAll,
      _halfChecked,
      handleConfirm
    } = useFilterMultiple(props.filterList, ctx2);
    return () => {
      let _slot;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": "filter-all-check"
      }, [createVNode("div", {
        "class": "filter-item"
      }, [createVNode(Checkbox, {
        "modelValue": _checkAll.value,
        "onUpdate:modelValue": ($event) => _checkAll.value = $event,
        "halfChecked": _halfChecked.value,
        "label": t("selectAll")
      }, null)])]), createVNode("div", {
        "class": "filter-multiple-menu"
      }, [_checkList.value.map((item) => createVNode("div", {
        "class": "filter-item"
      }, [createVNode(Checkbox, {
        "modelValue": item.checked,
        "onUpdate:modelValue": ($event) => item.checked = $event,
        "label": item.name
      }, null)]))]), createVNode("div", {
        "class": "filter-operation"
      }, [createVNode(DButton, {
        "variant": "text",
        "onClick": handleConfirm
      }, _isSlot$3(_slot = t("ok")) ? _slot : {
        default: () => [_slot]
      })])]);
    };
  }
});
function _isSlot$2(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var SingleFilter = defineComponent({
  props: {
    filterList: {
      type: Array,
      default: () => []
    }
  },
  emits: ["select"],
  setup(props, ctx2) {
    const {
      selectedItem,
      handleSelect
    } = useFilterSingle(ctx2);
    return () => {
      let _slot;
      return createVNode(Fragment, null, [createVNode(List, {
        "class": "filter-single-menu"
      }, _isSlot$2(_slot = props.filterList.map((item) => createVNode(ListItem, {
        "class": ["filter-item", {
          "filter-item-active": selectedItem.value === item
        }],
        "onClick": () => {
          handleSelect(item);
        }
      }, {
        default: () => [item.name]
      }))) ? _slot : {
        default: () => [_slot]
      })]);
    };
  }
});
var filter = "";
var Filter = defineComponent({
  props: filterProps,
  emits: ["filter"],
  setup(props, ctx2) {
    const {
      showMenu,
      filterMenuRef,
      filterIconRef,
      iconClasses,
      handleIconClick,
      handleConfirm,
      handleSelect
    } = useFilterRender(ctx2);
    return () => createVNode(Dropdown$1, {
      "visible": showMenu.value,
      "trigger": "manually",
      "close-scope": "none",
      "destroy-on-hide": false,
      "style": "padding-bottom: 4px;"
    }, {
      default: () => createVNode("i", {
        "ref": filterIconRef,
        "class": iconClasses.value,
        "onClick": handleIconClick
      }, [createVNode("svg", {
        "width": "16px",
        "height": "16px",
        "viewBox": "0 0 16 16",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("g", {
        "stroke": "none",
        "stroke-width": "1",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", null, [createVNode("polygon", {
        "points": "10.0085775 7 10.0085775 15 6 13 6 7 2 3 2 1 14 1 14 3"
      }, null)])])])]),
      menu: () => createVNode("div", {
        "ref": filterMenuRef,
        "class": "filter-wrapper"
      }, [props.multiple ? createVNode(MultipleFilter, {
        "filterList": props.filterList,
        "onConfirm": handleConfirm
      }, null) : createVNode(SingleFilter, {
        "filterList": props.filterList,
        "onSelect": handleSelect
      }, null)])
    });
  }
});
function useBaseRender(column2) {
  const baseClass = computed(() => ({
    operable: column2.value.filterable || column2.value.sortable || column2.value.resizeable,
    resizeable: column2.value.resizeable
  }));
  return { baseClass };
}
function useSort(column2) {
  const table2 = inject(TABLE_TOKEN);
  const store = table2.store;
  const direction = ref(column2.value.sortDirection || "");
  const sortClass = computed(() => ({
    "sort-active": Boolean(direction.value)
  }));
  const thInstance = getCurrentInstance();
  thInstance && store.collectTh(thInstance);
  onMounted(async () => {
    var _a;
    await nextTick();
    column2.value.sortable && column2.value.sortDirection && ((_a = store.sortData) == null ? void 0 : _a.call(store, direction.value, column2.value.sortMethod));
  });
  const execClearSortOrder = () => {
    store.states.thList.forEach((th) => {
      var _a, _b;
      if (th !== thInstance) {
        (_b = (_a = th.exposed) == null ? void 0 : _a.clearSortOrder) == null ? void 0 : _b.call(_a);
      }
    });
  };
  const handleSort = (val) => {
    var _a;
    direction.value = val;
    execClearSortOrder();
    (_a = store.sortData) == null ? void 0 : _a.call(store, direction.value, column2.value.sortMethod);
    table2.emit("sort-change", { field: column2.value.field, direction: direction.value });
  };
  const clearSortOrder = () => {
    direction.value = "";
  };
  return { direction, sortClass, handleSort, clearSortOrder };
}
function useFilter(column2) {
  const filter2 = ref(null);
  const filterClass = computed(() => ({
    "filter-active": Boolean(filter2.value || Array.isArray(filter2.value) && filter2.value.length)
  }));
  const handleFilter = (val) => {
    var _a;
    filter2.value = val;
    (_a = column2.value.ctx) == null ? void 0 : _a.emit("filter-change", val);
  };
  return { filterClass, handleFilter };
}
function handleWidth(width) {
  if (!width) {
    return;
  }
  if (typeof width === "number") {
    return width;
  }
  return parseInt(width, 10);
}
function getFinalWidth(newWidth, minWidth, maxWidth) {
  const realMinWidth = handleWidth(minWidth);
  const realMaxWidth = handleWidth(maxWidth);
  const overMinWidth = !realMinWidth || newWidth >= realMinWidth;
  const underMaxWidth = !realMaxWidth || newWidth <= realMaxWidth;
  const finalWidth = !overMinWidth ? realMinWidth : !underMaxWidth ? realMaxWidth : newWidth;
  return finalWidth;
}
function useDragColumnWidth(elementRef, column2) {
  let initialWidth = 0;
  let mouseDownScreenX = 0;
  let resizeBarElement;
  const table2 = inject(TABLE_TOKEN);
  const dragClass = ref("");
  const resizing = ref(false);
  const tableElement = table2.tableRef;
  const onMousemove = (e) => {
    var _a;
    const movementX = e.clientX - mouseDownScreenX;
    const newWidth = initialWidth + movementX;
    const finalWidth = getFinalWidth(newWidth, column2.value.minWidth, column2.value.maxWidth);
    if (resizeBarElement) {
      resizeBarElement.style.left = `${finalWidth + elementRef.value.offsetLeft}px`;
    }
    (_a = column2.value.ctx) == null ? void 0 : _a.emit("resizing", { width: finalWidth });
  };
  const onMouseup = (e) => {
    var _a;
    const movementX = e.clientX - mouseDownScreenX;
    const newWidth = initialWidth + movementX;
    const finalWidth = getFinalWidth(newWidth, column2.value.minWidth, column2.value.maxWidth);
    column2.value.width = finalWidth;
    column2.value.realWidth = finalWidth;
    table2.updateColumnWidth();
    resizing.value = false;
    tableElement == null ? void 0 : tableElement.value.classList.remove("table-selector");
    dragClass.value = "";
    tableElement == null ? void 0 : tableElement.value.removeChild(resizeBarElement);
    (_a = column2.value.ctx) == null ? void 0 : _a.emit("resize-end", { width: finalWidth, beforeWidth: initialWidth });
    document.removeEventListener("mouseup", onMouseup);
    document.removeEventListener("mousemove", onMousemove);
  };
  const onMousedown2 = (e) => {
    var _a;
    const isHandle = e.target.classList.contains("resize-handle");
    if (isHandle) {
      (_a = column2.value.ctx) == null ? void 0 : _a.emit("resize-start");
      const initialOffset = elementRef.value.offsetLeft;
      initialWidth = elementRef.value.clientWidth;
      mouseDownScreenX = e.clientX;
      e.stopPropagation();
      resizing.value = true;
      tableElement == null ? void 0 : tableElement.value.classList.add("table-selector");
      resizeBarElement = document.createElement("div");
      resizeBarElement.classList.add("resize-bar");
      if (tableElement.value) {
        resizeBarElement.style.display = "block";
        resizeBarElement.style.left = initialOffset + initialWidth + "px";
        tableElement.value.appendChild(resizeBarElement);
      }
      dragClass.value = "hover-bg";
      document.addEventListener("mouseup", onMouseup);
      document.addEventListener("mousemove", onMousemove);
    }
  };
  return { resizing, dragClass, onMousedown: onMousedown2 };
}
const headerThProps = {
  column: {
    type: Object,
    required: true
  },
  colspan: {
    type: Number
  },
  rowspan: {
    type: Number
  }
};
var TH = defineComponent({
  name: "DTableHeaderTh",
  props: headerThProps,
  setup(props, {
    expose
  }) {
    const table2 = inject(TABLE_TOKEN);
    const store = table2.store;
    const headerContainerRef = ref();
    const {
      column: column2,
      colspan,
      rowspan
    } = toRefs(props);
    const {
      baseClass
    } = useBaseRender(column2);
    const {
      direction,
      sortClass,
      handleSort,
      clearSortOrder
    } = useSort(column2);
    const {
      filterClass,
      handleFilter
    } = useFilter(column2);
    const {
      stickyClass,
      stickyStyle
    } = useFixedColumn(column2);
    const {
      resizing,
      dragClass,
      onMousedown: onMousedown2
    } = useDragColumnWidth(headerContainerRef, column2);
    expose({
      clearSortOrder
    });
    return () => {
      var _a, _b;
      return createVNode("th", {
        "class": [baseClass.value, stickyClass.value, sortClass.value, filterClass.value, dragClass.value],
        "style": stickyStyle.value,
        "colspan": colspan == null ? void 0 : colspan.value,
        "rowspan": rowspan == null ? void 0 : rowspan.value
      }, [createVNode("div", {
        "ref": headerContainerRef,
        "class": "header-container",
        "onMousedown": onMousedown2
      }, [(_b = (_a = column2.value).renderHeader) == null ? void 0 : _b.call(_a, column2.value, store), column2.value.filterable && createVNode(Filter, {
        "filterList": column2.value.filterList,
        "multiple": column2.value.filterMultiple,
        "onFilter": handleFilter
      }, null), column2.value.sortable && createVNode(Sort, {
        "sort-direction": direction.value,
        "onSort": handleSort
      }, null), column2.value.resizeable && createVNode("span", {
        "class": "resize-handle",
        "onClick": (e) => e.stopPropagation()
      }, null), column2.value.resizeable && resizing.value && createVNode("div", {
        "class": "resize-overlay",
        "onClick": (e) => e.stopPropagation()
      }, null)])]);
    };
  }
});
function getAllColumns(columns) {
  const result2 = [];
  columns.forEach((column2) => {
    if (column2.children) {
      result2.push(column2);
      result2.push.apply(result2, getAllColumns(column2.children));
    } else {
      result2.push(column2);
    }
  });
  return result2;
}
function convertToRows(originColumns) {
  let maxLevel = 1;
  const traverse = (column2, parent) => {
    if (parent) {
      column2.level = parent.level + 1;
      if (maxLevel < column2.level) {
        maxLevel = column2.level;
      }
    }
    if (column2.children) {
      let colSpan = 0;
      column2.children.forEach((subColumn) => {
        traverse(subColumn, column2);
        colSpan += subColumn.colSpan || 0;
      });
      column2.colSpan = colSpan;
    } else {
      column2.colSpan = 1;
    }
  };
  originColumns.forEach((column2) => {
    column2.level = 1;
    traverse(column2, void 0);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach((column2) => {
    if (!column2.children) {
      column2.rowSpan = maxLevel - (column2.level || 0) + 1;
    } else {
      column2.rowSpan = 1;
      column2.children.forEach((col2) => col2.isSubColumn = true);
    }
    rows[column2.level - 1].push(column2);
  });
  return rows;
}
function useHeader() {
  const table2 = inject(TABLE_TOKEN);
  const headerRows = computed(() => convertToRows(table2 == null ? void 0 : table2.store.states._columns.value));
  return { headerRows };
}
var header = "";
var body = "";
var TableHeader = defineComponent({
  name: "DTableHeader",
  setup() {
    const ns2 = useNamespace("table");
    const {
      headerRows
    } = useHeader();
    return () => createVNode("thead", {
      "class": ns2.e("thead")
    }, [headerRows.value.map((subColumns) => createVNode("tr", null, [subColumns.map((column2, columnIndex) => {
      var _a, _b;
      return createVNode(TH, {
        "key": columnIndex,
        "column": column2,
        "colspan": column2.colSpan,
        "rowspan": column2.rowSpan,
        "class": {
          [ns2.m("last-sticky-left")]: column2.fixedLeft && !((_a = subColumns[columnIndex + 1]) == null ? void 0 : _a.fixedLeft),
          [ns2.m("first-sticky-right")]: column2.fixedRight && !((_b = subColumns[columnIndex - 1]) == null ? void 0 : _b.fixedRight)
        }
      }, null);
    })]))]);
  }
});
const bodyTdProps = {
  column: {
    type: Object,
    default: () => ({})
  },
  row: {
    type: Object,
    default: () => ({})
  },
  rowspan: {
    type: Number
  },
  colspan: {
    type: Number
  },
  index: {
    type: Number,
    default: 0
  }
};
var TooltipInstall = {
  title: "Tooltip \u63D0\u793A",
  category: "\u53CD\u9988",
  status: "100%",
  install(app) {
    app.component(Tooltip.name, Tooltip);
  }
};
function useBodyTd(props, ctx2) {
  const tooltipContent = ref();
  const isShowTooltip = ref(false);
  const tdRef = ref();
  let observer;
  const table2 = inject(TABLE_TOKEN);
  function getTooltipContent() {
    var _a, _b;
    return ((_a = tdRef.value) == null ? void 0 : _a.innerText) || ((_b = tdRef.value) == null ? void 0 : _b.textContent);
  }
  function shouldShowTooltip() {
    if (!tdRef.value) {
      return;
    }
    const range3 = document.createRange();
    range3.setStart(tdRef.value, 0);
    range3.setEnd(tdRef.value, tdRef.value.childNodes.length);
    const rangeWidth = range3.getBoundingClientRect().width;
    const padding = parseInt(window.getComputedStyle(tdRef.value)["paddingLeft"], 10) + parseInt(window.getComputedStyle(tdRef.value)["paddingRight"], 10);
    isShowTooltip.value = !!(props.column.showOverflowTooltip && rangeWidth + padding > tdRef.value.offsetWidth);
  }
  onMounted(() => {
    if (inBrowser && window.ResizeObserver && props.column.showOverflowTooltip) {
      const innerObserver = new window.ResizeObserver(shouldShowTooltip);
      tdRef.value && innerObserver.observe(tdRef.value);
    }
    tooltipContent.value = getTooltipContent();
  });
  onBeforeMount(() => {
    tdRef.value && observer.unobserve(tdRef.value);
  });
  onUpdated(() => {
    const modeMap = table2.store.states.tableCellModeMap.value;
    for (const child of modeMap.keys()) {
      modeMap.set(child, "readonly");
    }
  });
  const getCellKsy = () => {
    return `${getRowIdentity(props.row, table2.props.rowKey, props.index)}-${props.column.field}-cell`;
  };
  const cellMode = computed(() => {
    const cellKey = getCellKsy();
    const mode = table2.store.states.tableCellModeMap.value.get(cellKey);
    return mode || "readonly";
  });
  const onCellClick = () => {
    const modeMap = table2.store.states.tableCellModeMap.value;
    const cellKey = getCellKsy();
    for (const child of modeMap.keys()) {
      modeMap.set(child, "readonly");
    }
    if (props.column.type === "editable" && modeMap.get(cellKey) === "edit") {
      return;
    }
    ctx2.emit("cellClick");
  };
  return { tdRef, isShowTooltip, tooltipContent, cellMode, onCellClick };
}
var TD = defineComponent({
  name: "DTableBodyTd",
  inheritAttrs: false,
  props: bodyTdProps,
  emits: ["cellClick"],
  setup(props, ctx2) {
    const {
      column: column2,
      rowspan,
      colspan
    } = toRefs(props);
    const table2 = inject(TABLE_TOKEN);
    const {
      stickyClass,
      stickyStyle
    } = useFixedColumn(column2);
    const {
      tdRef,
      isShowTooltip,
      tooltipContent,
      cellMode,
      onCellClick
    } = useBodyTd(props, ctx2);
    return () => {
      return createVNode(Tooltip, {
        "content": tooltipContent.value,
        "disabled": !isShowTooltip.value
      }, {
        default: () => {
          var _a, _b;
          return [createVNode("td", mergeProps({
            "ref": tdRef,
            "class": [stickyClass.value, column2.value.cellClass],
            "style": stickyStyle.value
          }, ctx2.attrs, {
            "rowspan": rowspan == null ? void 0 : rowspan.value,
            "colspan": colspan == null ? void 0 : colspan.value,
            "onClick": onCellClick
          }), [(_b = (_a = props.column).renderCell) == null ? void 0 : _b.call(_a, props.row, props.column, table2.store, props.index, table2.props, cellMode)])];
        }
      });
    };
  }
});
const ns$3 = useNamespace("table");
function useMergeCell() {
  const table2 = inject(TABLE_TOKEN);
  const { _data: data, _columns: columns } = table2.store.states;
  const getSpan = (row2, column2, rowIndex, columnIndex) => {
    const fn = table2 == null ? void 0 : table2.props.spanMethod;
    let rowspan = 1;
    let colspan = 1;
    if (typeof fn === "function") {
      const result2 = fn({ row: row2, column: column2, rowIndex, columnIndex });
      if (Array.isArray(result2)) {
        rowspan = result2[0];
        colspan = result2[1];
      } else if (typeof result2 === "object") {
        rowspan = result2.rowspan;
        colspan = result2.colspan;
      }
    }
    return { rowspan, colspan };
  };
  const tableSpans = computed(() => {
    const result2 = {};
    if (table2 == null ? void 0 : table2.props.spanMethod) {
      data.value.forEach((row2, rowIndex) => {
        columns.value.forEach((column2, columnIndex) => {
          const { rowspan, colspan } = getSpan(row2, column2, rowIndex, columnIndex);
          if (rowspan > 1 || colspan > 1) {
            result2[`${rowIndex}-${columnIndex}`] = [rowspan, colspan];
          }
        });
      });
    }
    return result2;
  });
  const removeCells = computed(() => {
    const result2 = [];
    for (const indexKey of Object.keys(tableSpans.value)) {
      const indexArray = indexKey.split("-").map((item) => Number(item));
      const spans = tableSpans.value[indexKey];
      for (let i = 1; i < spans[0]; i++) {
        result2.push(`${indexArray[0] + i}-${indexArray[1]}`);
        for (let j = 1; j < spans[1]; j++) {
          result2.push(`${indexArray[0] + i}-${indexArray[1] + j}`);
        }
      }
      for (let i = 1; i < spans[1]; i++) {
        result2.push(`${indexArray[0]}-${indexArray[1] + i}`);
      }
    }
    return result2;
  });
  return { tableSpans, removeCells };
}
function useBodyRender() {
  const table2 = inject(TABLE_TOKEN);
  const hoverEnabled = computed(() => table2 == null ? void 0 : table2.props.rowHoveredHighlight);
  const rowLevelMap = (table2 == null ? void 0 : table2.store.states.rowLevelMap) || {};
  const rowKey = (table2 == null ? void 0 : table2.props.rowKey) || "id";
  const getTableRowClass = (row2) => {
    const level = rowLevelMap.value[getRowIdentity(row2, rowKey)];
    return {
      [ns$3.e("row")]: true,
      ["hover-enabled"]: hoverEnabled.value,
      ["expanded"]: table2 == null ? void 0 : table2.store.isRowExpanded(row2),
      [ns$3.em("row", `level-${level}`)]: level !== void 0,
      ["is-hidden"]: table2 == null ? void 0 : table2.store.states.hiddenRowKeys.value.includes(getRowIdentity(row2, rowKey))
    };
  };
  return { getTableRowClass };
}
function useLazyLoad$1() {
  const table2 = inject(TABLE_TOKEN);
  const { lazy } = table2.props;
  const lazyFlagRef = ref();
  let lazyObserver;
  onMounted(() => {
    if (lazy) {
      lazyObserver = new IntersectionObserver((entries) => {
        const lazyFlagOb = entries[0];
        if (lazyFlagOb.isIntersecting) {
          table2.emit("load-more");
        }
      }, {
        root: table2.tableRef.value
      });
      lazyObserver.observe(lazyFlagRef.value);
    }
  });
  onBeforeUnmount(() => {
    if (lazy) {
      lazyObserver.unobserve(lazyFlagRef.value);
      lazyObserver.disconnect();
    }
  });
  return {
    lazy,
    lazyFlagRef
  };
}
var TableBody = defineComponent({
  name: "DTableBody",
  setup() {
    const table2 = inject(TABLE_TOKEN);
    const {
      flatColumns,
      flatRows
    } = table2.store.states;
    const ns2 = useNamespace("table");
    const {
      tableSpans,
      removeCells
    } = useMergeCell();
    const {
      getTableRowClass
    } = useBodyRender();
    const {
      lazy,
      lazyFlagRef
    } = useLazyLoad$1();
    const onCellClick = (cellClickArg) => {
      table2.emit("cell-click", cellClickArg);
    };
    const onRowClick = (rowClickArg) => {
      table2.emit("row-click", rowClickArg);
    };
    return () => createVNode("tbody", {
      "class": ns2.e("tbody")
    }, [flatRows.value.map((row2, rowIndex) => {
      var _a, _b, _c, _d;
      return createVNode(Fragment, null, [createVNode("tr", {
        "key": rowIndex,
        "class": getTableRowClass(row2),
        "onClick": () => onRowClick({
          row: row2
        })
      }, [flatColumns.value.map((column2, columnIndex) => {
        var _a2, _b2, _c2;
        const cellId = `${rowIndex}-${columnIndex}`;
        const [rowspan, colspan] = (_a2 = tableSpans.value[cellId]) != null ? _a2 : [1, 1];
        if (removeCells.value.includes(cellId)) {
          return null;
        }
        return createVNode(TD, {
          "column": column2,
          "index": rowIndex,
          "row": row2,
          "rowspan": rowspan,
          "colspan": colspan,
          "class": {
            [ns2.m("last-sticky-left")]: column2.fixedLeft && !((_b2 = flatColumns.value[columnIndex + 1]) == null ? void 0 : _b2.fixedLeft),
            [ns2.m("first-sticky-right")]: column2.fixedRight && !((_c2 = flatColumns.value[columnIndex - 1]) == null ? void 0 : _c2.fixedRight)
          },
          "onCellClick": () => onCellClick({
            rowIndex,
            columnIndex,
            column: column2,
            row: row2
          })
        }, null);
      })]), flatColumns.value.some((column2) => column2.type === "expand") && table2.store.isRowExpanded(row2) && createVNode("tr", null, [createVNode("td", {
        "colspan": flatColumns.value.length
      }, [(_d = (_c = (_b = (_a = flatColumns.value.filter((column2) => column2.type === "expand")) == null ? void 0 : _a[0]) == null ? void 0 : _b.slots) == null ? void 0 : _c.default) == null ? void 0 : _d.call(_c, {
        row: row2
      })])])]);
    }), lazy && createVNode("span", {
      "ref": lazyFlagRef,
      "class": ns2.e("lazy__flag")
    }, null)]);
  }
});
var FixHeader = defineComponent({
  props: {
    classes: {
      type: Object,
      default: () => ({})
    },
    isEmpty: {
      type: Boolean
    }
  },
  setup(props) {
    const ns2 = useNamespace("table");
    const table2 = inject(TABLE_TOKEN, void 0);
    const showHeader = computed(() => Boolean(table2 == null ? void 0 : table2.props.showHeader));
    const {
      onTableScroll
    } = useHorizontalScroll(table2);
    return () => createVNode("div", {
      "class": ns2.e("fix-header"),
      "onScroll": withModifiers(onTableScroll, ["stop"])
    }, [showHeader.value && createVNode("div", {
      "class": ns2.e("header-wrapper")
    }, [createVNode("table", {
      "class": props.classes,
      "cellpadding": "0",
      "cellspacing": "0"
    }, [createVNode(ColGroup, null, null), createVNode(TableHeader, null, null)])]), createVNode("div", {
      "class": ns2.e("scroll-view")
    }, [createVNode("table", {
      "class": props.classes,
      "cellpadding": "0",
      "cellspacing": "0"
    }, [createVNode(ColGroup, null, null), !props.isEmpty && createVNode(TableBody, {
      "style": "flex: 1"
    }, null)])])]);
  }
});
var NormalHeader = defineComponent({
  props: {
    classes: {
      type: Object,
      default: () => ({})
    },
    isEmpty: {
      type: Boolean
    }
  },
  setup(props) {
    const table2 = inject(TABLE_TOKEN, void 0);
    const showHeader = computed(() => Boolean(table2 == null ? void 0 : table2.props.showHeader));
    return () => createVNode("table", {
      "class": props.classes,
      "cellpadding": "0",
      "cellspacing": "0"
    }, [createVNode(ColGroup, null, null), showHeader.value && createVNode(TableHeader, {
      "style": "position:relative"
    }, null), !props.isEmpty && createVNode(TableBody, null, null)]);
  }
});
var table = "";
let tableIdInit = 1;
var Table = defineComponent({
  name: "DTable",
  directives: {
    Loading: LoadingDirective
  },
  props: tableProps,
  emits: ["sort-change", "cell-click", "row-click", "check-change", "check-all-change", "expand-change", "load-more"],
  setup(props, ctx2) {
    const table2 = getCurrentInstance();
    const store = createStore(toRef(props, "data"), table2, ctx2);
    const tableId = `devui-table_${tableIdInit++}`;
    const tableRef = ref();
    table2.tableId = tableId;
    table2.store = store;
    provide(TABLE_TOKEN, table2);
    const {
      tableWidth,
      updateColumnWidth
    } = useTableLayout(table2);
    const {
      classes,
      styles
    } = useTable(props, tableWidth);
    const {
      onTableScroll
    } = useHorizontalScroll(table2);
    useTableWatcher(props, store);
    const isEmpty2 = computed(() => props.data.length === 0);
    const ns2 = useNamespace("table");
    const hiddenColumns = ref(null);
    table2.hiddenColumns = hiddenColumns;
    table2.tableRef = tableRef;
    table2.updateColumnWidth = updateColumnWidth;
    ctx2.expose({
      store
    });
    onMounted(async () => {
      await nextTick();
      store.updateColumns();
      store.updateFirstDefaultColumn();
      store.updateRows();
      updateColumnWidth();
      window.addEventListener("resize", updateColumnWidth);
    });
    return () => {
      var _a, _b;
      return withDirectives(createVNode("div", {
        "ref": tableRef,
        "class": ns2.b(),
        "style": styles.value,
        "onScroll": withModifiers(onTableScroll, ["stop"])
      }, [createVNode("div", {
        "class": ns2.e("container")
      }, [createVNode("div", {
        "ref": hiddenColumns,
        "class": "hidden-columns"
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]), props.fixHeader ? createVNode(FixHeader, {
        "classes": classes.value,
        "is-empty": isEmpty2.value
      }, null) : createVNode(NormalHeader, {
        "classes": classes.value,
        "is-empty": isEmpty2.value
      }, null), isEmpty2.value && createVNode("div", {
        "class": ns2.e("empty")
      }, [ctx2.slots.empty ? ctx2.slots.empty() : props.empty])])]), [[resolveDirective("loading"), props.showLoading]]);
    };
  }
});
const tableColumnProps = {
  type: {
    type: String,
    default: ""
  },
  header: {
    type: String
  },
  field: {
    type: String,
    default: ""
  },
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  maxWidth: {
    type: [String, Number],
    default: ""
  },
  formatter: {
    type: Function
  },
  order: {
    type: Number,
    default: 0
  },
  sortable: {
    type: Boolean,
    default: false
  },
  sortDirection: {
    type: String,
    default: ""
  },
  sortMethod: {
    type: Function
  },
  filterable: {
    type: Boolean,
    default: false
  },
  filterMultiple: {
    type: Boolean,
    default: true
  },
  filterList: {
    type: Array,
    default: []
  },
  fixedLeft: {
    type: String
  },
  fixedRight: {
    type: String
  },
  align: {
    type: String,
    default: "left"
  },
  showOverflowTooltip: {
    type: Boolean,
    default: false
  },
  checkable: {
    type: Function
  },
  resizeable: {
    type: Boolean,
    default: false
  },
  reserveCheck: {
    type: Boolean,
    default: false
  },
  cellClass: {
    type: String,
    default: ""
  }
};
var column = "";
const IconOpen$1 = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg",
  "class": "svg-icon svg-icon-close"
}, [createVNode("g", {
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("rect", {
  "x": "0.5",
  "y": "0.5",
  "width": "15",
  "height": "15",
  "rx": "2",
  "stroke": "#5e7ce0"
}, null), createVNode("rect", {
  "x": "4",
  "y": "7",
  "width": "8",
  "height": "2",
  "fill": "#5e7ce0"
}, null)])]);
const IconClose$1 = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg",
  "class": "svg-icon"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("rect", {
  "x": "0.5",
  "y": "0.5",
  "width": "15",
  "height": "15",
  "rx": "2",
  "stroke": "#252b3a"
}, null), createVNode("path", {
  "fill": "#252b3a",
  "d": "M8.75,4 L8.75,7.25 L12,7.25 L12,8.75 L8.749,8.75 L8.75,12 L7.25,12 L7.249,8.75 L4,8.75 L4,7.25 L7.25,7.25 L7.25,4 L8.75,4 Z"
}, null)])]);
const ns$2 = useNamespace("table");
const cellMap = {
  checkable: {
    renderHeader(column2, store) {
      return h(Checkbox, {
        modelValue: store.states._checkAll.value,
        halfChecked: store.states._halfChecked.value,
        onChange: (val) => {
          store.states._checkAll.value = val;
          store.emitTableEvent("check-all-change", val, store.getCheckedRows());
        }
      });
    },
    renderCell(rowData, column2, store, rowIndex) {
      return h(Checkbox, {
        modelValue: store.isRowChecked(rowData, rowIndex),
        onChange: (val) => {
          store.checkRow(val, rowData, rowIndex);
          store.emitTableEvent("check-change", val, store.states._data.value[rowIndex], store.getCheckedRows());
        }
      });
    }
  },
  index: {
    renderHeader(column2) {
      var _a;
      return h("span", {
        class: "title"
      }, (_a = column2.header) != null ? _a : "#");
    },
    renderCell(rowData, column2, store, rowIndex) {
      return rowIndex + 1;
    }
  },
  expand: {
    renderHeader() {
      return createVNode("span", null, null);
    },
    renderCell(rowData, column2, store) {
      return createVNode(DIcon, {
        "name": "chevron-right",
        "class": "icon-expand-row",
        "onClick": () => {
          store.toggleRowExpansion(rowData);
        }
      }, null);
    }
  },
  editable: {
    renderHeader(column2) {
      var _a;
      return h("span", {
        class: "title"
      }, (_a = column2.header) != null ? _a : "");
    },
    renderCell(rowData, column2, store, rowIndex, props, cellMode, ctx2) {
      var _a, _b;
      let columnValue;
      if (cellMode.value === "edit") {
        columnValue = ctx2.slots.cellEdit ? ctx2.slots.cellEdit({
          row: rowData,
          rowIndex
        }) : "";
      } else {
        if (ctx2.slots.cell) {
          columnValue = createVNode("div", {
            "class": "cell-text"
          }, [ctx2.slots.cell({
            row: rowData,
            rowIndex
          })]);
        } else {
          const value = column2.field ? rowData[column2.field] : "";
          if (column2.formatter) {
            columnValue = column2.formatter(rowData, column2, value, rowIndex);
          }
          columnValue = createVNode("div", {
            "class": "cell-text"
          }, [(_b = (_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) != null ? _b : ""]);
        }
      }
      return h("div", {
        class: [ns$2.e("cell"), column2.type === "editable" && (cellMode == null ? void 0 : cellMode.value) === "readonly" && "editable-cell"]
      }, columnValue);
    }
  },
  default: {
    renderHeader(column2) {
      var _a;
      return h("span", {
        class: "title"
      }, (_a = column2.header) != null ? _a : "");
    },
    renderCell(rowData, column2, store, rowIndex, props, cellMode, ctx2) {
      var _a, _b, _c;
      let columnValue;
      if (ctx2.slots.default) {
        columnValue = ctx2.slots.default({
          row: rowData,
          rowIndex
        });
      } else {
        const value = column2.field ? rowData[column2.field] : "";
        if (column2.formatter) {
          columnValue = column2.formatter(rowData, column2, value, rowIndex);
        }
        columnValue = (_b = (_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) != null ? _b : "";
      }
      const hasExpandColumn = store.states.flatColumns.value.some((column22) => column22.type === "expand");
      const hasChildren = store.states._data.value.some((row2) => {
        var _a2;
        return (_a2 = row2.children) == null ? void 0 : _a2.length;
      });
      const level = store.states.rowLevelMap.value[getRowIdentity(rowData, props.rowKey)] || 0;
      const indentDom = h("span", {
        class: `${ns$2.e("indent")}`,
        style: {
          paddingLeft: `${level * props.indent}px`
        }
      }, "");
      const isTreeCell = store.states.firstDefaultColumn.value === column2.id;
      const showIndentDom = isTreeCell && level;
      const showExpendIconDom = isTreeCell && ((_c = rowData.children) == null ? void 0 : _c.length);
      const expendIconDom = createVNode("span", {
        "class": ns$2.e("tree-operate"),
        "onClick": () => {
          store.toggleRowExpansion(rowData);
        },
        "style": showExpendIconDom ? "" : "visibility: hidden;"
      }, [store.isRowExpanded(rowData) ? createVNode(IconOpen$1, null, null) : createVNode(IconClose$1, null, null)]);
      const cellDom = [];
      if (showIndentDom) {
        cellDom.push(indentDom);
      }
      if (hasChildren && !hasExpandColumn && isTreeCell) {
        cellDom.push(expendIconDom);
      }
      cellDom.push(columnValue);
      return h("div", {
        class: `${ns$2.e("cell")} `
      }, cellDom);
    }
  }
};
function createColumn(id, props, ctx2) {
  const {
    type: type4,
    field,
    header: header2,
    sortable,
    sortDirection,
    width,
    minWidth,
    maxWidth,
    formatter,
    sortMethod,
    filterable,
    filterList,
    filterMultiple,
    order,
    fixedLeft,
    fixedRight,
    align,
    showOverflowTooltip,
    resizeable,
    cellClass
  } = props;
  const column2 = reactive({ id });
  column2.type = type4.value;
  function renderHeader(columnItem, store) {
    if (ctx2.slots.header) {
      return ctx2.slots.header(columnItem);
    }
    return cellMap[type4.value || "default"].renderHeader(columnItem, store);
  }
  function renderCell(rowData, columnItem, store, rowIndex, tableProps2, cellMode) {
    if (ctx2.slots.default && columnItem.type === "index") {
      return ctx2.slots.default({ row: rowData, rowIndex });
    }
    return cellMap[type4.value || "default"].renderCell(rowData, columnItem, store, rowIndex, tableProps2, cellMode, ctx2);
  }
  watch([field, header2, order], ([fieldVal, headerVal, orderVal]) => {
    column2.field = fieldVal;
    column2.header = headerVal;
    column2.order = orderVal;
  }, { immediate: true });
  watch([sortable, sortDirection, sortMethod], ([sortableVal, sortDirectionVal, sortMethodVal]) => {
    column2.sortable = sortableVal;
    column2.sortDirection = sortDirectionVal;
    column2.sortMethod = sortMethodVal;
  }, { immediate: true });
  watch([filterable, filterList, filterMultiple], ([filterableVal, filterListVal, filterMultipleVal]) => {
    column2.filterable = filterableVal;
    column2.filterMultiple = filterMultipleVal;
    column2.filterList = filterListVal;
  }, { immediate: true });
  watch([fixedLeft, fixedRight], ([left, right]) => {
    column2.fixedLeft = left;
    column2.fixedRight = right;
  }, { immediate: true });
  watch(align, (alignVal) => {
    column2.align = alignVal;
  }, { immediate: true });
  watch(cellClass, (cellClassVal) => {
    column2.cellClass = cellClassVal;
  }, { immediate: true });
  watch(showOverflowTooltip, (showVal) => {
    column2.showOverflowTooltip = showVal;
  }, { immediate: true });
  watch(resizeable, (resizeVal) => {
    column2.resizeable = resizeVal;
  }, { immediate: true });
  watch([width, minWidth, maxWidth], ([widthVal, minWidthVal, maxWidthVal]) => {
    column2.width = formatWidth(widthVal);
    column2.minWidth = minWidthVal;
    column2.maxWidth = maxWidthVal;
    column2.realWidth = column2.width;
  }, { immediate: true });
  onBeforeMount(() => {
    column2.id = id;
    column2.renderHeader = renderHeader;
    column2.renderCell = renderCell;
    column2.formatter = formatter == null ? void 0 : formatter.value;
    column2.customFilterTemplate = ctx2.slots.customFilterTemplate;
    column2.subColumns = ctx2.slots.subColumns;
    column2.slots = ctx2.slots;
    column2.ctx = ctx2;
  });
  return column2;
}
function useRender() {
  const instance = getCurrentInstance();
  const columnOrTableParent = computed(() => {
    let parent = instance == null ? void 0 : instance.parent;
    while (parent && !parent.tableId && !parent.columnId) {
      parent = parent.parent;
    }
    return parent;
  });
  const getColumnIndex = (children, child) => {
    return Array.prototype.indexOf.call(children, child);
  };
  return { columnOrTableParent, getColumnIndex };
}
let columnIdInit = 1;
var Column = defineComponent({
  name: "DColumn",
  props: tableColumnProps,
  emits: ["filter-change", "resize-start", "resizing", "resize-end"],
  setup(props, ctx2) {
    const owner = inject(TABLE_TOKEN);
    const isSubColumn = ref(false);
    const {
      columnOrTableParent,
      getColumnIndex
    } = useRender();
    const parent = columnOrTableParent.value;
    const instance = getCurrentInstance();
    instance.columnId = `${parent.tableId || parent.columnId}_column_${columnIdInit++}`;
    const column2 = createColumn(instance.columnId, toRefs(props), ctx2);
    instance.columnConfig = column2;
    onBeforeMount(() => {
      isSubColumn.value = owner !== parent;
    });
    onMounted(() => {
      var _a, _b, _c;
      const children = isSubColumn.value ? (_b = (_a = parent == null ? void 0 : parent.vnode) == null ? void 0 : _a.el) == null ? void 0 : _b.children : (_c = owner == null ? void 0 : owner.hiddenColumns.value) == null ? void 0 : _c.children;
      const columnIndex = getColumnIndex(children || [], instance.vnode.el);
      columnIndex > -1 && (owner == null ? void 0 : owner.store.insertColumn(column2, isSubColumn.value ? parent.columnConfig : null));
      if (typeof props.checkable === "function") {
        for (const [rowIndex, row2] of owner == null ? void 0 : owner.store.states._data.value.entries()) {
          if (props.checkable(row2, rowIndex)) {
            owner.store.checkRow(true, row2);
          }
        }
      }
    });
    watch(() => column2.order, () => {
      owner == null ? void 0 : owner.store.sortColumn();
    });
    onBeforeUnmount(() => {
      owner == null ? void 0 : owner.store.removeColumn(column2);
    });
    return () => {
      var _a, _b;
      try {
        const defaultSlot = (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a, {
          row: {},
          column: {},
          $index: -1
        });
        return createVNode("div", null, [defaultSlot && Array.isArray(defaultSlot) ? defaultSlot.filter((child) => child.type.name === "DColumn").map((child) => createVNode(Fragment, null, [child])) : createVNode("div", null, null)]);
      } catch {
        return h("div", []);
      }
    };
  }
});
var TableInstall = {
  title: "Table \u8868\u683C",
  category: "\u6570\u636E\u5C55\u793A",
  status: "50%",
  install(app) {
    app.component(Table.name, Table);
    app.component(Column.name, Column);
  }
};
var removeBtnSvg = createVNode("svg", mergeProps({
  "width": "12px",
  "height": "12px",
  "viewBox": "0 0 12 12",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg"
}, {
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}), [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("path", {
  "d": "M8.86785321,3.13214679 C9.02624037,3.29053395 9.02624037,3.54733027 8.86785321,3.70571743 L6.573,6 L8.86785321,8.29428257 C9.02624037,8.45266973 9.02624037,8.70946605 8.86785321,8.86785321 C8.70946605,9.02624037 8.45266973,9.02624037 8.29428257,8.86785321 L6,6.573 L3.70571743,8.86785321 C3.54733027,9.02624037 3.29053395,9.02624037 3.13214679,8.86785321 C2.97375963,8.70946605 2.97375963,8.45266973 3.13214679,8.29428257 L5.427,6 L3.13214679,3.70571743 C2.97375963,3.54733027 2.97375963,3.29053395 3.13214679,3.13214679 C3.29053395,2.97375963 3.54733027,2.97375963 3.70571743,3.13214679 L6,5.427 L8.29428257,3.13214679 C8.45266973,2.97375963 8.70946605,2.97375963 8.86785321,3.13214679 Z",
  "fill-rule": "nonzero"
}, null)])]);
const tagInputProps = {
  modelValue: {
    type: Array,
    default: () => []
  },
  displayProperty: {
    type: String,
    default: "name"
  },
  placeholder: {
    type: String,
    default: ""
  },
  minLength: {
    type: Number,
    default: 3
  },
  maxLength: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  maxTags: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  maxTagsText: {
    type: String,
    default: ""
  },
  spellcheck: {
    type: Boolean,
    default: true
  },
  suggestionList: {
    type: Array,
    default: () => []
  },
  disabled: {
    type: Boolean,
    default: false
  },
  isAddBySpace: {
    type: Boolean,
    default: true
  },
  disabledText: {
    type: String,
    default: ""
  },
  noData: {
    type: String,
    default: "\u6682\u65E0\u6570\u636E"
  },
  caseSensitivity: {
    type: Boolean,
    default: false
  }
};
var tagInput = "";
const useInputKeydown = (props, handleEnter, onSelectIndexChange) => {
  const KEYS_MAP = {
    tab: "Tab",
    down: "ArrowDown",
    up: "ArrowUp",
    enter: "Enter",
    space: " "
  };
  const onInputKeydown = ($event) => {
    switch ($event.key) {
      case KEYS_MAP.tab:
      case KEYS_MAP.enter:
      case KEYS_MAP.space:
        if (!props.isAddBySpace && KEYS_MAP.space) {
          return;
        }
        handleEnter();
        break;
      case KEYS_MAP.down:
        onSelectIndexChange(true);
        break;
      case KEYS_MAP.up:
        onSelectIndexChange(false);
        break;
    }
  };
  return { onInputKeydown };
};
var TagInput = defineComponent({
  name: "DTagInput",
  props: tagInputProps,
  emits: ["update:modelValue", "update:suggestionList", "change"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTagInput", app);
    const ns2 = useNamespace("tag-input");
    const selectedTags = ref([]);
    watch(() => props.modelValue, () => {
      selectedTags.value = props.modelValue;
    }, {
      immediate: true,
      deep: true
    });
    const add = (arr, target) => {
      const res = Object.assign({}, target);
      delete res.__index;
      return arr.concat(res);
    };
    const remove = (arr, targetIdx) => {
      const newArr = arr.slice();
      newArr.splice(targetIdx, 1);
      return newArr;
    };
    const tagInputVal = ref("");
    const onInput = ($event) => {
      const v = $event.target.value || "";
      tagInputVal.value = v.trim();
    };
    const mergedSuggestions = computed(() => {
      const suggestions = props.suggestionList.map((item, index2) => {
        return __spreadValues({
          __index: index2
        }, item);
      });
      if (tagInputVal.value === "") {
        return suggestions;
      }
      return suggestions.filter((item) => {
        const val = item[props.displayProperty];
        if (props.caseSensitivity) {
          return val.indexOf(tagInputVal.value) !== -1;
        } else {
          return val.toLowerCase().indexOf(tagInputVal.value.toLowerCase()) !== -1;
        }
      });
    });
    const selectIndex = ref(0);
    watch(mergedSuggestions, () => {
      selectIndex.value = 0;
    });
    const onSelectIndexChange = (isUp = false) => {
      if (isUp) {
        selectIndex.value < mergedSuggestions.value.length - 1 ? selectIndex.value++ : selectIndex.value = 0;
        return;
      }
      selectIndex.value > 0 ? selectIndex.value-- : selectIndex.value = mergedSuggestions.value.length - 1;
    };
    const tagInputRef = ref();
    const isInputBoxFocus = ref(false);
    const onInputFocus = () => {
      isInputBoxFocus.value = true;
    };
    const handleEnter = () => {
      let res = {
        [props.displayProperty]: tagInputVal.value
      };
      if (tagInputVal.value === "" && mergedSuggestions.value.length === 0) {
        return false;
      }
      if (selectedTags.value.findIndex((item) => item[props.displayProperty] === tagInputVal.value) > -1) {
        tagInputVal.value = "";
        return false;
      }
      if (mergedSuggestions.value.length === 0 && (tagInputVal.value.length < props.minLength || tagInputVal.value.length > props.maxLength)) {
        tagInputVal.value = "";
        return false;
      }
      if (mergedSuggestions.value.length) {
        const target = mergedSuggestions.value[selectIndex.value];
        res = target;
        ctx2.emit("update:suggestionList", remove(props.suggestionList, target.__index));
      }
      const newTags = add(selectedTags.value, res);
      ctx2.emit("change", selectedTags.value, newTags);
      ctx2.emit("update:modelValue", newTags);
      mergedSuggestions.value.length === 0 && (tagInputVal.value = "");
    };
    const {
      onInputKeydown
    } = useInputKeydown(props, handleEnter, onSelectIndexChange);
    const removeTag = ($event, tagIdx) => {
      $event.preventDefault();
      const newTags = remove(selectedTags.value, tagIdx);
      ctx2.emit("change", selectedTags.value, newTags);
      ctx2.emit("update:modelValue", newTags);
      ctx2.emit("update:suggestionList", add(props.suggestionList, selectedTags.value[tagIdx]));
      nextTick(() => {
        var _a;
        (_a = tagInputRef.value) == null ? void 0 : _a.focus();
        isInputBoxFocus.value = true;
      });
    };
    const onSuggestionItemClick = ($event, itemIndex) => {
      $event.preventDefault();
      const target = mergedSuggestions.value[itemIndex];
      const newTags = add(selectedTags.value, target);
      const newSuggestions = remove(props.suggestionList, target.__index);
      ctx2.emit("change", selectedTags.value, newTags);
      ctx2.emit("update:modelValue", newTags);
      ctx2.emit("update:suggestionList", newSuggestions);
    };
    const isTagsLimit = computed(() => props.maxTags <= selectedTags.value.length);
    const isShowSuggestion = computed(() => {
      return !props.disabled && !isTagsLimit.value && isInputBoxFocus.value;
    });
    const chosenTags = () => {
      return createVNode("ul", {
        "class": ns2.e("tags"),
        "title": props.disabled ? props.disabledText : ""
      }, [selectedTags.value.map((tag2, tagIdx) => {
        return createVNode("li", {
          "class": ns2.e("tags__item")
        }, [createVNode("span", null, [tag2[props.displayProperty]]), !props.disabled && createVNode("a", {
          "class": "remove-button",
          "onClick": ($event) => removeTag($event, tagIdx)
        }, [removeBtnSvg])]);
      })]);
    };
    const origin = ref();
    const dropdownWidth = ref("0");
    const updateDropdownWidth = () => {
      var _a;
      dropdownWidth.value = ((_a = origin == null ? void 0 : origin.value) == null ? void 0 : _a.clientWidth) ? origin.value.clientWidth + "px" : "100%";
    };
    onMounted(() => {
      updateDropdownWidth();
      window.addEventListener("resize", updateDropdownWidth);
    });
    onUnmounted(() => {
      window.removeEventListener("resize", updateDropdownWidth);
    });
    const dropdownRef = ref();
    onClickOutside(dropdownRef, () => {
      isInputBoxFocus.value = false;
    }, {
      ignore: [origin]
    });
    const suggestionList = () => {
      const showNoData = mergedSuggestions.value.length === 0;
      const suggestionListItem = mergedSuggestions.value.map((item, index2) => {
        return createVNode("li", {
          "class": {
            [ns2.e("suggestion-list__item")]: true,
            selected: index2 === selectIndex.value
          },
          "onClick": ($event) => {
            onSuggestionItemClick($event, index2);
          }
        }, [item[props.displayProperty]]);
      });
      const noDataTplCls = `${ns2.e("suggestion-list__item")} ${ns2.e("suggestion-list__no-data")}`;
      const noDataTpl = createVNode("li", {
        "class": noDataTplCls
      }, [props.noData]);
      return createVNode(Teleport, {
        "to": "body"
      }, {
        default: () => [createVNode(Transition, {
          "name": "fade"
        }, {
          default: () => [createVNode(FlexibleOverlay, {
            "ref": dropdownRef,
            "origin": origin.value,
            "modelValue": isShowSuggestion.value,
            "onUpdate:modelValue": ($event) => isShowSuggestion.value = $event,
            "style": {
              zIndex: "var(--b-z-index-dropdown, 1052)"
            }
          }, {
            default: () => [createVNode("ul", {
              "class": ns2.e("suggestion-list"),
              "style": {
                width: `${dropdownWidth.value}`
              }
            }, [showNoData ? noDataTpl : suggestionListItem])]
          })]
        })]
      });
    };
    const tagsWrapperCls = computed(() => {
      return {
        [ns2.e("tags__wrapper")]: true,
        "is-disabled": props.disabled
      };
    });
    const inputCls = computed(() => {
      return {
        [ns2.e("input")]: true,
        [ns2.e("input_hide")]: props.disabled
      };
    });
    return () => createVNode("div", {
      "class": ns2.b(),
      "ref": origin
    }, [createVNode("div", {
      "class": tagsWrapperCls.value
    }, [chosenTags(), createVNode("input", {
      "type": "text",
      "ref": "tagInputRef",
      "value": tagInputVal.value,
      "class": inputCls.value,
      "onKeydown": onInputKeydown,
      "onFocus": onInputFocus,
      "onInput": onInput,
      "placeholder": isTagsLimit.value ? `${props.maxTagsText || t("maxTagsText")} ${props.maxTags}` : props.placeholder,
      "spellcheck": props.spellcheck,
      "disabled": isTagsLimit.value
    }, null)]), suggestionList()]);
  }
});
var TagInputInstall = {
  title: "TagInput \u6807\u7B7E\u8F93\u5165\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "90%",
  install(app) {
    app.component(TagInput.name, TagInput);
  }
};
var TextareaInstall = {
  title: "Textarea \u591A\u884C\u6587\u672C\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(Textarea.name, Textarea);
  }
};
function useTimePicker(hh, mm, ss, format2, props) {
  const showPopup = ref(false);
  const inputDom = ref();
  const overlayRef = ref();
  const timePopupDom = ref();
  const timePickerValue = ref("");
  const showClearIcon = ref(false);
  const firsthandActiveTime = ref(`${hh.value}:${mm.value}:${ss.value}`);
  const vModeValue = ref(props.modelValue);
  const formatTime = () => {
    let modelValue = vModeValue.value || "00:00:00";
    if (["hh:mm", "mm:ss"].includes(format2)) {
      modelValue = vModeValue.value || "00:00";
    }
    const timeArr = modelValue.split(":");
    let trueValue = "00:00:00";
    if (format2 === "hh:mm:ss") {
      trueValue = modelValue;
    } else if (format2 === "mm:hh:ss") {
      trueValue = `${timeArr[1]}:${timeArr[0]}:${timeArr[2]}`;
    } else if (format2 === "hh:mm") {
      trueValue = `${timeArr[0]}:${timeArr[1]}`;
    } else if (format2 === "mm:ss") {
      trueValue = `${timeArr[0]}:${timeArr[1]}`;
    }
    return trueValue;
  };
  const trueTimeValue = computed(() => {
    return formatTime();
  });
  const setInputValue = (h2, m, s) => {
    if (format2 === "hh:mm:ss") {
      vModeValue.value = `${h2}:${m}:${s}`;
    } else if (format2 === "mm:hh:ss") {
      vModeValue.value = `${m}:${h2}:${s}`;
    } else if (format2 === "hh:mm") {
      vModeValue.value = `${h2}:${m}`;
    } else if (format2 === "mm:ss") {
      vModeValue.value = `${m}:${s}`;
    }
  };
  const initData = () => {
    if (vModeValue.value) {
      firsthandActiveTime.value = props.modelValue;
      const time = vModeValue.value.split(":");
      setInputValue(time[0], time[1], time[2]);
    }
  };
  initData();
  const changeTimeData = ({ activeHour, activeMinute, activeSecond }) => {
    hh.value = activeHour.value || "00";
    mm.value = activeMinute.value || "00";
    ss.value = activeSecond.value || "00";
    firsthandActiveTime.value = `${hh.value}:${mm.value}:${ss.value}`;
    setInputValue(hh.value, mm.value, ss.value);
  };
  const mouseInputFun = () => {
    if (!vModeValue.value) {
      vModeValue.value = "00:00:00";
    }
    const minTimeValueArr = props.minTime.split(":");
    const maxTimeValueArr = props.maxTime.split(":");
    if (vModeValue.value > props.maxTime) {
      firsthandActiveTime.value = props.maxTime;
      setInputValue(maxTimeValueArr[0], maxTimeValueArr[1], maxTimeValueArr[2]);
    } else if (vModeValue.value < props.minTime) {
      firsthandActiveTime.value = props.minTime;
      setInputValue(minTimeValueArr[0], minTimeValueArr[1], minTimeValueArr[2]);
    }
    showPopup.value = true;
  };
  const clickVerifyFun = () => {
    if (props.disabled || props.readonly) {
      return;
    }
    mouseInputFun();
  };
  onClickOutside(overlayRef, () => {
    showPopup.value = false;
  }, { ignore: [inputDom] });
  const clearAll = (e) => {
    e.stopPropagation();
    if (props.minTime !== "00:00:00") {
      const minTimeArr = props.minTime.split(":");
      hh.value = minTimeArr[0];
      mm.value = minTimeArr[1];
      ss.value = minTimeArr[2];
    } else {
      hh.value = "00";
      mm.value = "00";
      ss.value = "00";
    }
    firsthandActiveTime.value = `${hh.value}:${mm.value}:${ss.value}`;
    setInputValue(hh.value, mm.value, ss.value);
  };
  const isOutOpen = () => {
    if (props.autoOpen) {
      mouseInputFun();
      showPopup.value = props.autoOpen;
    }
  };
  const chooseTime = (slotTime) => {
    if (slotTime.type) {
      if (slotTime.type.toLowerCase() === "hh") {
        hh.value = slotTime.time;
      } else if (slotTime.type.toLowerCase() === "mm") {
        mm.value = slotTime.time;
      } else if (slotTime.type.toLowerCase() === "ss") {
        ss.value = slotTime.time;
      }
      firsthandActiveTime.value = `${hh.value}:${mm.value}:${ss.value}`;
      setInputValue(hh.value, mm.value, ss.value);
    } else {
      const timeArr = slotTime.time.split(":");
      hh.value = timeArr[0];
      mm.value = timeArr[1];
      ss.value = timeArr[2];
      firsthandActiveTime.value = `${hh.value}:${mm.value}:${ss.value}`;
      setInputValue(hh.value, mm.value, ss.value);
    }
  };
  return {
    showPopup,
    trueTimeValue,
    timePickerValue,
    inputDom,
    timePopupDom,
    showClearIcon,
    firsthandActiveTime,
    vModeValue,
    clickVerifyFun,
    isOutOpen,
    clearAll,
    chooseTime,
    overlayRef,
    changeTimeData
  };
}
const timePopupProps = {
  showPopup: {
    type: Boolean,
    default: false
  },
  popupTop: {
    type: Number,
    default: -100
  },
  popupLeft: {
    type: Number,
    default: -100
  },
  popupWidth: {
    type: Number,
    default: 300
  },
  popupFormat: {
    type: String,
    default: "hh:mm:ss"
  },
  minTime: {
    type: String,
    default: "00:00:00"
  },
  maxTime: {
    type: String,
    default: "23:59:59"
  },
  bindData: {
    type: String,
    default: "00:00:00"
  }
};
var index = "";
function _isSlot$1(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var TimePopup = defineComponent({
  name: "DTimePopup",
  props: timePopupProps,
  emits: ["submitData", "change"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTimePopup", app);
    const ns2 = useNamespace("time-popup");
    const popupDome = ref();
    const timeListDom = ref();
    const hourList = initializeTimeData("hour");
    const minuteList = initializeTimeData("minute");
    const secondList = initializeTimeData("second");
    onMounted(() => {
      setTimeAstrict(hourList, minuteList, secondList, props.minTime, props.maxTime, props.popupFormat);
      timeListDom.value.setOuterTime(props.bindData);
    });
    watch(() => [props.showPopup, props.bindData], ([showPopup, newTimeVal], [, oldTimeVal]) => {
      if (showPopup || newTimeVal !== oldTimeVal) {
        timeListDom.value.setOuterTime(newTimeVal);
      } else {
        timeListDom.value.resetScrollTop();
      }
    });
    const changTimeData = () => {
      return timeListDom.value.getNewTime();
    };
    const changeData = (value) => {
      ctx2.emit("change", value);
    };
    const subDataFun = () => {
      ctx2.emit("submitData");
    };
    ctx2.expose({
      changTimeData
    });
    return () => {
      var _a, _b;
      let _slot;
      return createVNode("div", {
        "ref": popupDome,
        "class": ns2.b(),
        "style": {
          width: props.popupWidth + "px"
        }
      }, [createVNode(PopupLine, {
        "ref": timeListDom,
        "hourList": hourList,
        "minuteList": minuteList,
        "secondList": secondList,
        "minTime": props.minTime,
        "maxTime": props.maxTime,
        "format": props.popupFormat,
        "onChange": changeData
      }, null), createVNode("div", {
        "class": ns2.m("btn")
      }, [createVNode("div", {
        "class": "popup-slots"
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)]), createVNode("div", {
        "onClick": withModifiers(subDataFun, ["stop"])
      }, [createVNode(DButton, {
        "variant": "solid",
        "color": "secondary",
        "size": "sm"
      }, _isSlot$1(_slot = t("ok")) ? _slot : {
        default: () => [_slot]
      })])])]);
    };
  }
});
var timePicker = "";
var TimePicker = defineComponent({
  name: "DTimePicker",
  components: {
    TimePopup,
    DInput
  },
  props: timePickerProps,
  emits: ["change", "update:modelValue"],
  setup(props, ctx2) {
    const ns2 = useNamespace("time-picker");
    const activeHour = ref("00");
    const activeMinute = ref("00");
    const activeSecond = ref("00");
    const format2 = props.format.toLowerCase();
    const position = ref(["bottom-start", "top-start"]);
    const {
      showPopup,
      trueTimeValue,
      inputDom,
      overlayRef,
      showClearIcon,
      firsthandActiveTime,
      chooseTime,
      clickVerifyFun,
      isOutOpen,
      clearAll,
      timePopupDom,
      vModeValue,
      changeTimeData
    } = useTimePicker(activeHour, activeMinute, activeSecond, format2, props);
    const selectedTimeChange = () => {
      showPopup.value = false;
      ctx2.emit("change", trueTimeValue.value);
    };
    onMounted(isOutOpen);
    watch(trueTimeValue, (newValue) => {
      ctx2.emit("update:modelValue", trueTimeValue.value);
      if (newValue !== props.minTime && newValue !== "00:00") {
        showClearIcon.value = true;
      } else {
        showClearIcon.value = false;
      }
    });
    ctx2.expose({
      clearAll,
      chooseTime
    });
    return () => {
      return createVNode("div", {
        "class": ns2.b()
      }, [createVNode(DInput, {
        "modelValue": vModeValue.value,
        "ref": inputDom,
        "placeholder": props.placeholder,
        "disabled": props.disabled,
        "readonly": props.readonly,
        "size": props.size,
        "onFocus": withModifiers(clickVerifyFun, ["stop"])
      }, {
        suffix: () => createVNode("span", {
          "class": "time-input-icon"
        }, [createVNode("span", {
          "onClick": clearAll,
          "class": "clear-button"
        }, [showClearIcon.value ? createVNode(DIcon, {
          "size": "small",
          "name": "close"
        }, null) : ""]), createVNode(DIcon, {
          "size": "small",
          "name": "time"
        }, null)])
      }), createVNode(Teleport, {
        "to": "body"
      }, {
        default: () => [createVNode(Transition, {
          "name": "fade"
        }, {
          default: () => {
            var _a;
            return [createVNode(FlexibleOverlay, {
              "modelValue": showPopup.value,
              "onUpdate:modelValue": ($event) => showPopup.value = $event,
              "ref": overlayRef,
              "origin": (_a = inputDom.value) == null ? void 0 : _a.$el,
              "position": position.value,
              "align": "start",
              "style": {
                zIndex: "var(--b-z-index-dropdown, 1052)"
              }
            }, {
              default: () => [createVNode(TimePopup, {
                "ref": timePopupDom,
                "showPopup": showPopup.value,
                "popupWidth": props.timePickerWidth,
                "popupFormat": props.format.toLowerCase(),
                "minTime": props.minTime,
                "maxTime": props.maxTime,
                "bindData": firsthandActiveTime.value,
                "onSubmitData": selectedTimeChange,
                "onChange": changeTimeData
              }, {
                default: () => {
                  var _a2, _b;
                  return [(_b = (_a2 = ctx2.slots).customViewTemplate) == null ? void 0 : _b.call(_a2)];
                }
              })]
            })];
          }
        })]
      })]);
    };
  }
});
var TimePickerInstall = {
  title: "TimePicker \u65F6\u95F4\u9009\u62E9\u5668",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(TimePicker.name, TimePicker);
  }
};
const timeSelectProps = {
  modelValue: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  start: {
    type: String,
    default: "00:00"
  },
  end: {
    type: String,
    default: "24:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: {
    type: String,
    default: "-1:-1"
  },
  maxTime: {
    type: String,
    default: "24:00"
  },
  placeholder: {
    type: String,
    default: ""
  },
  size: {
    type: String
  },
  "onUpdate:modelValue": {
    type: Function
  },
  clearable: {
    type: Boolean,
    default: true
  }
};
function useTimeSelect(props, ctx2) {
  const select2 = ref();
  const padTime = (time) => {
    return `${time}`.padStart(2, "0");
  };
  const parseTimeToNumber = (time) => {
    const timeArr = (time || "").split(":");
    if (timeArr.length < 2) {
      return null;
    }
    const hour = Number.parseInt(timeArr[0], 10);
    const minute = Number.parseInt(timeArr[1], 10);
    return {
      hour,
      minute
    };
  };
  const formatTime = (time) => {
    return `${padTime(time.hour)}:${padTime(time.minute)}`;
  };
  const nextTime = (time, step22) => {
    const timeValue = parseTimeToNumber(time);
    const stepValue = parseTimeToNumber(step22);
    const nextTimeObj = {
      hour: timeValue.hour,
      minute: timeValue.minute
    };
    nextTimeObj.minute += stepValue.minute;
    nextTimeObj.hour += stepValue.hour;
    nextTimeObj.hour += Math.floor(nextTimeObj.minute / 60);
    nextTimeObj.minute = nextTimeObj.minute % 60;
    return formatTime(nextTimeObj);
  };
  const start = computed(() => {
    const startTime = parseTimeToNumber(props.start);
    return startTime ? formatTime(startTime) : "00:00";
  });
  const end = computed(() => {
    const endTime = parseTimeToNumber(props.end);
    return endTime ? formatTime(endTime) : "24:00";
  });
  const step2 = computed(() => {
    const stepTime = parseTimeToNumber(props.step);
    if (stepTime && stepTime.hour >= 0 && stepTime.minute >= 0 && stepTime.hour + stepTime.minute > 0) {
      return formatTime(stepTime);
    }
    return "00:30";
  });
  const minTime = computed(() => {
    const min = parseTimeToNumber(props.minTime);
    return min ? formatTime(min) : null;
  });
  const maxTime = computed(() => {
    const max = parseTimeToNumber(props.maxTime);
    return max ? formatTime(max) : null;
  });
  const compareTime = (time1, time2) => {
    const time1Obj = parseTimeToNumber(time1);
    const time2Obj = parseTimeToNumber(time2);
    const minutes01 = time1Obj.minute + time1Obj.hour * 60;
    const minutes02 = time2Obj.minute + time2Obj.hour * 60;
    if (minutes01 === minutes02) {
      return 0;
    }
    return minutes01 > minutes02 ? 1 : -1;
  };
  const options = computed(() => {
    const list2 = [];
    if (props.start && props.end && props.step) {
      let current = start.value;
      let currentTime;
      while (compareTime(current, end.value) <= 0) {
        currentTime = current;
        list2.push({
          value: currentTime,
          name: currentTime,
          disabled: compareTime(current, minTime.value || "-1:-1") < 0 || compareTime(current, maxTime.value || "24:00") > 0
        });
        current = nextTime(current, step2.value);
      }
    }
    return list2;
  });
  const changeData = (data) => {
    ctx2.emit("update:modelValue", data.value);
    ctx2.emit("change", data.value);
  };
  const clearData = (value) => {
    ctx2.emit("update:modelValue", value);
  };
  const focusFun = (e) => {
    ctx2.emit("focus", e);
  };
  const blurFun = (e) => {
    ctx2.emit("blur", e);
  };
  return {
    options,
    changeData,
    select: select2,
    clearData,
    focusFun,
    blurFun
  };
}
var TimeSelect = defineComponent({
  name: "DTimeSelect",
  components: {
    Select
  },
  props: timeSelectProps,
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTimeSelect", app);
    const {
      options,
      changeData,
      select: select2,
      clearData,
      focusFun,
      blurFun
    } = useTimeSelect(props, ctx2);
    return () => {
      return createVNode(Select, {
        "ref": select2,
        "modelValue": props.modelValue,
        "options": options.value,
        "onValueChange": changeData,
        "placeholder": props.placeholder || t("placeholder"),
        "option-disabled-key": "disabled",
        "disabled": props.disabled,
        "allow-clear": props.clearable,
        "size": props.size,
        "onClear": clearData,
        "onFocus": focusFun,
        "onBlur": blurFun
      }, null);
    };
  }
});
var TimeSelectInstall = {
  title: "TimeSelect \u65F6\u95F4\u9009\u62E9\u5668",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.component(TimeSelect.name, TimeSelect);
  }
};
const timeAxisProps = {
  direction: {
    type: String,
    default: "vertical"
  },
  center: {
    type: Boolean,
    default: false
  },
  mode: {
    type: String,
    default: "normal"
  },
  timePosition: {
    type: String,
    default: "left"
  }
};
const timeAxisItemProps = {
  time: {
    type: String
  },
  dotColor: {
    type: String
  },
  lineStyle: {
    type: String,
    default: "solid"
  },
  lineColor: {
    type: String
  },
  position: {
    type: String
  },
  timePosition: {
    type: String,
    default: "left"
  },
  type: {
    type: String,
    default: "primary"
  }
};
var TimelineItem = defineComponent({
  name: "DTimelineItem",
  components: {
    DIcon
  },
  props: timeAxisItemProps,
  emits: [],
  setup(props, ctx2) {
    const timeAxis = inject("timeAxis");
    const itemClass = "devui-timeline-item";
    const renderTime = () => {
      var _a, _b;
      return createVNode("div", {
        "class": `${itemClass}-time`
      }, [ctx2.slots.time ? (_b = (_a = ctx2.slots).time) == null ? void 0 : _b.call(_a) : props.time]);
    };
    const renderContent = () => {
      var _a, _b;
      return createVNode("div", {
        "class": `${itemClass}-content`
      }, [(_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a, props)]);
    };
    const renderPosition = (types2) => {
      if (types2.includes(props.position)) {
        return renderContent();
      } else {
        if (timeAxis.props.direction === "horizontal") {
          return renderTime();
        } else {
          return props.timePosition === "left" ? renderTime() : "";
        }
      }
    };
    const setTypeIcon = (type4) => {
      if (type4 === "primary") {
        return "";
      }
      return createVNode("i", {
        "class": `icon-${type4 === "success" ? "right" : type4}-o`
      }, null);
    };
    const renderDot = () => {
      var _a, _b;
      if (ctx2.slots.dot) {
        return createVNode("div", {
          "style": {
            color: props.dotColor
          },
          "class": `${itemClass}-dot`
        }, [" ", (_b = (_a = ctx2.slots).dot) == null ? void 0 : _b.call(_a)]);
      } else {
        return createVNode("div", {
          "class": `${itemClass}-dot ${itemClass}-type-${props.type}`,
          "style": {
            borderColor: props.dotColor
          }
        }, [setTypeIcon(props.type)]);
      }
    };
    return () => {
      return createVNode("div", {
        "class": itemClass
      }, [createVNode("div", {
        "class": `${itemClass}-data-left ${itemClass}-data-top`
      }, [renderPosition(["top", "left"])]), createVNode("div", {
        "class": `${itemClass}-axis`
      }, [renderDot(), timeAxis.props.direction === "vertical" && props.timePosition === "bottom" ? renderTime() : "", createVNode("div", {
        "class": `${itemClass}-line ${itemClass}-line-style-${props.lineStyle}`,
        "style": {
          borderColor: props.lineColor
        }
      }, [ctx2.slots.extra ? createVNode("div", {
        "class": `${itemClass}-line-extra`
      }, [ctx2.slots.extra()]) : ""])]), createVNode("div", {
        "class": `${itemClass}-data-right ${itemClass}-data-bottom`
      }, [renderPosition(["right", "bottom"])])]);
    };
  }
});
var timeline = "";
var Timeline = defineComponent({
  name: "DTimeline",
  components: {
    TimelineItem
  },
  props: timeAxisProps,
  emits: [],
  setup(props, ctx2) {
    provide("timeAxis", {
      ctx: ctx2,
      props
    });
    const timeAxis = ref();
    const style = reactive({
      marginLeft: "0px",
      height: "auto"
    });
    const setStyle2 = () => {
      style.height = "auto";
      style.marginLeft = "0px";
      if (props.direction === "horizontal") {
        nextTick(() => {
          var _a;
          const element = timeAxis.value;
          if (props.center) {
            style.marginLeft = (((_a = element == null ? void 0 : element.firstElementChild) == null ? void 0 : _a.clientWidth) || 0) / 2 + "px";
          }
          style.height = Math.max(...Array.from(element == null ? void 0 : element.querySelectorAll(".devui-timeline-item-data-top")).map((el) => el.clientHeight), ...Array.from(element == null ? void 0 : element.querySelectorAll(".devui-timeline-item-data-bottom")).map((el) => el.clientHeight)) * 2 + Math.max(...Array.from(element == null ? void 0 : element.querySelectorAll(".devui-timeline-item-axis")).map((el) => el.clientHeight)) + "px";
        });
      }
    };
    onMounted(() => {
      setStyle2();
    });
    watch(toRef(props, "direction"), () => {
      setStyle2();
    });
    return () => {
      const renderItemPosition = (item, position) => {
        return position ? createVNode(item, {
          "position": position
        }, null) : createVNode(item, null, null);
      };
      const renderItem = () => {
        var _a, _b, _c;
        const slots = (_c = (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : [];
        let children;
        if (slots.length === 1 && slots[0].type === Fragment) {
          children = slots[0].children || [];
        } else {
          children = slots;
        }
        return children.map((item, index2) => {
          var _a2, _b2, _c2, _d, _e, _f, _g, _h;
          if (index2 + 1 === children.length) {
            if (!((_a2 = item.props) == null ? void 0 : _a2.lineStyle) && !((_b2 = item.props) == null ? void 0 : _b2["line-style"])) {
              item = createVNode(item, {
                "line-style": "none"
              }, null);
            }
          }
          if (!((_c2 = item.props) == null ? void 0 : _c2.timePosition) && !((_d = item.props) == null ? void 0 : _d["time-position"])) {
            item = createVNode(item, {
              "time-position": props.timePosition ? props.timePosition : "left"
            }, null);
          }
          if (props.direction === "horizontal") {
            if (((_e = item.props) == null ? void 0 : _e.position) === "top" || ((_f = item.props) == null ? void 0 : _f.position) === "bottom") {
              return item;
            }
            if (props.mode === "alternative") {
              return renderItemPosition(item, index2 % 2 === 0 ? "bottom" : "top");
            } else {
              return renderItemPosition(item, "bottom");
            }
          } else {
            if (((_g = item.props) == null ? void 0 : _g.position) === "left" || ((_h = item.props) == null ? void 0 : _h.position) === "right") {
              return item;
            }
            if (props.mode === "alternative") {
              return renderItemPosition(item, index2 % 2 === 0 ? "left" : "right");
            } else {
              return renderItemPosition(item, "right");
            }
          }
        });
      };
      const getDirection = () => {
        return props.direction === "horizontal" ? "horizontal" : "vertical";
      };
      return createVNode("div", {
        "class": `devui-timeline devui-timeline-${getDirection()}  ${props.center ? "devui-timeline-" + getDirection() + "-center" : ""} `,
        "ref": timeAxis,
        "style": style
      }, [renderItem()]);
    };
  }
});
var TimelineInstall = {
  title: "Timeline \u65F6\u95F4\u8F74",
  category: "\u6570\u636E\u5C55\u793A",
  status: "100%",
  install(app) {
    app.component(Timeline.name, Timeline);
    app.component(TimelineItem.name, TimelineItem);
  }
};
const transferPanelProps = {
  title: {
    type: String,
    default: ""
  },
  height: {
    type: Number,
    default: 320
  },
  data: {
    type: Array,
    default: () => []
  },
  defaultChecked: {
    type: Array,
    default: () => []
  },
  filter: {
    type: [Boolean, Function],
    default: false
  },
  unit: {
    type: String,
    default: ""
  },
  placeholder: {
    type: String,
    default: ""
  },
  isKeyupSearch: {
    type: Boolean,
    default: true
  },
  search: {
    type: Function
  },
  direction: {
    type: String,
    default: "source"
  },
  isDrag: {
    type: Boolean,
    default: false
  },
  sortMethods: {
    type: Function
  },
  dragstart: {
    type: Function
  },
  drop: {
    type: Function
  },
  dragend: {
    type: Function
  },
  onUpdateAllChecked: {
    type: Function
  },
  onChangeChecked: {
    type: Function
  },
  renderContent: {
    type: Function
  }
};
const transferPanelState = (props, ctx2) => {
  const allChecked = ref(false);
  const query = ref("");
  const bodyHeight = computed(() => `${props.height}px`);
  const filterData = computed(() => {
    return props.data.filter((item) => {
      if (typeof props.filter === "function") {
        return props.filter(item, query.value);
      } else {
        return item.name.toLocaleUpperCase().includes(query.value.toLocaleUpperCase());
      }
    });
  });
  const checkableData = computed(() => {
    return filterData.value.filter((item) => {
      return !item.disabled;
    });
  });
  const allNum = computed(() => {
    return filterData.value.length;
  });
  const checkedNum = computed(() => {
    return filterData.value.length ? props.defaultChecked.length : filterData.value.length;
  });
  const allHalfchecked = computed(() => {
    if (allChecked.value) {
      return false;
    } else {
      return !!(filterData.value.length && props.defaultChecked.length > 0);
    }
  });
  const changeAllCheckedHandle = (value) => {
    const checkableDataValues = checkableData.value.map((item) => {
      return item.value;
    });
    const checkeds = value ? checkableDataValues : [];
    ctx2.emit("updateAllChecked", checkeds);
  };
  const updateAllCheckedHandle = () => {
    const checkableDataValues = checkableData.value.map((item) => {
      return item.value;
    });
    allChecked.value = checkableDataValues.length > 0 && checkableDataValues.every((item) => {
      return props.defaultChecked.includes(item);
    });
  };
  const updateCheckedDataHandle = (value) => {
    ctx2.emit("changeChecked", value);
  };
  const updateModelValueHandle = (value) => {
    query.value = value;
    props.search && typeof props.search === "function" && props.search(props.direction, filterData.value, value);
  };
  const updateDataHandle = (startValue, endValue) => {
    ctx2.emit(`updateData`, startValue, endValue);
  };
  watchEffect(() => {
    updateAllCheckedHandle();
  });
  watch(() => props.defaultChecked, (nVal) => {
    updateAllCheckedHandle();
    ctx2.emit("changeChecked", nVal);
  });
  return {
    bodyHeight,
    filterData,
    checkableData,
    allChecked,
    allHalfchecked,
    allNum,
    checkedNum,
    query,
    changeAllCheckedHandle,
    updateModelValueHandle,
    updateCheckedDataHandle,
    updateDataHandle
  };
};
const transferHeaderProps = {
  title: {
    type: String,
    default: ""
  },
  checked: {
    type: Boolean,
    default: false
  },
  halfchecked: {
    type: Boolean,
    default: false
  },
  total: {
    type: Number,
    default: 0
  },
  checkedNum: {
    type: Number,
    default: 0
  },
  unit: {
    type: String,
    default: ""
  },
  onChange: {
    type: Function
  },
  search: {
    type: Function
  }
};
const transferHeaderState$1 = (props, ctx2) => {
  const allCheckedChangeHandle = (value) => {
    ctx2.emit("change", value);
  };
  return {
    allCheckedChangeHandle
  };
};
var transferHeader = defineComponent({
  name: "DTransferHeader",
  components: {
    DCheckbox: Checkbox
  },
  props: transferHeaderProps,
  emits: ["change"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTransfer", app);
    const ns2 = useNamespace("transfer");
    const {
      allCheckedChangeHandle
    } = transferHeaderState$1(props, ctx2);
    return () => {
      return ctx2.slots.header && typeof ctx2.slots.header === "function" ? ctx2.slots.header() : createVNode("div", {
        "class": ns2.em("panel", "header")
      }, [createVNode("div", {
        "class": ns2.em("panel", "header-allChecked")
      }, [createVNode(Checkbox, {
        "modelValue": props.checked,
        "halfChecked": props.halfchecked,
        "onChange": (value) => {
          allCheckedChangeHandle(value);
        }
      }, {
        default: () => [props.title]
      })]), createVNode("div", {
        "class": ns2.em("panel", "header-num")
      }, [props.checkedNum, createTextVNode("/"), props.total, createVNode("span", {
        "class": ns2.em("panel", "header-num-unit")
      }, [props.unit || t("headerUnit")])])]);
    };
  }
});
const transferBodyProps = {
  height: {
    type: Number,
    default: 320
  },
  data: {
    type: Array,
    default: () => []
  },
  defaultChecked: {
    type: Array,
    default: () => []
  },
  filter: {
    type: [Boolean, Function],
    default: false
  },
  queryString: {
    type: String,
    default: ""
  },
  placeholder: {
    type: String,
    default: ""
  },
  isKeyupSearch: {
    type: Boolean,
    default: true
  },
  search: {
    type: Function
  },
  isDrag: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: void 0
  },
  dragstart: {
    type: Function
  },
  drop: {
    type: Function
  },
  dragend: {
    type: Function
  },
  renderContent: {
    type: Function
  }
};
const transferBodyState = (props, ctx2) => {
  const bodyHeight = computed(() => `${props.height}px`);
  const query = ref("");
  const checkedListModels = ref([]);
  const dragHighlight = ref(null);
  const dragOverNodeKey = ref();
  const dropPosition = ref(null);
  const dragTimer = ref(0);
  const dragRef = ref(null);
  const updateFilterQueryHandle = (value) => {
    ctx2.emit("updateQueryString", value);
  };
  const updateCheckedListModels = (idx, value) => {
    checkedListModels.value[idx].checked = value;
    ctx2.emit("change", checkedListModels.value.filter((item) => item.checked).map((item) => item.value));
  };
  const resetState = () => {
    dragOverNodeKey.value = "";
    dropPosition.value = null;
    dragHighlight.value = null;
  };
  const calcDropPosition = (event) => {
    const { clientY } = event;
    if (!dragRef.value) {
      return -1;
    }
    const { top, bottom, height } = event.target.getBoundingClientRect();
    const des = Math.max(height * 0.25, 2);
    if (clientY <= top + des) {
      return -1;
    }
    if (clientY >= bottom - des) {
      return 1;
    }
    return 0;
  };
  const dragstartHandle = (event, item) => {
    event.stopPropagation();
    dragRef.value = event.target;
    if (props.dragstart && typeof props.dragstart === "function") {
      props.dragstart(event, item);
    }
  };
  const setCurrentDragItem = (event, item, reset) => {
    event.stopPropagation();
    dragHighlight.value = reset ? item.value : null;
  };
  const setDragOverNodeKeyHandle = (event, item) => {
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(dragTimer.value);
    if (dragHighlight.value === item.value) {
      return;
    }
    const curDropPosition = calcDropPosition(event);
    dragTimer.value = window.setTimeout(() => {
      dragOverNodeKey.value = item.value;
      dropPosition.value = curDropPosition;
    }, 0);
  };
  const dragoverHandle = (event, item) => {
    event.preventDefault();
    event.stopPropagation();
    if (item.value === dragOverNodeKey.value) {
      const curDropPosition = calcDropPosition(event);
      if (curDropPosition === dropPosition.value) {
        return;
      }
      dropPosition.value = curDropPosition;
    }
  };
  const dragleaveHandle = (event, item) => {
    event.stopPropagation();
  };
  const dropHandle = (event, item) => {
    event.preventDefault();
    event.stopPropagation();
    if (props.drop && typeof props.drop === "function") {
      props.drop(event, item);
    }
    ctx2.emit("updateDataPosition", dragHighlight.value, item.value);
  };
  const dragendHandle = (event, item) => {
    event.stopPropagation();
    if (props.dragend && typeof props.dragend === "function") {
      props.dragend(event, item);
    }
    resetState();
  };
  watchEffect(() => {
    const models = [];
    query.value = props.queryString;
    props.data.forEach((item) => {
      models.push({
        value: item.value,
        name: item.name,
        checked: props.defaultChecked.includes(item.value)
      });
    });
    checkedListModels.value = models;
  });
  return {
    bodyHeight,
    query,
    checkedListModels,
    dragHighlight,
    dragOverNodeKey,
    dropPosition,
    dragTimer,
    dragRef,
    updateFilterQueryHandle,
    updateCheckedListModels,
    setCurrentDragItem,
    setDragOverNodeKeyHandle,
    dragoverHandle,
    dragleaveHandle,
    dropHandle,
    dragendHandle,
    dragstartHandle
  };
};
var transfer = "";
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var transferBody = defineComponent({
  name: "DTransferBody",
  components: {
    DSearch,
    DCheckbox: Checkbox,
    DCheckboxGroup,
    DIcon
  },
  props: transferBodyProps,
  emits: ["change", "update:modelValue", "updateQueryString", "updateDataPosition"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTransferBody", app);
    const ns2 = useNamespace("transfer");
    const {
      bodyHeight,
      query,
      checkedListModels,
      dragHighlight,
      dropPosition,
      dragOverNodeKey,
      updateFilterQueryHandle,
      updateCheckedListModels,
      setCurrentDragItem,
      setDragOverNodeKeyHandle,
      dragoverHandle,
      dragleaveHandle,
      dropHandle,
      dragendHandle,
      dragstartHandle
    } = transferBodyState(props, ctx2);
    const renderSearch = () => {
      return createVNode("div", {
        "class": ns2.em("panel", "body-search")
      }, [createVNode(DSearch, {
        "modelValue": query.value,
        "placeholder": props.placeholder || t("placeholder"),
        "is-keyup-search": props.isKeyupSearch,
        "size": "sm",
        "onSearch": (value) => {
          updateFilterQueryHandle(value);
        }
      }, null)]);
    };
    const renderCheckboxInner = (data) => {
      if (props.renderContent) {
        return props.renderContent(h, data);
      } else {
        return data.name;
      }
    };
    const renderCheckbox = () => {
      return props.data.map((data) => {
        let _slot;
        return createVNode(Checkbox, {
          "disabled": data.disabled,
          "value": data.value,
          "class": "transfer-checkbox"
        }, _isSlot(_slot = renderCheckboxInner(data)) ? _slot : {
          default: () => [_slot]
        });
      });
    };
    const renderList = () => {
      let _slot2;
      if (!props.data.length) {
        return createVNode("div", {
          "class": ns2.em("panel", "body-list-empty")
        }, [t("noData")]);
      }
      return createVNode(DCheckboxGroup, {
        "modelValue": props.defaultChecked,
        "class": ns2.em("panel", "body-list-group"),
        "onChange": (value) => {
          ctx2.emit("change", value);
        }
      }, _isSlot(_slot2 = renderCheckbox()) ? _slot2 : {
        default: () => [_slot2]
      });
    };
    const renderDragList = () => {
      if (!props.data.length) {
        return createVNode("div", {
          "class": ns2.em("panel", "body-list-empty")
        }, [t("noData")]);
      }
      return props.data.map((item, idx) => {
        const isEqual = dragOverNodeKey.value === item.value;
        return createVNode("div", {
          "class": {
            [ns2.em("panel", "body-list-item")]: true,
            [ns2.em("panel", "body-list-drag-dragging")]: dragHighlight.value === item.value,
            [ns2.em("panel", "body-list-drag-over")]: isEqual && dropPosition.value === 0,
            [ns2.em("panel", "body-list-drag-over-top")]: isEqual && dropPosition.value === -1,
            [ns2.em("panel", "body-list-drag-over-bottom")]: isEqual && dropPosition.value === 1
          },
          "onDragstart": (event) => {
            dragstartHandle(event, item);
          },
          "onDragenter": (event) => {
            setDragOverNodeKeyHandle(event, item);
          },
          "onDragover": (event) => {
            dragoverHandle(event, item);
          },
          "onDragleave": (event) => {
            dragleaveHandle(event, item);
          },
          "onDrop": (event) => {
            dropHandle(event, item);
          },
          "onDragend": (event) => {
            dragendHandle(event, item);
          },
          "draggable": item.value === dragHighlight.value
        }, [createVNode("span", {
          "class": "icon icon-drag-small",
          "onMousedown": (event) => {
            setCurrentDragItem(event, item, true);
          },
          "onMouseout": (event) => {
            setCurrentDragItem(event, item, false);
          }
        }, null), createVNode(Checkbox, {
          "label": item.name,
          "key": item.value,
          "disabled": item.disabled,
          "modelValue": checkedListModels.value[idx] && checkedListModels.value[idx].checked,
          "onChange": (value) => {
            updateCheckedListModels(idx, value);
          }
        }, null)]);
      });
    };
    return () => {
      return createVNode("div", {
        "class": ns2.em("panel", "body")
      }, [props.filter && renderSearch(), createVNode("div", {
        "class": ns2.em("panel", "body-list"),
        "style": {
          height: bodyHeight.value
        }
      }, [props.isDrag ? renderDragList() : renderList()])]);
    };
  }
});
var transferPanel = defineComponent({
  name: "DTransferPanel",
  components: {
    transferHeader,
    transferBody
  },
  props: transferPanelProps,
  emits: ["updateAllChecked", "changeButtonState", "changeChecked"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTransfer", app);
    const ns2 = useNamespace("transfer");
    const {
      allChecked,
      allHalfchecked,
      allNum,
      checkedNum,
      filterData,
      query,
      changeAllCheckedHandle,
      updateModelValueHandle,
      updateCheckedDataHandle,
      updateDataHandle
    } = transferPanelState(props, ctx2);
    return () => {
      return createVNode("div", {
        "class": ns2.e("panel")
      }, [createVNode(transferHeader, {
        "title": props.title,
        "checkedNum": checkedNum.value,
        "unit": props.unit || t("panelUnit"),
        "checked": allChecked.value,
        "halfchecked": allHalfchecked.value,
        "total": allNum.value,
        "search": props.search,
        "onChange": (value) => {
          changeAllCheckedHandle(value);
        }
      }, {
        header: ctx2.slots.header
      }), createVNode(transferBody, {
        "height": props.height,
        "filter": props.filter,
        "isKeyupSearch": props.isKeyupSearch,
        "isDrag": props.isDrag,
        "placeholder": props.placeholder,
        "defaultChecked": props.defaultChecked,
        "search": props.search,
        "dragstart": props.dragstart,
        "drop": props.drop,
        "dragend": props.dragend,
        "data": filterData.value,
        "queryString": query.value,
        "renderContent": props.renderContent,
        "onChange": (value) => {
          updateCheckedDataHandle(value);
        },
        "onUpdateQueryString": (value) => {
          updateModelValueHandle(value);
        },
        "onUpdateDataPosition": (startValue, endValue) => {
          updateDataHandle(startValue, endValue);
        }
      }, null)]);
    };
  }
});
const transferOperateProps = {
  sourceDisabled: {
    type: Boolean,
    default: true
  },
  targetDisabled: {
    type: Boolean,
    default: true
  },
  onToTarget: {
    type: Function
  },
  onToSource: {
    type: Function
  }
};
const transferHeaderState = (props, ctx2) => {
  const toTargetHandle = () => {
    ctx2.emit("toTarget");
  };
  const toSourceHandle = () => {
    ctx2.emit("toSource");
  };
  return {
    toTargetHandle,
    toSourceHandle
  };
};
var transferOperate = defineComponent({
  name: "DTransferOperate",
  components: {
    DButton
  },
  props: transferOperateProps,
  setup(props, ctx2) {
    const ns2 = useNamespace("transfer");
    const {
      toTargetHandle,
      toSourceHandle
    } = transferHeaderState(props, ctx2);
    return () => {
      return createVNode("div", {
        "class": ns2.e("operate")
      }, [ctx2.slots.operate && typeof ctx2.slots.operate === "function" ? ctx2.slots.operate() : createVNode("div", {
        "class": ns2.em("operate", "group")
      }, [createVNode(DButton, {
        "class": ns2.em("operate", "group-left"),
        "shape": "circle",
        "size": "lg",
        "disabled": props.targetDisabled,
        "icon": "chevron-right",
        "variant": !props.targetDisabled ? "solid" : "outline",
        "color": !props.targetDisabled ? "primary" : "secondary",
        "onClick": () => toTargetHandle()
      }, null), createVNode(DButton, {
        "class": ns2.em("operate", "group-right"),
        "shape": "circle",
        "size": "lg",
        "disabled": props.sourceDisabled,
        "icon": "collapse",
        "variant": !props.sourceDisabled ? "solid" : "outline",
        "color": !props.sourceDisabled ? "primary" : "secondary",
        "onClick": () => toSourceHandle()
      }, null)])]);
    };
  }
});
const transferProps = {
  modelValue: {
    type: Array,
    default: () => []
  },
  data: {
    type: Array,
    default: () => []
  },
  sourceDefaultChecked: {
    type: Array,
    default: () => []
  },
  targetDefaultChecked: {
    type: Array,
    default: () => []
  },
  titles: {
    type: Array,
    default: () => ["sourceHeader", "targetHeader"]
  },
  sourceOption: {
    type: Array,
    default: () => []
  },
  targetOption: {
    type: Array,
    default: () => []
  },
  filter: {
    type: [Boolean, Function],
    default: false
  },
  height: {
    type: Number,
    default: 320
  },
  unit: {
    type: String,
    default: ""
  },
  placeholder: {
    type: String,
    default: ""
  },
  isKeyupSearch: {
    type: Boolean,
    default: true
  },
  isSourceDrag: {
    type: Boolean,
    default: false
  },
  isTargetDrag: {
    type: Boolean,
    default: false
  },
  search: {
    type: Function
  },
  sortMethods: {
    type: Function
  },
  dragstart: {
    type: Function
  },
  drop: {
    type: Function
  },
  dragend: {
    type: Function
  },
  renderContent: {
    type: Function
  }
};
const transferState = (props, ctx2) => {
  const sourceTitle = computed(() => props.titles[0]);
  const targetTitle = computed(() => props.titles[1]);
  const sourceChecked = ref([]);
  const targetChecked = ref([]);
  const sourceData = ref([]);
  const targetData = ref([]);
  const sourceDirection = ref("source");
  const targetDirection = ref("target");
  const sourceDisabled = computed(() => {
    return targetChecked.value.length === 0;
  });
  const targetDisabled = computed(() => {
    return sourceChecked.value.length === 0;
  });
  const activeDirection = ref("source");
  const activeMoveItems = ref([]);
  const getTransferData = () => {
    return {
      data: (() => {
        var _a;
        if (props.data && typeof props.sortMethods === "function") {
          return (_a = props.sortMethods(props.data)) != null ? _a : [];
        }
        return props.data;
      })()
    };
  };
  const updateSourceAllCheckedHandle = (value) => {
    sourceChecked.value = value;
  };
  const updateTargetAllCheckedHandle = (value) => {
    targetChecked.value = value;
  };
  const updateSourceCheckedHandle = (value) => {
    sourceChecked.value = value;
  };
  const updateTargetCheckedHandle = (value) => {
    targetChecked.value = value;
  };
  const updateModelValue = () => {
    const targetValues = targetData.value.map((item) => {
      return item.value;
    });
    ctx2.emit("update:modelValue", targetValues);
    ctx2.emit("change", targetValues, activeDirection.value, activeMoveItems.value);
  };
  const toMoveTargetHandle = () => {
    const notIncluded = [];
    sourceData.value = sourceData.value.filter((item) => {
      if (!sourceChecked.value.includes(item.value)) {
        return true;
      }
      notIncluded.push(item);
      return false;
    });
    sourceChecked.value = [];
    targetData.value = targetData.value.concat(notIncluded);
    activeDirection.value = "target";
    activeMoveItems.value = notIncluded;
  };
  const toMoveSourceHandle = () => {
    const notIncluded = [];
    targetData.value = targetData.value.filter((item) => {
      if (!targetChecked.value.includes(item.value)) {
        return true;
      }
      notIncluded.push(item);
      return false;
    });
    targetChecked.value = [];
    sourceData.value = sourceData.value.concat(notIncluded);
    activeDirection.value = "source";
    activeMoveItems.value = notIncluded;
  };
  watch(targetData, () => {
    updateModelValue();
  });
  const getDargItemAndDropItem = (startValue, endValue, direction) => {
    const dataList = direction === "source" ? sourceData.value : targetData.value;
    let startIndex = -1, endIndex = -1;
    let dragItem = null, dropItem = null;
    for (let i = 0; i < dataList.length; i++) {
      if (dataList[i].value === startValue) {
        startIndex = i;
        dragItem = dataList[i];
      }
      if (dataList[i].value === endValue) {
        endIndex = i;
        dropItem = dataList[i];
      }
    }
    return {
      startIndex,
      endIndex,
      dragItem,
      dropItem
    };
  };
  const updateSourceDataHandle = (startValue, endValue) => {
    const { startIndex, endIndex, dragItem, dropItem } = getDargItemAndDropItem(startValue, endValue, "source");
    sourceData.value.splice(endIndex, 1, dragItem);
    sourceData.value.splice(startIndex, 1, dropItem);
  };
  const updateTargetDataHandle = (startValue, endValue) => {
    const { startIndex, endIndex, dragItem, dropItem } = getDargItemAndDropItem(startValue, endValue, "target");
    targetData.value.splice(endIndex, 1, dragItem);
    targetData.value.splice(startIndex, 1, dropItem);
  };
  onMounted(() => {
    const { data } = getTransferData();
    const sourceValues = [];
    const targetValues = [];
    data.forEach((item) => {
      if (props.sourceDefaultChecked.includes(item.value) && item.disabled === false) {
        sourceValues.push(item.value);
      }
      if (props.targetDefaultChecked.includes(item.value) && item.disabled === false) {
        targetValues.push(item.value);
      }
    });
    const sourceOption = [];
    const targetOption = [];
    data.forEach((item) => {
      if (props.modelValue.includes(item.value)) {
        targetOption.push(item);
      } else {
        sourceOption.push(item);
      }
    });
    sourceData.value = sourceOption;
    targetData.value = targetOption;
    sourceChecked.value = sourceValues;
    targetChecked.value = targetValues;
  });
  return {
    sourceTitle,
    targetTitle,
    sourceData,
    targetData,
    sourceDisabled,
    targetDisabled,
    sourceChecked,
    targetChecked,
    sourceDirection,
    targetDirection,
    updateSourceAllCheckedHandle,
    updateTargetAllCheckedHandle,
    updateSourceCheckedHandle,
    updateTargetCheckedHandle,
    toMoveTargetHandle,
    toMoveSourceHandle,
    updateSourceDataHandle,
    updateTargetDataHandle
  };
};
var Transfer = defineComponent({
  name: "DTransfer",
  components: {
    transferPanel,
    transferOperate
  },
  props: transferProps,
  emits: ["update:modelValue", "change"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTransfer", app);
    const ns2 = useNamespace("transfer");
    const {
      sourceTitle,
      targetTitle,
      sourceDisabled,
      targetDisabled,
      sourceData,
      targetData,
      sourceChecked,
      targetChecked,
      sourceDirection,
      targetDirection,
      updateSourceAllCheckedHandle,
      updateTargetAllCheckedHandle,
      updateSourceCheckedHandle,
      updateTargetCheckedHandle,
      toMoveTargetHandle,
      toMoveSourceHandle,
      updateSourceDataHandle,
      updateTargetDataHandle
    } = transferState(props, ctx2);
    return () => {
      return createVNode("div", {
        "class": ns2.b()
      }, [ctx2.slots.header && ctx2.slots.header(), createVNode(transferPanel, {
        "filter": props.filter,
        "isKeyupSearch": props.isKeyupSearch,
        "isDrag": props.isSourceDrag,
        "height": props.height,
        "unit": props.unit || t("unit"),
        "placeholder": props.placeholder,
        "sortMethods": props.sortMethods,
        "search": props.search,
        "dragstart": props.dragstart,
        "drop": props.drop,
        "dragend": props.dragend,
        "title": sourceTitle.value,
        "data": sourceData.value,
        "defaultChecked": sourceChecked.value,
        "direction": sourceDirection.value,
        "renderContent": props.renderContent,
        "class": ns2.e("source"),
        "onUpdateAllChecked": (value) => {
          updateSourceAllCheckedHandle(value);
        },
        "onChangeChecked": (value) => {
          updateSourceCheckedHandle(value);
        },
        "onUpdateData": (startValue, endValue) => {
          updateSourceDataHandle(startValue, endValue);
        }
      }, {
        header: ctx2.slots.sourceHeader
      }), createVNode(transferOperate, {
        "sourceDisabled": sourceDisabled.value,
        "targetDisabled": targetDisabled.value,
        "onToTarget": () => {
          toMoveTargetHandle();
        },
        "onToSource": () => {
          toMoveSourceHandle();
        }
      }, __spreadValues({}, ctx2.slots)), createVNode(transferPanel, {
        "filter": props.filter,
        "isKeyupSearch": props.isKeyupSearch,
        "isDrag": props.isTargetDrag,
        "height": props.height,
        "unit": props.unit || t("unit"),
        "placeholder": props.placeholder,
        "sortMethods": props.sortMethods,
        "search": props.search,
        "dragstart": props.dragstart,
        "drop": props.drop,
        "dragend": props.dragend,
        "title": targetTitle.value,
        "data": targetData.value,
        "defaultChecked": targetChecked.value,
        "direction": targetDirection.value,
        "renderContent": props.renderContent,
        "class": ns2.e("target"),
        "onUpdateAllChecked": (value) => {
          updateTargetAllCheckedHandle(value);
        },
        "onChangeChecked": (value) => {
          updateTargetCheckedHandle(value);
        },
        "onUpdateData": (startValue, endValue) => {
          updateTargetDataHandle(startValue, endValue);
        }
      }, {
        header: ctx2.slots.targetHeader
      })]);
    };
  }
});
var TransferInstall = {
  title: "Transfer \u7A7F\u68AD\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "60%",
  install(app) {
    app.component(Transfer.name, Transfer);
  }
};
const USE_TREE_TOKEN = "use-tree-token";
const TREE_INSTANCE = "tree-instance";
const NODE_HEIGHT = 30;
const NODE_INDENT = 24;
const commonProps = {
  check: {
    type: [Boolean, String],
    default: false
  },
  dragdrop: {
    type: [Boolean, Object],
    default: false
  },
  operate: {
    type: [Boolean, String, Array],
    default: false
  }
};
const treeProps = __spreadProps(__spreadValues({
  data: {
    type: Object,
    default: []
  }
}, commonProps), {
  height: {
    type: [Number, String]
  }
});
const treeNodeProps = __spreadValues({
  data: {
    type: Object,
    default: {}
  }
}, commonProps);
function useCheck(options = ref({ checkStrategy: "both" })) {
  return function useCheckFn(data, core, context) {
    const { setNodeValue, getNode, getChildren, getParent } = core;
    const checkNode = (node) => {
      setNodeValue(node, "checked", true);
      context.emit("check-change", node);
    };
    const setNodeValueInAvailable = (node, key, value) => {
      if (!node.disableCheck) {
        setNodeValue(node, key, value);
      }
    };
    const uncheckNode = (node) => {
      setNodeValue(node, "checked", false);
      context.emit("check-change", node);
    };
    const controlParentNodeChecked = (node, checked) => {
      if (!node.parentId) {
        return;
      }
      const parentNode = getParent(node);
      if (!parentNode) {
        return;
      }
      let childChecked = checked;
      if (checked) {
        if (!parentNode.checked) {
          setNodeValueInAvailable(parentNode, "checked", true);
        }
      } else {
        const siblingNodes = getChildren(parentNode);
        const checkedSiblingNodes = siblingNodes.filter((item) => item.checked && item.id !== node.id);
        if (checkedSiblingNodes.length === 0) {
          setNodeValueInAvailable(parentNode, "checked", false);
        } else {
          setNodeValueInAvailable(parentNode, "checked", true);
          childChecked = true;
        }
      }
      if (parentNode.parentId) {
        controlParentNodeChecked(parentNode, childChecked);
      }
    };
    const toggleCheckNode = (node) => {
      const checked = getNode(node).checked;
      if (checked) {
        setNodeValue(node, "checked", false);
        context.emit("check-change", node);
        if (["downward", "both"].includes(options.value.checkStrategy)) {
          getChildren(node).forEach((item) => setNodeValueInAvailable(item, "checked", false));
        }
      } else {
        setNodeValue(node, "checked", true);
        context.emit("check-change", node);
        if (["downward", "both"].includes(options.value.checkStrategy)) {
          getChildren(node).forEach((item) => setNodeValueInAvailable(item, "checked", true));
        }
      }
      if (["upward", "both"].includes(options.value.checkStrategy)) {
        controlParentNodeChecked(node, !checked);
      }
    };
    const getCheckedNodes = () => {
      return data.value.filter((node) => node.checked);
    };
    return {
      checkNode,
      uncheckNode,
      toggleCheckNode,
      getCheckedNodes
    };
  };
}
let selectedNodes = [];
function useInitSelectCollection() {
  const setInitSelectedNode2 = (node) => {
    selectedNodes.push(node);
  };
  const getInitSelectedNodes = () => {
    return selectedNodes;
  };
  const clearInitSelectedNodes = () => {
    selectedNodes = [];
  };
  return {
    setInitSelectedNode: setInitSelectedNode2,
    getInitSelectedNodes,
    clearInitSelectedNodes
  };
}
const { setInitSelectedNode } = useInitSelectCollection();
function generateInnerTree(tree2, key = "children", level = 0, path = []) {
  level++;
  return tree2.reduce((acc, item, currentIndex) => {
    var _a, _b, _c;
    const newItem = Object.assign({}, item);
    if (newItem.id === void 0) {
      newItem.id = randomId();
      newItem.idType = "random";
    }
    if (newItem.selected) {
      setInitSelectedNode(newItem);
    }
    newItem.level = level;
    newItem.parentChildNodeCount = tree2.length;
    newItem.currentIndex = currentIndex;
    newItem.childNodeCount = ((_a = newItem.children) == null ? void 0 : _a.length) || 0;
    if (path.length > 0 && ((_b = path[path.length - 1]) == null ? void 0 : _b.level) >= level) {
      while (((_c = path[path.length - 1]) == null ? void 0 : _c.level) >= level) {
        path.pop();
      }
    }
    path.push(newItem);
    const parentNode = path[path.length - 2];
    if (parentNode) {
      newItem.parentId = parentNode.id;
    }
    if (!newItem[key]) {
      return acc.concat(__spreadProps(__spreadValues({}, newItem), { isLeaf: newItem.isLeaf === false ? false : true }));
    } else {
      return acc.concat(omit(newItem, "children"), generateInnerTree(newItem[key], key, level, path));
    }
  }, []);
}
const DEFAULT_CONFIG = {
  expanded: false,
  recursive: true
};
function useCore() {
  const nodeMap2 = /* @__PURE__ */ new Map();
  return function useCoreFn(data) {
    const getLevel = (node) => {
      var _a;
      return (_a = data.value.find((item) => item.id === node.id)) == null ? void 0 : _a.level;
    };
    const getChildren = (node, userConfig = DEFAULT_CONFIG) => {
      if (node.isLeaf) {
        return [];
      }
      let mapKey = node.id || "";
      if (userConfig.expanded) {
        mapKey += "_expanded";
      }
      if (userConfig.recursive) {
        mapKey += "_recursive";
      }
      if (node.id && nodeMap2.has(mapKey)) {
        const cacheNode = nodeMap2.get(node.id);
        if (cacheNode) {
          return cacheNode;
        }
      }
      const getInnerExpendedTree = () => {
        return computed(() => {
          let excludeNodes = [];
          const result22 = [];
          for (let i = 0, len = data == null ? void 0 : data.value.length; i < len; i++) {
            const item = data == null ? void 0 : data.value[i];
            if (excludeNodes.map((innerNode) => innerNode.id).includes(item.id)) {
              continue;
            }
            if (item.expanded !== true && !item.isLeaf) {
              excludeNodes = getChildren(item);
            }
            result22.push(item);
          }
          return result22;
        });
      };
      const result2 = [];
      const config = __spreadValues(__spreadValues({}, DEFAULT_CONFIG), userConfig);
      const treeData = config.expanded ? getInnerExpendedTree() : data;
      const startIndex = treeData.value.findIndex((item) => item.id === node.id);
      for (let i = startIndex + 1; i < treeData.value.length && getLevel(node) < treeData.value[i].level; i++) {
        if (config.recursive && !treeData.value[i].isHide) {
          result2.push(treeData.value[i]);
        } else if (getLevel(node) === treeData.value[i].level - 1 && !treeData.value[i].isHide) {
          result2.push(treeData.value[i]);
        }
      }
      if (node.id) {
        nodeMap2.set(mapKey, result2);
      }
      return result2;
    };
    const clearNodeMap = () => {
      nodeMap2.clear();
    };
    const getParent = (node) => {
      return data.value.find((item) => item.id === node.parentId);
    };
    const getExpendedTree = () => {
      return computed(() => {
        let excludeNodes = [];
        const result2 = [];
        for (let i = 0, len = data == null ? void 0 : data.value.length; i < len; i++) {
          const item = data == null ? void 0 : data.value[i];
          if (excludeNodes.map((node) => node.id).includes(item.id) || item.isHide) {
            continue;
          }
          if (item.expanded !== true) {
            excludeNodes = getChildren(item);
          }
          result2.push(item);
        }
        return result2;
      });
    };
    const getIndex = (node) => {
      if (!node) {
        return -1;
      }
      return data.value.findIndex((item) => item.id === node.id);
    };
    const getNode = (node) => {
      return data.value.find((item) => item.id === node.id);
    };
    const setNodeValue = (node, key, value) => {
      clearNodeMap();
      if (getIndex(node) !== -1) {
        data.value[getIndex(node)][key] = value;
      }
    };
    const setTree = (newTree) => {
      clearNodeMap();
      data.value = generateInnerTree(newTree);
    };
    const getTree = () => {
      return data.value;
    };
    onUnmounted(() => {
      clearNodeMap();
    });
    return {
      getLevel,
      getChildren,
      clearNodeMap,
      getParent,
      getExpendedTree,
      getIndex,
      getNode,
      setNodeValue,
      setTree,
      getTree
    };
  };
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array4, key) {
  var length = array4.length;
  while (length--) {
    if (eq$1(array4[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$4 = root$7.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result2;
}
var _getRawTag = getRawTag$1;
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObject$5(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$5;
var baseGetTag$3 = _baseGetTag, isObject$4 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$4(value)) {
    return false;
  }
  var tag2 = baseGetTag$3(value);
  return tag2 == funcTag$2 || tag2 == genTag$1 || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$3 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$3(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object4, key) {
  return object4 == null ? void 0 : object4[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object4, key) {
  var value = getValue(object4, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$5 = _root;
var Map$4 = getNative$6(root$5, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED$1 ? void 0 : result2;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result2 = getMapData$3(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
function arrayEach$1(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$1 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$1;
var defineProperty = _defineProperty;
function baseAssignValue$2(object4, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object4, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseAssignValue$1 = _baseAssignValue, eq = eq_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue$2(object4, key, value) {
  var objValue = object4[key];
  if (!(hasOwnProperty$5.call(object4, key) && eq(objValue, value)) || value === void 0 && !(key in object4)) {
    baseAssignValue$1(object4, key, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source, props, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object4, key, newValue);
    } else {
      assignValue$1(object4, key, newValue);
    }
  }
  return object4;
}
var _copyObject = copyObject$4;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result2 = Array(n);
  while (++index2 < n) {
    result2[index2] = iteratee(index2);
  }
  return result2;
}
var _baseTimes = baseTimes$1;
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$2(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$1;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$2 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$4 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype$2(object4)) {
    return nativeKeys(object4);
  }
  var result2 = [];
  for (var key in Object(object4)) {
    if (hasOwnProperty$2.call(object4, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$3(object4) {
  return isArrayLike$1(object4) ? arrayLikeKeys$1(object4) : baseKeys(object4);
}
var keys_1 = keys$3;
var copyObject$3 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object4, source) {
  return object4 && copyObject$3(source, keys$2(source), object4);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object4) {
  var result2 = [];
  if (object4 != null) {
    for (var key in Object(object4)) {
      result2.push(key);
    }
  }
  return result2;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn$1(object4) {
  if (!isObject$2(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype$1(object4), result2 = [];
  for (var key in object4) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object4, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object4, source) {
  return object4 && copyObject$2(source, keysIn$2(source), object4);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result2);
    return result2;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$1(source, array4) {
  var index2 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source[index2];
  }
  return array4;
}
var _copyArray = copyArray$1;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object4) {
  return copyObject$1(source, getSymbols$2(source), object4);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(array4, values) {
  var index2 = -1, length = values.length, offset2 = array4.length;
  while (++index2 < length) {
    array4[offset2 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$2;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object4) {
  var result2 = [];
  while (object4) {
    arrayPush$1(result2, getSymbols$1(object4));
    object4 = getPrototype$1(object4);
  }
  return result2;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object4) {
  return copyObject(source, getSymbolsIn$1(source), object4);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush = _arrayPush, isArray$1 = isArray_1;
function baseGetAllKeys$2(object4, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object4);
  return isArray$1(object4) ? result2 : arrayPush(result2, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(object4) {
  return baseGetAllKeys$1(object4, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object4) {
  return baseGetAllKeys(object4, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var getNative$3 = _getNative, root$4 = _root;
var DataView$1 = getNative$3(root$4, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$3 = _root;
var Promise$2 = getNative$2(root$3, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$2 = _root;
var Set$2 = getNative$1(root$2, "Set");
var _Set = Set$2;
var getNative = _getNative, root$1 = _root;
var WeakMap$2 = getNative(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$3 = baseGetTag;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result2 = baseGetTag(value), Ctor = result2 == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result2;
  };
}
var _getTag = getTag$3;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(array4) {
  var length = array4.length, result2 = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
    result2.index = array4.index;
    result2.input = array4.input;
  }
  return result2;
}
var _initCloneArray = initCloneArray$1;
var root = _root;
var Uint8Array$1 = root.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array2 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
  return result2;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp4) {
  var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result2.lastIndex = regexp4.lastIndex;
  return result2;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object4, tag2, isDeep) {
  var Ctor = object4.constructor;
  switch (tag2) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object4);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object4);
    case dataViewTag$1:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object4);
    case regexpTag$1:
      return cloneRegExp(object4);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object4);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$1 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result2 = new object4();
    object4.prototype = void 0;
    return result2;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBuffer$2.exports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key, object4, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result2 = object4 ? customizer(value, key, object4, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result2 = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result2);
    }
  } else {
    var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag2 == objectTag || tag2 == argsTag || isFunc && !object4) {
      result2 = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object4 ? value : {};
      }
      result2 = initCloneByTag(value, tag2, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result2, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
const formatCheckStatus = (check) => {
  return typeof check === "boolean" ? check ? "both" : "none" : check;
};
const formatBasicTree = (trees, keyName = "id", childrenName = "children", parentId) => {
  return trees.map((item) => {
    var _a;
    const curItem = __spreadProps(__spreadValues({}, item), { parentId });
    if (!(keyName in curItem) || !curItem[keyName]) {
      curItem[keyName] = randomId();
      curItem.idType = "random";
    }
    if (childrenName in curItem && Array.isArray(curItem[childrenName]) && ((_a = curItem[childrenName]) == null ? void 0 : _a.length)) {
      curItem[childrenName] = formatBasicTree(curItem[childrenName], keyName, childrenName, curItem[keyName]);
      if ("isLeaf" in curItem) {
        delete curItem.isLeaf;
      }
    } else {
      if (!("isLeaf" in curItem)) {
        curItem.isLeaf = true;
      }
    }
    if (!curItem.parentId) {
      delete curItem.parentId;
    }
    return curItem;
  });
};
const ns$1 = useNamespace("tree");
const dropTypeMap = {
  dropPrev: ns$1.em("node", "drop-prev"),
  dropNext: ns$1.em("node", "drop-next"),
  dropInner: ns$1.em("node", "drop-inner")
};
function useDragdrop(props, data) {
  return function useDragdropFn() {
    const dragState = reactive({
      dropType: void 0,
      draggingNode: null,
      draggingTreeNode: null
    });
    const treeIdMapValue = computed(() => {
      return data.value.reduce((acc, cur) => __spreadProps(__spreadValues({}, acc), {
        [cur.id]: cur
      }), {});
    });
    const removeDraggingStyle = (target) => {
      target == null ? void 0 : target.classList.remove(...Object.values(dropTypeMap));
    };
    const checkIsParent = (childNodeId, parentNodeId) => {
      var _a;
      const realParentId = (_a = treeIdMapValue.value[childNodeId]) == null ? void 0 : _a.parentId;
      if (realParentId === parentNodeId) {
        return true;
      } else if (realParentId !== void 0) {
        return checkIsParent(realParentId, parentNodeId);
      } else {
        return false;
      }
    };
    const handlerDropData = (dragNodeId, dropNodeId, currentDropType) => {
      const cloneData = cloneDeep_1(data.value);
      let currentDragNode;
      let currentDropNode;
      const findDragAndDropNode = (curr) => {
        if (!Array.isArray(curr)) {
          return;
        }
        curr.every((item, index2) => {
          if (currentDragNode && currentDropNode) {
            return false;
          }
          if (item.id === dragNodeId) {
            currentDragNode = { target: curr, index: index2, item };
          } else if (item.id === dropNodeId) {
            currentDropNode = { target: curr, index: index2, item };
          }
          if (!currentDragNode || !currentDropNode) {
            Array.isArray(item.children) && findDragAndDropNode(item.children);
          }
          return true;
        });
      };
      findDragAndDropNode(cloneData);
      if (currentDragNode && currentDropNode && currentDropType) {
        const cloneDrapNode = Object.assign({}, currentDragNode.target[currentDragNode.index]);
        if (currentDropType === "dropPrev") {
          currentDropNode.target.splice(currentDropNode.index, 0, cloneDrapNode);
        } else if (currentDropType === "dropNext") {
          currentDropNode.target.splice(currentDropNode.index + 1, 0, cloneDrapNode);
        } else if (currentDropType === "dropInner") {
          const children = currentDropNode.target[currentDropNode.index].children;
          if (Array.isArray(children)) {
            children.unshift(cloneDrapNode);
          } else {
            currentDropNode.target[currentDropNode.index].children = [cloneDrapNode];
          }
        }
        const targetIndex = currentDragNode.target.indexOf(currentDragNode.item);
        if (targetIndex !== -1) {
          currentDragNode.target.splice(targetIndex, 1);
        }
      }
      return cloneData;
    };
    const clearDragDropInfo = () => {
      dragState.dropType = void 0;
      dragState.draggingNode = null;
      dragState.draggingTreeNode = null;
    };
    const onDragstart = (event, treeNode) => {
      var _a;
      event.stopPropagation();
      dragState.draggingNode = event.target;
      dragState.draggingTreeNode = treeNode;
      const treeInfo = {
        type: "tree-node",
        nodeId: treeNode.id
      };
      (_a = event.dataTransfer) == null ? void 0 : _a.setData("Text", JSON.stringify(treeInfo));
    };
    const onDragover = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (!dragState.draggingNode) {
        return;
      }
      if (props.dragdrop) {
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = "move";
        }
        if (!data) {
          return;
        }
        let curDropType = {};
        if (typeof props.dragdrop === "object") {
          curDropType = props.dragdrop;
        } else if (props.dragdrop === true) {
          curDropType = { dropInner: true };
        }
        const { dropPrev, dropNext, dropInner } = curDropType;
        let innerDropType;
        const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
        const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
        const currentTarget = event.currentTarget;
        const targetPosition = currentTarget == null ? void 0 : currentTarget.getBoundingClientRect();
        const distance = event.clientY - ((targetPosition == null ? void 0 : targetPosition.top) || 0);
        if (distance < ((targetPosition == null ? void 0 : targetPosition.height) || 0) * prevPercent) {
          innerDropType = "dropPrev";
        } else if (distance > ((targetPosition == null ? void 0 : targetPosition.height) || 0) * nextPercent) {
          innerDropType = "dropNext";
        } else if (dropInner) {
          innerDropType = "dropInner";
        } else {
          innerDropType = void 0;
        }
        if (innerDropType) {
          const classList = currentTarget == null ? void 0 : currentTarget.classList;
          if (classList) {
            if (!classList.contains(dropTypeMap[innerDropType])) {
              removeDraggingStyle(currentTarget);
              classList.add(dropTypeMap[innerDropType]);
            }
          }
        } else {
          removeDraggingStyle(currentTarget);
        }
        dragState.dropType = innerDropType;
      }
    };
    const onDragleave = (event) => {
      event.stopPropagation();
      if (!dragState.draggingNode) {
        return;
      }
      removeDraggingStyle(event.currentTarget);
    };
    const onDrop2 = (event, dropNode) => {
      var _a;
      event.preventDefault();
      event.stopPropagation();
      removeDraggingStyle(event.currentTarget);
      if (!dragState.draggingNode) {
        return;
      }
      if (!props.dragdrop) {
        return;
      }
      const treeInfoStr = (_a = event.dataTransfer) == null ? void 0 : _a.getData("Text");
      if (treeInfoStr) {
        try {
          const treeInfo = JSON.parse(treeInfoStr);
          if (typeof treeInfo === "object" && treeInfo.type === "tree-node") {
            const dragNodeId = treeInfo.nodeId;
            const isParent = checkIsParent(dropNode.id, dragNodeId);
            if (dragNodeId === dropNode.id || isParent) {
              return;
            }
            if (dragState.dropType) {
              let result2 = handlerDropData(dragNodeId, dropNode.id, dragState.dropType);
              result2 = formatBasicTree(result2);
              data.value = result2;
            }
          }
        } catch (e) {
          console.error(e);
        }
        clearDragDropInfo();
      }
    };
    const onDragend = (event) => {
      event.preventDefault();
      event.stopPropagation();
      clearDragDropInfo();
    };
    return {
      onDragstart,
      onDragover,
      onDragleave,
      onDrop: onDrop2,
      onDragend
    };
  };
}
function useLazyLoad() {
  return function useLazyLoadFn(data, core, context) {
    const { getNode, setNodeValue, getIndex, getChildren } = core;
    const setCommonParent = (node, nodes) => {
      nodes.value.forEach((item) => {
        if (item.level - 1 === node.level && !item.parentId) {
          item.parentId = node.id;
        }
      });
    };
    const insertChildrenNodes = (parent, nodes) => {
      const parentIndex = getIndex(parent);
      if (parentIndex !== -1) {
        data.value.splice(parentIndex + 1, 0, ...nodes.value);
      }
    };
    const dealChildNodes = (result2) => {
      const node = getNode(result2.node);
      setNodeValue(node, "loading", false);
      const childNodes = ref(generateInnerTree(result2.treeItems, "children", node.level));
      setCommonParent(node, childNodes);
      insertChildrenNodes(node, childNodes);
      const childrenNodes = getChildren(node);
      setNodeValue(node, "childNodeCount", childrenNodes.length);
    };
    const lazyLoadNodes = (node) => {
      const innerNode = getNode(node);
      if (!innerNode.isLeaf && !innerNode.childNodeCount) {
        setNodeValue(node, "loading", true);
        context.emit("lazy-load", node, dealChildNodes);
      }
    };
    return {
      lazyLoadNodes
    };
  };
}
function useOperate() {
  return function useOperateFn(data, core) {
    const { setNodeValue, getChildren, getIndex, getLevel, getParent } = core;
    const insertBefore = (parentNode, node, referenceNode) => {
      const children = getChildren(parentNode, {
        recursive: false
      });
      const lastChild = children[children.length - 1];
      let insertedIndex = getIndex(parentNode) + 1;
      if (referenceNode) {
        insertedIndex = getIndex(referenceNode);
      } else if (lastChild) {
        insertedIndex = getIndex(lastChild) + 1;
      }
      setNodeValue(parentNode, "expanded", true);
      setNodeValue(parentNode, "isLeaf", false);
      if (lastChild) {
        setNodeValue(lastChild, "parentChildNodeCount", children.length + 1);
      }
      const currentNode = ref(__spreadProps(__spreadValues({}, node), {
        level: getLevel(parentNode) + 1,
        parentId: parentNode.id,
        isLeaf: true,
        parentChildNodeCount: children.length + 1,
        currentIndex: lastChild && typeof lastChild.currentIndex === "number" ? lastChild.currentIndex + 1 : 0
      }));
      if (currentNode.value.id === void 0) {
        currentNode.value.id = randomId();
      }
      data.value = data.value.slice(0, insertedIndex).concat(currentNode.value, data.value.slice(insertedIndex, data.value.length));
    };
    const removeNode = (node, config = { recursive: true }) => {
      if (!config.recursive) {
        getChildren(node).forEach((child) => {
          setNodeValue(child, "level", getLevel(child) - 1);
        });
      }
      data.value = data.value.filter((item) => {
        if (config.recursive) {
          return item.id !== node.id && !getChildren(node).map((nodeItem) => nodeItem.id).includes(item.id);
        } else {
          return item.id !== node.id;
        }
      });
      if (getParent(node) && getChildren(getParent(node)).length === 0) {
        setNodeValue(getParent(node), "isLeaf", true);
      }
    };
    const editNode = (node, label) => {
      setNodeValue(node, "label", label);
    };
    return {
      insertBefore,
      removeNode,
      editNode
    };
  };
}
function useMergeNodes() {
  return function useMergeNodesFn(data, core) {
    const { setNodeValue, getChildren } = core;
    const { removeNode } = useOperate()(data, core);
    const mergeTreeNodes = () => {
      const mergeToNode = (node) => {
        var _a;
        if (node.isLeaf) {
          return;
        }
        const children = getChildren(node, { recursive: false });
        if ((children == null ? void 0 : children.length) === 1) {
          const subChildren = getChildren(children[0], { recursive: false });
          if (subChildren.length !== 0) {
            setNodeValue(node, "label", node.label + " / " + ((_a = children[0]) == null ? void 0 : _a.label));
            removeNode(children[0], { recursive: false });
            mergeToNode(node);
          } else {
            setNodeValue(children[0], "parentId", node.id);
          }
        } else {
          children.forEach((item) => {
            mergeToNode(item);
          });
        }
      };
      data.value.filter((item) => item.level === 1).forEach((item) => {
        mergeToNode(item);
      });
    };
    return {
      mergeTreeNodes
    };
  };
}
function useSearchFilter() {
  return function useSearchFilterFn(data, core) {
    const { clearNodeMap, getExpendedTree } = core;
    const virtualListRef = ref();
    const resetNodeSearchProperty = () => {
      data.value.forEach((item) => {
        item.childrenMatched = false;
        item.isHide = false;
        item.isMatched = false;
        item.matchedText = "";
      });
      if (virtualListRef.value) {
        virtualListRef.value.scrollTo(0);
      }
    };
    const hasDealParentNode = (pre, cur, parentIdSet) => {
      return data.value[pre].parentId === data.value[cur].parentId && data.value[pre].isMatched || parentIdSet.has(data.value[pre].id) && data.value[pre].childrenMatched;
    };
    const dealMatchedData = (target, matchKey, pattern4) => {
      const trimmedTarget = lodash.exports.trim(target).toLocaleLowerCase();
      for (let i = 0; i < data.value.length; i++) {
        const key = matchKey ? data.value[i][matchKey] : data.value[i].label;
        const selfMatched = pattern4 ? pattern4.test(key) : key.toLocaleLowerCase().includes(trimmedTarget);
        data.value[i].isMatched = selfMatched;
        if (selfMatched) {
          data.value[i].matchedText = matchKey ? data.value[i].label : trimmedTarget;
          if (!data.value[i].parentId) {
            continue;
          }
          let L = i - 1;
          const set = /* @__PURE__ */ new Set();
          set.add(data.value[i].parentId);
          while (L >= 0 && data.value[L].parentId && !hasDealParentNode(L, i, set)) {
            if (set.has(data.value[L].id)) {
              data.value[L].childrenMatched = true;
              data.value[L].expanded = true;
              set.add(data.value[L].parentId);
            }
            L--;
          }
          if (L >= 0 && !data.value[L].parentId && set.has(data.value[L].id)) {
            data.value[L].childrenMatched = true;
            data.value[L].expanded = true;
          }
        }
      }
    };
    const hasParentNodeMatched = (pre, cur, parentIdSet) => {
      return parentIdSet.has(data.value[pre].id) && data.value[pre].isMatched;
    };
    const dealNodeHideProperty = () => {
      data.value.forEach((item, index2) => {
        if (item.isMatched || item.childrenMatched) {
          item.isHide = false;
        } else {
          if (!item.parentId) {
            item.isHide = true;
            return;
          }
          let L = index2 - 1;
          const set = /* @__PURE__ */ new Set();
          set.add(data.value[index2].parentId);
          while (L >= 0 && data.value[L].parentId && !hasParentNodeMatched(L, index2, set)) {
            if (set.has(data.value[L].id)) {
              set.add(data.value[L].parentId);
            }
            L--;
          }
          if (!data.value[L].parentId && !data.value[L].isMatched) {
            item.isHide = true;
          } else {
            item.isHide = false;
          }
        }
      });
    };
    const getFirstMatchIndex = () => {
      let index2 = 0;
      const showTreeData = getExpendedTree().value;
      while (index2 <= showTreeData.length - 1 && !showTreeData[index2].isMatched) {
        index2++;
      }
      return index2 >= showTreeData.length ? 0 : index2;
    };
    const searchTree = (target, option2) => {
      clearNodeMap();
      resetNodeSearchProperty();
      if (!target) {
        return;
      }
      dealMatchedData(target, option2.matchKey, option2.pattern);
      if (option2.isFilter) {
        dealNodeHideProperty();
      }
      if (virtualListRef.value) {
        const scrollIndex = getFirstMatchIndex();
        virtualListRef.value.scrollTo(scrollIndex);
      }
    };
    return {
      virtualListRef,
      searchTree
    };
  };
}
function useSelect$1() {
  return function useSelectFn(data, core, context) {
    const { setNodeValue } = core;
    const { getInitSelectedNodes, clearInitSelectedNodes } = useInitSelectCollection();
    let prevActiveNode;
    const selectNode = (node) => {
      if (node.disableSelect) {
        return;
      }
      const initSelectedNodes = getInitSelectedNodes();
      if (initSelectedNodes.length) {
        initSelectedNodes.forEach((item) => {
          setNodeValue(item, "selected", false);
        });
        clearInitSelectedNodes();
      }
      if (prevActiveNode) {
        const prevActiveNodeIndex = data.value.findIndex((item) => item.id === prevActiveNode.id);
        setNodeValue(data.value[prevActiveNodeIndex], "selected", false);
      }
      setNodeValue(node, "selected", true);
      context.emit("select-change", node);
      prevActiveNode = node;
    };
    const deselectNode = (node) => {
      setNodeValue(node, "selected", false);
      context.emit("select-change", node);
    };
    const toggleSelectNode = (node) => {
      if (node.selected) {
        deselectNode(node);
      } else {
        selectNode(node);
      }
    };
    const getSelectedNode = () => {
      return data.value.find((node) => node.selected);
    };
    return {
      selectNode,
      deselectNode,
      toggleSelectNode,
      getSelectedNode
    };
  };
}
function useToggle$1() {
  return function useToggleFn(data, core, context, lazyLode) {
    const { getNode, setNodeValue } = core;
    const { lazyLoadNodes } = lazyLode;
    const expandNode = (node) => {
      if (node.disableToggle || node.loading) {
        return;
      }
      setNodeValue(node, "expanded", true);
      context.emit("toggle-change", node);
    };
    const collapseNode = (node) => {
      if (node.disableToggle || node.loading) {
        return;
      }
      setNodeValue(node, "expanded", false);
      context.emit("toggle-change", node);
    };
    const toggleNode = (node) => {
      if (node.disableToggle || node.loading) {
        return;
      }
      if (getNode(node).expanded) {
        collapseNode(node);
      } else {
        expandNode(node);
      }
      lazyLoadNodes(node);
    };
    const expandAllNodes = () => {
      data.value.forEach((node) => {
        expandNode(node);
      });
    };
    return {
      expandNode,
      collapseNode,
      toggleNode,
      expandAllNodes
    };
  };
}
const DEFAULT_TREE_PLUGINS = [useToggle$1()];
function useTree(tree2, plugins = [], context) {
  const treeData = ref(generateInnerTree(tree2));
  const core = useCore()(treeData);
  const lazyLode = useLazyLoad()(treeData, core, context);
  const pluginMethods = DEFAULT_TREE_PLUGINS.concat(plugins).reduce((acc, plugin) => {
    return __spreadValues(__spreadValues({}, acc), plugin(treeData, core, context, lazyLode));
  }, {});
  return __spreadValues(__spreadValues({
    treeData
  }, pluginMethods), core);
}
const ns = useNamespace("tree");
function useTreeNode(data) {
  const nodeClass = computed(() => {
    var _a;
    return [ns.e("node"), ((_a = data.value) == null ? void 0 : _a.expanded) && ns.em("node", "open")];
  });
  const nodeStyle = computed(() => {
    var _a;
    return { paddingLeft: `${NODE_INDENT * (((_a = data.value) == null ? void 0 : _a.level) - 1)}px` };
  });
  const nodeVLineClass = computed(() => {
    var _a;
    return [((_a = data.value) == null ? void 0 : _a.level) !== 1 && ns.e("node-vline")];
  });
  const nodeVLineStyles = computed(() => {
    if (!data.value || data.value.level === 1) {
      return [];
    }
    const { currentIndex = 0, parentChildNodeCount = 0, level, expanded, isLeaf } = data.value;
    return Array.from({ length: data.value.level - 1 }).map((_, index2) => ({
      height: `${currentIndex + 1 === parentChildNodeCount && index2 === 0 ? isLeaf || !expanded ? NODE_HEIGHT / 2 : NODE_HEIGHT : NODE_HEIGHT}px`,
      left: `${NODE_INDENT * (level - index2 - 2) + 9}px`,
      top: `0px`
    }));
  });
  const nodeHLineClass = computed(() => {
    var _a;
    return [((_a = data.value) == null ? void 0 : _a.level) !== 1 && ns.e("node-hline")];
  });
  const nodeContentClass = computed(() => {
    var _a;
    return [ns.e("node-content"), ((_a = data.value) == null ? void 0 : _a.selected) && "active"];
  });
  const nodeTitleClass = computed(() => {
    var _a;
    return [ns.e("node-title"), ((_a = data.value) == null ? void 0 : _a.disableSelect) && "select-disabled"];
  });
  const nodeOperationAreaClass = computed(() => ns.e("node-operation-area"));
  const matchedContents = computed(() => {
    var _a, _b;
    const matchItem = ((_a = data.value) == null ? void 0 : _a.matchedText) || "";
    const label = ((_b = data.value) == null ? void 0 : _b.label) || "";
    const reg = (str) => str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    const regExp = new RegExp("(" + reg(matchItem) + ")", "gi");
    return label.split(regExp);
  });
  const highlightCls = ns.e("match-highlight");
  return {
    nodeClass,
    nodeStyle,
    nodeContentClass,
    nodeTitleClass,
    nodeVLineClass,
    nodeVLineStyles,
    nodeHLineClass,
    nodeOperationAreaClass,
    matchedContents,
    highlightCls
  };
}
var DTreeNodeToggle = defineComponent({
  name: "DTreeNodeToggle",
  props: {
    data: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const {
      data
    } = toRefs(props);
    const {
      toggleNode
    } = inject(USE_TREE_TOKEN);
    const ns2 = useNamespace("tree");
    return () => {
      var _a;
      return createVNode("span", {
        "class": [ns2.e("node-folder"), ((_a = data.value) == null ? void 0 : _a.disableToggle) && "toggle-disabled"],
        "onClick": (event) => {
          event.stopPropagation();
          if (toggleNode) {
            toggleNode(data.value);
          }
        }
      }, [data.value.isLeaf ? createVNode("span", {
        "class": ns2.e("node-indent")
      }, null) : data.value.expanded ? createVNode(IconOpen$1, {
        "class": "mr-xs"
      }, null) : createVNode(IconClose$1, {
        "class": "mr-xs"
      }, null)]);
    };
  }
});
var DTreeNodeLoading = defineComponent({
  name: "DTreeNodeLoading",
  setup() {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTree", app);
    const ns2 = useNamespace("loading-children ");
    return () => {
      return createVNode("span", {
        "class": ns2.b()
      }, [`${t("loading") || "Loading"}...`]);
    };
  }
});
var DTreeNodeContent = defineComponent({
  name: "DTreeNodeContent",
  props: {
    data: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const {
      data
    } = toRefs(props);
    const {
      nodeTitleClass,
      matchedContents,
      highlightCls
    } = useTreeNode(data);
    return () => {
      var _a, _b, _c;
      return createVNode("span", {
        "class": nodeTitleClass.value
      }, [!((_a = data.value) == null ? void 0 : _a.matchedText) && ((_b = data.value) == null ? void 0 : _b.label), ((_c = data.value) == null ? void 0 : _c.matchedText) && matchedContents.value.map((item, index2) => index2 % 2 === 0 ? item : createVNode("span", {
        "class": highlightCls
      }, [item]))]);
    };
  }
});
var DTreeNode = defineComponent({
  name: "DTreeNode",
  props: treeNodeProps,
  setup(props, {
    slots
  }) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTree", app);
    const {
      data,
      check,
      dragdrop,
      operate
    } = toRefs(props);
    const {
      toggleSelectNode,
      toggleCheckNode,
      toggleNode,
      getChildren,
      insertBefore,
      removeNode,
      getNode,
      onDragstart,
      onDragover,
      onDragleave,
      onDrop: onDrop2,
      onDragend
    } = inject(USE_TREE_TOKEN);
    const treeInstance = inject(TREE_INSTANCE);
    const ns2 = useNamespace("tree");
    const {
      nodeClass,
      nodeStyle,
      nodeContentClass,
      nodeVLineClass,
      nodeVLineStyles,
      nodeHLineClass,
      nodeOperationAreaClass
    } = useTreeNode(data);
    const halfChecked = computed(() => {
      var _a;
      if (!((_a = data.value) == null ? void 0 : _a.checked)) {
        return false;
      }
      const checkFormat = formatCheckStatus(check.value);
      if (["upward", "both"].includes(checkFormat)) {
        const children = (getChildren == null ? void 0 : getChildren(data.value)) || [];
        const checkedChildren = children == null ? void 0 : children.filter((item) => item.checked);
        return checkedChildren.length > 0 && checkedChildren.length < children.length;
      } else {
        return false;
      }
    });
    const checkboxProps2 = computed(() => {
      var _a, _b, _c;
      return {
        key: (_a = data.value) == null ? void 0 : _a.id,
        disabled: (_b = data.value) == null ? void 0 : _b.disableCheck,
        halfChecked: halfChecked.value,
        modelValue: (_c = data.value) == null ? void 0 : _c.checked,
        "onUpdate:modelValue": () => {
          toggleCheckNode == null ? void 0 : toggleCheckNode(data.value);
        },
        onClick: (event) => {
          event.stopPropagation();
        }
      };
    });
    const isShowOperationArea = ref(false);
    const showOperationArea = () => {
      isShowOperationArea.value = true;
    };
    const hideOperationArea = () => {
      isShowOperationArea.value = false;
    };
    return () => {
      var _a, _b;
      let dragdropProps = {};
      if (dragdrop.value && !((_a = data.value) == null ? void 0 : _a.disableSelect)) {
        dragdropProps = {
          draggable: true,
          onDragstart: (event) => onDragstart == null ? void 0 : onDragstart(event, data.value),
          onDragover: (event) => onDragover == null ? void 0 : onDragover(event),
          onDragleave: (event) => onDragleave == null ? void 0 : onDragleave(event),
          onDrop: (event) => onDrop2 == null ? void 0 : onDrop2(event, data.value),
          onDragend: (event) => onDragend == null ? void 0 : onDragend(event)
        };
      }
      return createVNode("div", {
        "class": nodeClass.value,
        "style": nodeStyle.value,
        "onMouseenter": showOperationArea,
        "onMouseleave": hideOperationArea
      }, [nodeVLineStyles.value.map((item) => createVNode("span", {
        "class": nodeVLineClass.value,
        "style": item
      }, null)), createVNode("span", {
        "class": nodeHLineClass.value,
        "style": omit(nodeVLineStyles.value[0], ["height", "top"])
      }, null), createVNode("div", mergeProps({
        "class": nodeContentClass.value,
        "onClick": () => {
          toggleSelectNode == null ? void 0 : toggleSelectNode(data.value);
          treeInstance == null ? void 0 : treeInstance.emit("node-click", data.value);
        }
      }, dragdropProps), [slots.icon ? renderSlot(useSlots(), "icon", {
        nodeData: data,
        toggleNode
      }) : createVNode(DTreeNodeToggle, {
        "data": data.value
      }, null), createVNode("div", {
        "class": ns2.em("node-content", "value-wrapper"),
        "style": {
          height: `${NODE_HEIGHT}px`
        }
      }, [check.value && createVNode(Checkbox, checkboxProps2.value, null), slots.default ? renderSlot(useSlots(), "default", {
        nodeData: data
      }) : createVNode(DTreeNodeContent, {
        "data": data.value
      }, null), ((_b = getNode == null ? void 0 : getNode(data.value)) == null ? void 0 : _b.loading) ? slots.loading ? renderSlot(useSlots(), "loading") : createVNode(DTreeNodeLoading, null, null) : "", dragdrop.value && createVNode(Fragment, null, [createVNode("div", {
        "class": ns2.em("node", "drop-top")
      }, null), createVNode("div", {
        "class": ns2.em("node", "drop-bottom")
      }, null), createVNode("div", {
        "class": ns2.em("node", "drop-left")
      }, null), createVNode("div", {
        "class": ns2.em("node", "drop-right")
      }, null)])]), operate.value && isShowOperationArea.value && createVNode("div", {
        "class": nodeOperationAreaClass.value
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "add",
        "onClick": () => {
          insertBefore == null ? void 0 : insertBefore(data.value, {
            label: t("newNode") || "New node"
          });
        }
      }, null), createVNode(resolveComponent("d-icon"), {
        "name": "delete",
        "onClick": () => {
          removeNode == null ? void 0 : removeNode(data.value);
        }
      }, null)])])]);
    };
  }
});
var tree = "";
var Tree = defineComponent({
  name: "DTree",
  props: treeProps,
  emits: ["toggle-change", "check-change", "select-change", "node-click", "lazy-load"],
  setup(props, context) {
    const {
      slots,
      expose
    } = context;
    const treeInstance = getCurrentInstance();
    const {
      check,
      dragdrop,
      operate
    } = toRefs(props);
    const ns2 = useNamespace("tree");
    const normalRef = ref();
    const data = ref(formatBasicTree(props.data));
    const userPlugins = [useSelect$1(), useOperate(), useMergeNodes(), useSearchFilter()];
    const checkOptions = ref({
      checkStrategy: formatCheckStatus(check.value)
    });
    if (check.value) {
      userPlugins.push(useCheck(checkOptions));
    }
    if (dragdrop.value) {
      userPlugins.push(useDragdrop(props, data));
    }
    const treeFactory = useTree(data.value, userPlugins, context);
    const {
      setTree,
      getExpendedTree,
      toggleNode,
      virtualListRef
    } = treeFactory;
    watch(data, setTree);
    watch(() => props.data, (newVal) => {
      data.value = formatBasicTree(newVal);
    });
    watch(check, (newVal) => {
      checkOptions.value.checkStrategy = formatCheckStatus(newVal);
    });
    provide(USE_TREE_TOKEN, treeFactory);
    provide(TREE_INSTANCE, treeInstance);
    expose({
      treeFactory
    });
    const renderDTreeNode = (treeNode) => slots.default ? renderSlot(useSlots(), "default", {
      treeFactory,
      nodeData: treeNode
    }) : createVNode(DTreeNode, {
      "data": treeNode,
      "check": check.value,
      "dragdrop": dragdrop.value,
      "operate": operate.value,
      "key": treeNode.id
    }, {
      default: () => slots.content ? renderSlot(useSlots(), "content", {
        nodeData: treeNode
      }) : createVNode(DTreeNodeContent, {
        "data": treeNode
      }, null),
      icon: () => slots.icon ? renderSlot(useSlots(), "icon", {
        nodeData: treeNode,
        toggleNode
      }) : createVNode(DTreeNodeToggle, {
        "data": treeNode
      }, null),
      loading: () => slots.loading ? renderSlot(useSlots(), "loading", {
        nodeData: treeNode
      }) : createVNode(DTreeNodeLoading, null, null)
    });
    return () => {
      const treeData = getExpendedTree == null ? void 0 : getExpendedTree().value;
      const vSlotsProps = {
        item: (treeNode) => renderDTreeNode(treeNode)
      };
      let virtualListProps2 = {};
      if (props.height) {
        virtualListProps2 = {
          height: props.height,
          data: treeData,
          itemHeight: NODE_HEIGHT
        };
      }
      return props.height ? createVNode(VirtualList, mergeProps({
        "ref": virtualListRef,
        "class": ns2.b()
      }, virtualListProps2), vSlotsProps) : createVNode("div", {
        "ref": normalRef,
        "class": ns2.b()
      }, [createVNode(TransitionGroup, {
        "name": ns2.m("list")
      }, {
        default: () => [treeData == null ? void 0 : treeData.map(renderDTreeNode)]
      })]);
    };
  }
});
var TreeInstall = {
  title: "Tree \u6811",
  category: "\u6570\u636E\u5C55\u793A",
  status: "50%",
  install(app) {
    app.component(Tree.name, Tree);
  }
};
var treeSelect = "";
const treeSelectProps = {
  modelValue: {
    type: [String, Number, Array],
    default: ""
  },
  treeData: {
    type: Array,
    default: () => []
  },
  placeholder: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: false
  },
  multiple: {
    type: Boolean,
    default: false
  },
  leafOnly: {
    type: Boolean,
    default: false
  },
  searchable: {
    type: Boolean,
    default: false
  },
  allowClear: {
    type: Boolean,
    default: false
  },
  enableLabelization: {
    type: Boolean,
    default: false
  },
  onToggleChange: {
    type: Function,
    default: void 0
  },
  onValueChange: {
    type: Function,
    default: void 0
  }
};
const nodeMap = /* @__PURE__ */ new Map();
function attributeExtension(data) {
  data.forEach((el) => {
    let level = 1;
    el.level = level;
    nodeMap.set(el.label, el);
    const nodeQueue = [];
    nodeQueue.push(el);
    while (nodeQueue.length !== 0) {
      const node = nodeQueue.shift();
      if (node.children) {
        node.children.forEach((el2) => {
          el2.level = level + 1;
          el2.parent = node;
          nodeMap.set(el2.label, el2);
          nodeQueue.push(el2);
        });
      }
      level += 1;
    }
  });
  return data;
}
function className(classStr, classOpt) {
  let classname = classStr;
  if (typeof classOpt === "object") {
    Object.keys(classOpt).forEach((key) => {
      classOpt[key] && (classname += ` ${key}`);
    });
  }
  return classname;
}
function useToggle(props) {
  const visible = ref(false);
  const selectToggle = () => {
    if (props.disabled) {
      return;
    }
    visible.value = !visible.value;
  };
  const treeToggle = (e, item) => {
    e.preventDefault();
    e.stopPropagation();
    item.opened = !item.opened;
  };
  return {
    visible,
    selectToggle,
    treeToggle
  };
}
function useSelect(props) {
  const inputValue = ref([]);
  const selectedCache = /* @__PURE__ */ new Set();
  const selectValue = (item) => {
    if (!props.multiple) {
      inputValue.value = item.label;
    } else {
      item.checked = !item.checked;
      if (item.halfchecked) {
        item.halfchecked = false;
      }
      useCache(item);
      searchUp(item);
      searchDown(item);
      inputValue.value = [...selectedCache];
    }
  };
  const useCache = (item) => {
    item.checked === true ? selectedCache.add(item.label) : selectedCache.has(item.label) && selectedCache.delete(item.label);
  };
  const searchUp = (item) => {
    if (!item.parent) {
      return;
    }
    let state = "";
    const checkedArr = item.parent.children.filter((el) => el.checked === true);
    switch (checkedArr.length) {
      case 0:
        state = "none";
        break;
      case item.parent.children.length:
        state = "checked";
        break;
      default:
        state = "halfchecked";
        break;
    }
    if (state === "checked") {
      item.parent.checked = true;
      item.parent.halfchecked = false;
    } else if (state === "halfchecked") {
      item.parent.halfchecked = true;
      item.parent.checked = false;
    } else {
      item.parent.checked = false;
      item.parent.halfchecked = false;
    }
    useCache(item.parent);
    searchUp(item.parent);
  };
  const searchDown = (item) => {
    if (!item.children) {
      return;
    }
    item.children.forEach((el) => {
      el.checked = item.checked;
      useCache(el);
      searchDown(el);
    });
  };
  return {
    inputValue,
    selectValue
  };
}
function useClear(props, ctx2, data) {
  const isClearable = computed(() => {
    return !props.disabled && props.allowClear;
  });
  const handleClearAll = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (props.multiple) {
      ctx2.emit("update:modelValue", []);
      data.value = [];
    } else {
      ctx2.emit("update:modelValue", "");
      data.value = "";
    }
  };
  const handleClearItem = (e, item) => {
    e.preventDefault();
    e.stopPropagation();
    if (props.multiple) {
      data.value.splice(data.value.indexOf(item), 1);
      ctx2.emit("update:modelValue", data.value);
    } else {
      ctx2.emit("update:modelValue", []);
      data.value = [];
    }
  };
  return {
    isClearable,
    handleClearAll,
    handleClearItem
  };
}
var IconOpen = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "class": "svg-icon svg-icon-close"
}, [createVNode("g", {
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("rect", {
  "x": "0.5",
  "y": "0.5",
  "width": "15",
  "height": "15",
  "rx": "2",
  "stroke": "#5e7ce0"
}, null), createVNode("rect", {
  "x": "4",
  "y": "7",
  "width": "8",
  "height": "2",
  "fill": "#5e7ce0"
}, null)])]);
var IconClose = () => createVNode("svg", {
  "width": "16px",
  "height": "16px",
  "viewBox": "0 0 16 16",
  "version": "1.1",
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "class": "svg-icon"
}, [createVNode("g", {
  "stroke": "none",
  "stroke-width": "1",
  "fill": "none",
  "fill-rule": "evenodd"
}, [createVNode("rect", {
  "x": "0.5",
  "y": "0.5",
  "width": "15",
  "height": "15",
  "rx": "2",
  "stroke": "#252b3a"
}, null), createVNode("path", {
  "fill": "#252b3a",
  "d": "M8.75,4 L8.75,7.25 L12,7.25 L12,8.75 L8.749,8.75 L8.75,12 L7.25,12 L7.249,8.75 L4,8.75 L4,7.25 L7.25,7.25 L7.25,4 L8.75,4 Z"
}, null)])]);
var TreeSelect = defineComponent({
  name: "DTreeSelect",
  directives: {
    ClickOutside: clickoutsideDirective
  },
  props: treeSelectProps,
  emits: ["toggleChange", "valueChange", "update:modelValue"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DTree", app);
    const {
      treeData,
      placeholder,
      disabled,
      multiple,
      leafOnly,
      enableLabelization
    } = toRefs(props);
    const {
      visible,
      selectToggle,
      treeToggle
    } = useToggle(props);
    const {
      inputValue,
      selectValue
    } = useSelect(props);
    const {
      isClearable,
      handleClearAll,
      handleClearItem
    } = useClear(props, ctx2, inputValue);
    const clickNode = (item) => {
      if (!leafOnly.value) {
        selectValue(item);
        !multiple.value && selectToggle(item);
      } else {
        if (!item.children) {
          selectValue(item);
          !multiple.value && selectToggle(item);
        }
      }
    };
    const deleteNode = (e, item) => {
      handleClearItem(e, item);
      selectValue(nodeMap.get(item));
    };
    const treeSelectCls = className("devui-tree-select", {
      "devui-tree-select-open": visible.value,
      "devui-tree-select-disabled": disabled.value
    });
    const treeSelectInputItem = className("devui-tree-select-value", {
      "devui-tree-select-value-enableLabelization": enableLabelization.value
    });
    const renderNode = (item) => createVNode("div", {
      "class": "devui-tree-select-item",
      "style": {
        paddingLeft: `${20 * (item.level - 1)}px`
      },
      "onClick": () => clickNode(item)
    }, [item.children ? item.opened ? createVNode(IconOpen, {
      "class": "mr-xs",
      "onClick": (e) => treeToggle(e, item)
    }, null) : createVNode(IconClose, {
      "class": "mr-xs",
      "onClick": (e) => treeToggle(e, item)
    }, null) : createVNode("span", null, ["\xA0\xA0\xA0"]), ctx2.slots.default ? ctx2.slots.default({
      item
    }) : multiple.value ? item.halfchecked ? createVNode(Checkbox, {
      "label": item.label,
      "halfchecked": item.halfchecked
    }, null) : createVNode(Checkbox, {
      "label": item.label,
      "checked": item.checked
    }, null) : item.label]);
    const renderTree = (treeData2) => {
      return treeData2.map((item) => {
        if (item.children) {
          return createVNode(Fragment, null, [renderNode(item), item.opened && renderTree(item.children)]);
        }
        return renderNode(item);
      });
    };
    return () => {
      return withDirectives(createVNode("div", {
        "class": treeSelectCls
      }, [createVNode("div", {
        "class": isClearable.value ? "devui-tree-select-clearable" : "devui-tree-select-notclearable",
        "onClick": () => selectToggle()
      }, [createVNode("div", {
        "class": "devui-tree-select-input",
        "placeholder": placeholder.value || t("selectPlaceholder")
      }, [multiple.value ? inputValue.value.map((item) => createVNode("div", {
        "class": treeSelectInputItem
      }, [item, enableLabelization.value ? createVNode(resolveComponent("d-icon"), {
        "name": "close",
        "onClick": (e) => deleteNode(e, item)
      }, null) : createVNode("span", null, [createTextVNode(",")])])) : !Array.isArray(inputValue.value) && createVNode("div", {
        "class": treeSelectInputItem
      }, [inputValue.value, enableLabelization.value && createVNode(resolveComponent("d-icon"), {
        "name": "close",
        "onClick": (e) => handleClearItem(e)
      }, null)])]), createVNode("span", {
        "onClick": (e) => handleClearAll(e),
        "class": "devui-tree-select-clear"
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "close"
      }, null)]), createVNode("span", {
        "class": "devui-tree-select-arrow"
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "select-arrow"
      }, null)])]), createVNode(Transition, {
        "name": "fade",
        "ref": "dropdownRef"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "devui-tree-select-dropdown"
        }, [createVNode("ul", {
          "class": "devui-tree-select-dropdown-list"
        }, [renderTree(attributeExtension(treeData.value))])]), [[vShow, visible.value]])]
      })]), [[resolveDirective("click-outside"), () => visible.value = false]]);
    };
  }
});
TreeSelect.install = function(app) {
  app.component(TreeSelect.name, TreeSelect);
};
var TreeSelectInstall = {
  title: "TreeSelect \u6811\u5F62\u9009\u62E9\u6846",
  category: "\u6570\u636E\u5F55\u5165",
  status: "20%",
  install(app) {
    app.use(TreeSelect);
  }
};
var UploadStatus = /* @__PURE__ */ ((UploadStatus2) => {
  UploadStatus2[UploadStatus2["preLoad"] = 0] = "preLoad";
  UploadStatus2[UploadStatus2["uploading"] = 1] = "uploading";
  UploadStatus2[UploadStatus2["uploaded"] = 2] = "uploaded";
  UploadStatus2[UploadStatus2["failed"] = 3] = "failed";
  return UploadStatus2;
})(UploadStatus || {});
const uploadProps = {
  accept: {
    type: String
  },
  webkitdirectory: {
    type: Boolean,
    default: false
  },
  uploadOptions: {
    type: Object
  },
  multiple: {
    type: Boolean,
    default: false
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  placeholder: {
    type: String,
    default: ""
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  droppable: {
    type: Boolean,
    default: false
  },
  beforeUpload: {
    type: Function
  },
  dynamicUploadOptionsFn: {
    type: Function
  },
  disabled: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function
  },
  fileDrop: {
    type: Function,
    default: void 0
  },
  fileOver: {
    type: Function,
    default: void 0
  },
  fileSelect: {
    type: Function,
    default: void 0
  },
  deleteUploadedFile: {
    type: Function,
    default: void 0
  },
  onError: {
    type: Function,
    default: void 0
  },
  onSuccess: {
    type: Function,
    default: void 0
  },
  onExceed: {
    type: Function,
    default: void 0
  },
  onProgress: {
    type: Function,
    default: void 0
  },
  onPreview: {
    type: Function,
    default: void 0
  },
  oneTimeUpload: {
    type: Boolean,
    default: false
  },
  limit: {
    type: Number,
    default: 0
  },
  httpRequest: {
    type: Function,
    default: void 0
  }
};
const useSelectFiles = (t) => {
  const BEYOND_MAXIMAL_FILE_SIZE_MSG = ref("");
  const simulateClickEvent = (input2) => {
    const evt = document.createEvent("MouseEvents");
    evt.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
    input2.dispatchEvent(evt);
  };
  const selectFiles = ({ multiple, accept, webkitdirectory }) => {
    return new Promise((resolve) => {
      const tempNode = document.getElementById("d-upload-temp");
      if (tempNode) {
        document.body.removeChild(tempNode);
      }
      const input2 = document.createElement("input");
      input2.style.position = "fixed";
      input2.style.left = "-2000px";
      input2.style.top = "-2000px";
      input2.setAttribute("id", "d-upload-temp");
      input2.setAttribute("type", "file");
      if (multiple) {
        input2.setAttribute("multiple", "");
      }
      if (accept) {
        input2.setAttribute("accept", accept);
      }
      if (webkitdirectory) {
        input2.setAttribute("webkitdirectory", "");
      }
      input2.addEventListener("change", (event) => {
        resolve(Array.prototype.slice.call(event.target.files));
      });
      document.body.appendChild(input2);
      simulateClickEvent(input2);
    });
  };
  const isAllowedFileType = (accept, file) => {
    if (accept) {
      const acceptArr = accept.split(",");
      const baseMimeType = file.type.replace(/\/.*$/, "");
      return acceptArr.some((type4) => {
        const validType = type4.trim();
        if (validType.startsWith(".")) {
          return file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.toLowerCase().length - validType.toLowerCase().length) > -1;
        } else if (/\/\*$/.test(validType)) {
          return baseMimeType === validType.replace(/\/.*$/, "");
        }
        return file.type === validType;
      });
    }
    return true;
  };
  const beyondMaximalSize = (fileSize, maximumSize) => {
    if (maximumSize) {
      return fileSize > 1024 * 1024 * maximumSize;
    }
    return false;
  };
  const _validateFiles = (file, accept, uploadOptions) => {
    if (!isAllowedFileType(accept, file)) {
      return {
        checkError: true,
        errorMsg: t("getNotAllowedFileTypeMsg")(file.name, accept)
      };
    }
    if (uploadOptions && beyondMaximalSize(file.size, uploadOptions.maximumSize)) {
      return {
        checkError: true,
        errorMsg: t("getBeyondMaximalFileSizeMsg")(file.name, uploadOptions.maximumSize || 0)
      };
    }
    return { checkError: false, errorMsg: void 0 };
  };
  const triggerSelectFiles = (fileOptions) => {
    const { multiple, accept, webkitdirectory } = fileOptions;
    return selectFiles({ multiple, accept, webkitdirectory });
  };
  const triggerDropFiles = (files) => {
    return Promise.resolve(files);
  };
  const checkAllFilesSize = (fileSize, maximumSize) => {
    if (beyondMaximalSize(fileSize, maximumSize)) {
      BEYOND_MAXIMAL_FILE_SIZE_MSG.value = t("getAllFilesBeyondMaximalFileSizeMsg")(maximumSize);
      return { checkError: true, errorMsg: BEYOND_MAXIMAL_FILE_SIZE_MSG.value };
    }
  };
  return {
    triggerSelectFiles,
    _validateFiles,
    triggerDropFiles,
    checkAllFilesSize
  };
};
class FileUploader {
  constructor(file, uploadOptions) {
    __publicField(this, "xhr");
    __publicField(this, "status");
    __publicField(this, "response");
    __publicField(this, "percentage", 0);
    this.file = file;
    this.uploadOptions = uploadOptions;
    this.file = file;
    this.uploadOptions = uploadOptions;
    this.status = UploadStatus.preLoad;
  }
  send(uploadFiles) {
    return new Promise((resolve, reject) => {
      const { uri, method: method4, headers, authToken, authTokenHeader, additionalParameter, fileFieldName, withCredentials, responseType } = this.uploadOptions || {};
      const authTokenHeader_ = authTokenHeader || "Authorization";
      const fileFieldName_ = fileFieldName || "file";
      this.xhr = new XMLHttpRequest();
      this.xhr.open(method4 || "POST", uri || "");
      if (withCredentials) {
        this.xhr.withCredentials = withCredentials;
      }
      if (responseType) {
        this.xhr.responseType = responseType;
      }
      if (authToken) {
        this.xhr.setRequestHeader(authTokenHeader_, authToken);
      }
      if (headers) {
        Object.keys(headers).forEach((key) => {
          var _a;
          (_a = this.xhr) == null ? void 0 : _a.setRequestHeader(key, headers[key]);
        });
      }
      this.xhr.upload.onprogress = (e) => {
        this.percentage = Math.round(e.loaded * 100 / e.total);
      };
      const formData = uploadFiles && uploadFiles.length ? this.oneTimeUploadFiles(fileFieldName_, additionalParameter, uploadFiles) : this.parallelUploadFiles(fileFieldName_, additionalParameter);
      this.xhr.send(formData);
      this.status = UploadStatus.uploading;
      this.xhr.onabort = () => {
        this.status = UploadStatus.preLoad;
        this.xhr = null;
      };
      this.xhr.onerror = () => {
        var _a, _b;
        this.response = (_a = this.xhr) == null ? void 0 : _a.response;
        this.status = UploadStatus.failed;
        reject({ file: this.file, response: (_b = this.xhr) == null ? void 0 : _b.response });
      };
      this.xhr.onload = () => {
        var _a, _b, _c;
        if (((_a = this.xhr) == null ? void 0 : _a.readyState) === 4 && this.xhr.status >= 200 && this.xhr.status < 300) {
          this.response = this.xhr.response;
          this.status = UploadStatus.uploaded;
          resolve({ file: this.file, response: this.xhr.response });
        } else {
          this.response = (_b = this.xhr) == null ? void 0 : _b.response;
          this.status = UploadStatus.failed;
          reject({ file: this.file, response: (_c = this.xhr) == null ? void 0 : _c.response });
        }
      };
    });
  }
  parallelUploadFiles(fileFieldName_, additionalParameter) {
    const formData = new FormData();
    formData.append(fileFieldName_, this.file, this.file.name);
    if (additionalParameter) {
      Object.keys(additionalParameter).forEach((key) => {
        formData.append(key, additionalParameter[key]);
      });
    }
    return formData;
  }
  oneTimeUploadFiles(fileFieldName_, additionalParameter, uploadFiles) {
    const formData = new FormData();
    uploadFiles.forEach((element) => {
      formData.append(fileFieldName_, element.file, element.file.name);
      if (additionalParameter) {
        Object.keys(additionalParameter).forEach((key) => {
          formData.append(key, additionalParameter[key]);
        });
      }
    });
    return formData;
  }
  cancel() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }
}
const useUpload = () => {
  const fileUploaders = ref([]);
  const filesWithSameName = ref([]);
  const checkFileSame = (fileName) => {
    let checkRel = true;
    for (let i = 0; i < fileUploaders.value.length; i++) {
      if (fileName === fileUploaders.value[i].file.name) {
        checkRel = false;
        if (filesWithSameName.value.indexOf(fileName) === -1) {
          filesWithSameName.value.push(fileName);
        }
        break;
      }
    }
    return checkRel;
  };
  const addFile = (file, options) => {
    if (options && options.checkSameName) {
      if (checkFileSame(file.name)) {
        fileUploaders.value.push(new FileUploader(file, options));
      }
    } else {
      fileUploaders.value.push(new FileUploader(file, options));
    }
  };
  const getFiles = () => {
    return fileUploaders.value.map((fileUploader) => {
      return fileUploader.file;
    });
  };
  const getFullFiles = () => {
    return fileUploaders.value.map((fileUploader) => {
      return fileUploader;
    });
  };
  const dealOneTimeUploadFiles = async (uploads) => {
    if (!uploads || !uploads.length) {
      return Promise.reject("no files");
    }
    let finalUploads = [];
    await uploads[0].send(uploads).finally(() => finalUploads = uploads.map((file) => {
      file.status = uploads[0].status;
      file.percentage = uploads[0].percentage;
      return { file: file.file, response: uploads[0].response };
    }));
    return finalUploads;
  };
  const upload2 = async (oneFile) => {
    let uploads = [];
    if (oneFile) {
      oneFile.percentage = 0;
      const uploadedFile = await oneFile.send();
      uploads.push(uploadedFile);
    } else {
      const preFiles = fileUploaders.value.filter((fileUploader) => fileUploader.status === UploadStatus.preLoad);
      const failedFiles = fileUploaders.value.filter((fileUploader) => fileUploader.status === UploadStatus.failed);
      const uploadFiles = preFiles.length > 0 ? preFiles : failedFiles;
      uploads = await Promise.all(uploadFiles.map(async (fileUploader) => {
        fileUploader.percentage = 0;
        const uploadedFile = await fileUploader.send();
        return uploadedFile;
      }));
    }
    if (uploads.length > 0) {
      return Promise.resolve(uploads);
    }
    return Promise.reject("no files");
  };
  const _oneTimeUpload = () => {
    const uploads = fileUploaders.value.filter((fileUploader) => fileUploader.status !== UploadStatus.uploaded);
    return dealOneTimeUploadFiles(uploads);
  };
  const deleteFile = (file) => {
    const deleteUploadFile = fileUploaders.value.find((fileUploader) => fileUploader.file === file);
    deleteUploadFile == null ? void 0 : deleteUploadFile.cancel();
    fileUploaders.value = fileUploaders.value.filter((fileUploader) => {
      return file !== fileUploader.file;
    });
  };
  const removeFiles = () => {
    fileUploaders.value = [];
    filesWithSameName.value = [];
  };
  const getSameNameFiles = () => {
    return filesWithSameName.value.join();
  };
  const resetSameNameFiles = () => {
    filesWithSameName.value = [];
  };
  return {
    fileUploaders,
    getFiles,
    addFile,
    getFullFiles,
    deleteFile,
    upload: upload2,
    removeFiles,
    getSameNameFiles,
    resetSameNameFiles,
    _oneTimeUpload
  };
};
var upload = "";
var Upload = defineComponent({
  name: "DUpload",
  props: uploadProps,
  emits: ["fileDrop", "fileOver", "fileSelect", "deleteUploadedFile", "update:modelValue"],
  setup(props, ctx2) {
    const app = getCurrentInstance();
    const t = createI18nTranslate("DUpload", app);
    const {
      uploadOptions,
      placeholder,
      autoUpload,
      disabled,
      beforeUpload,
      droppable,
      oneTimeUpload,
      modelValue,
      multiple,
      accept,
      webkitdirectory,
      limit,
      httpRequest
    } = toRefs(props);
    const ns2 = useNamespace("upload");
    const inputGroupNs = useNamespace("input-group");
    const formControlNs = useNamespace("form-control");
    const inputGroupAddOnNs = useNamespace("input-group-addon");
    const {
      triggerSelectFiles,
      _validateFiles,
      triggerDropFiles,
      checkAllFilesSize
    } = useSelectFiles(t);
    const {
      fileUploaders,
      addFile,
      getFullFiles,
      deleteFile,
      upload: upload2,
      resetSameNameFiles,
      removeFiles,
      _oneTimeUpload,
      getSameNameFiles
    } = useUpload();
    const isDropOver = ref(false);
    const selectedFiles = ref([]);
    const alertMsg = (errorMsg) => {
      NotificationService.open({
        type: "warning",
        content: errorMsg
      });
    };
    const checkValid = () => {
      var _a;
      let totalFileSize = 0;
      fileUploaders.value.forEach((fileUploader) => {
        totalFileSize += fileUploader.file.size;
        const checkResult = _validateFiles(fileUploader.file, (accept == null ? void 0 : accept.value) || "", fileUploader.uploadOptions);
        if (checkResult && checkResult.checkError) {
          deleteFile(fileUploader.file);
          alertMsg(checkResult.errorMsg);
          return;
        }
      });
      if (oneTimeUpload.value) {
        const checkResult = checkAllFilesSize(totalFileSize, ((_a = uploadOptions == null ? void 0 : uploadOptions.value) == null ? void 0 : _a.maximumSize) || 0);
        if (checkResult && checkResult.checkError) {
          removeFiles();
          alertMsg(checkResult.errorMsg);
        }
      }
    };
    const onFileOver = (event) => {
      isDropOver.value = event;
      ctx2.emit("fileOver", event);
    };
    const deleteUploadedFile = (file) => {
      const newUploadedFiles = modelValue.value.filter((uploadedFile) => {
        return uploadedFile.name !== file.name;
      });
      ctx2.emit("deleteUploadedFile", file);
      ctx2.emit("update:modelValue", newUploadedFiles);
    };
    const onDeleteFile = (event, file, status2) => {
      event == null ? void 0 : event.stopPropagation();
      if (status2 === UploadStatus.uploaded) {
        deleteUploadedFile(file);
      }
      deleteFile(file);
    };
    const canUpload = () => {
      let uploadResult = Promise.resolve(true);
      if (beforeUpload == null ? void 0 : beforeUpload.value) {
        const result2 = beforeUpload == null ? void 0 : beforeUpload.value(getFullFiles());
        if (typeof result2 !== "undefined") {
          if (typeof result2 === "boolean") {
            uploadResult = Promise.resolve(result2);
          } else {
            uploadResult = result2;
          }
        }
      }
      return uploadResult;
    };
    const fileUpload = (event, fileUploader) => {
      if (event) {
        event.stopPropagation();
      }
      canUpload().then((_canUpload) => {
        if (!_canUpload) {
          removeFiles();
          return;
        }
        if (typeof (httpRequest == null ? void 0 : httpRequest.value) === "function") {
          const files = fileUploaders.value.map((tempFileUploader) => tempFileUploader.file);
          httpRequest.value(files);
          return;
        }
        const uploadObservable = oneTimeUpload.value ? _oneTimeUpload() : upload2(fileUploader);
        props.onProgress && props.onProgress(selectedFiles.value, modelValue.value);
        uploadObservable == null ? void 0 : uploadObservable.then((results2) => {
          props.onSuccess && props.onSuccess(results2);
          const newFiles = results2.map((result2) => result2.file);
          const newUploadedFiles = [...newFiles, ...modelValue.value];
          ctx2.emit("update:modelValue", newUploadedFiles);
          props.onChange && props.onChange(newFiles, newUploadedFiles);
        }).catch((error2) => {
          props.onError && props.onError(error2);
          props.onChange && props.onChange([error2.file], modelValue.value);
        });
      });
    };
    const _dealFiles = (promise) => {
      resetSameNameFiles();
      promise.then((files) => {
        if (limit.value && modelValue.value.length + files.length > limit.value) {
          props.onExceed && props.onExceed(files, modelValue.value);
          return;
        }
        props.onChange && props.onChange(files, modelValue.value);
        files.forEach((file) => {
          if (!multiple.value) {
            removeFiles();
          }
          addFile(file, uploadOptions == null ? void 0 : uploadOptions.value);
        });
        checkValid();
        const sameNameFiles = getSameNameFiles();
        if ((uploadOptions == null ? void 0 : uploadOptions.value) && uploadOptions.value.checkSameName && sameNameFiles.length) {
          alertMsg(t("getExistSameNameFilesMsg")(sameNameFiles));
        }
        selectedFiles.value = fileUploaders.value.filter((fileUploader) => fileUploader.status === UploadStatus.preLoad).map((fileUploader) => fileUploader.file);
        ctx2.emit("fileSelect", selectedFiles.value);
        if (autoUpload.value) {
          fileUpload();
        }
      }).catch((error2) => {
        alertMsg(error2.message);
      });
    };
    const handleClick = () => {
      if (disabled.value) {
        return;
      }
      _dealFiles(triggerSelectFiles({
        accept: accept == null ? void 0 : accept.value,
        multiple: multiple.value,
        webkitdirectory: webkitdirectory.value
      }));
    };
    const onFileDrop = (files) => {
      isDropOver.value = false;
      _dealFiles(triggerDropFiles(files));
      ctx2.emit("fileDrop", files);
    };
    const submit = (event, fileUploader) => {
      fileUpload(event, fileUploader);
    };
    const clearFiles = (event) => {
      fileUploaders.value.forEach((fileUploader) => {
        onDeleteFile(event, fileUploader.file, fileUploader.status);
      });
    };
    const clickSelectedFile = (event, file) => {
      event == null ? void 0 : event.stopPropagation();
      props.onPreview && props.onPreview(file);
    };
    ctx2.expose({
      submit,
      clearFiles
    });
    return () => {
      var _a, _b, _c, _d;
      return createVNode("div", null, [withDirectives(createVNode("div", {
        "class": ns2.b(),
        "style": `border: ${isDropOver.value ? "1px solid #15bf15" : "0"}`
      }, [((_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a)) ? createVNode("div", {
        "onClick": handleClick
      }, [ctx2.slots.default()]) : createVNode("div", {
        "class": [inputGroupNs.b(), disabled.value ? "disabled" : ""],
        "onClick": handleClick
      }, [fileUploaders.value.length === 0 && createVNode("div", {
        "class": [formControlNs.b(), ns2.e("placeholder")]
      }, [placeholder.value || t("placeholder")]), fileUploaders.value.length > 0 && createVNode("ul", {
        "class": [formControlNs.b(), ns2.e("files-list")]
      }, [fileUploaders.value.map((fileUploader, index2) => createVNode("li", {
        "key": index2,
        "class": [ns2.e("file-item"), ns2.e("file-tag")],
        "style": "display: inline-block;",
        "title": fileUploader.file.name,
        "onClick": (event) => clickSelectedFile(event, fileUploader.file)
      }, [createVNode("span", {
        "class": [ns2.e("filename"), fileUploader.status === UploadStatus.failed ? ns2.m("failed-color") : ""]
      }, [fileUploader.file.name]), createVNode(resolveComponent("d-icon"), {
        "name": "close",
        "class": [(fileUploader == null ? void 0 : fileUploader.status) === UploadStatus.failed ? ns2.e("delete-file-button") : "", (fileUploader == null ? void 0 : fileUploader.status) === UploadStatus.uploading || (fileUploader == null ? void 0 : fileUploader.status) === UploadStatus.uploaded ? ns2.e("delete") : ""],
        "onClick": (event) => onDeleteFile(event, fileUploader.file, fileUploader.status)
      }, null), fileUploader.status === UploadStatus.uploading && createVNode("div", {
        "class": ["icon", ns2.e("progress")]
      }, [createVNode(resolveComponent("d-progress"), {
        "isCircle": true,
        "percentage": fileUploader.percentage,
        "barbgcolor": "#50D4AB",
        "strokeWidth": 8,
        "showContent": false
      }, null)]), fileUploader.status === UploadStatus.failed && createVNode(resolveComponent("d-icon"), {
        "name": "running",
        "onClick": fileUpload
      }, null), fileUploader.status === UploadStatus.uploaded && createVNode(resolveComponent("d-icon"), {
        "name": "right",
        "color": "#50d4ab"
      }, null)]))]), createVNode("span", {
        "class": inputGroupAddOnNs.b()
      }, [createVNode(resolveComponent("d-icon"), {
        "name": "more-operate",
        "color": "#252b3a"
      }, null)])])]), [[resolveDirective("file-drop"), {
        droppable,
        isSingle: !multiple,
        onFileDrop,
        onFileOver
      }]]), createVNode("div", null, [(_d = (_c = ctx2.slots)["uploaded-files"]) == null ? void 0 : _d.call(_c, {
        uploadedFiles: modelValue.value,
        deleteFile: deleteUploadedFile
      })])]);
    };
  }
});
const getTransfer = (event) => {
  var _a;
  return event.dataTransfer ? event.dataTransfer : (_a = event.originalEvent) == null ? void 0 : _a.dataTransfer;
};
const haveFiles = (types2) => {
  if (!types2) {
    return false;
  }
  if (types2.indexOf) {
    return types2.indexOf("Files") !== -1;
  } else if (types2.contains) {
    return types2.contains("Files");
  } else {
    return false;
  }
};
const preventAndStop = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
const onDragOver = (el, binding) => {
  const { onFileOver } = binding.value;
  el.addEventListener("dragover", (event) => {
    const transfer2 = getTransfer(event);
    if (!haveFiles(transfer2.types)) {
      return;
    }
    preventAndStop(event);
    onFileOver && onFileOver(true);
  });
};
const onDragLeave = (el, binding) => {
  const { onFileOver } = binding.value;
  el.addEventListener("dragleave", (event) => {
    if (event.currentTarget === el) {
      return;
    }
    preventAndStop(event);
    onFileOver && onFileOver(true);
  });
};
const onDrop = (el, binding) => {
  const { onFileDrop, isSingle } = binding.value;
  el.addEventListener("drop", (event) => {
    const transfer2 = getTransfer(event);
    if (!transfer2) {
      return;
    }
    preventAndStop(event);
    if (isSingle) {
      onFileDrop && onFileDrop([transfer2.files[0]]);
    } else {
      onFileDrop && onFileDrop(Array.from(transfer2.files));
    }
  });
};
const fileDropDirective = {
  mounted: (el, binding) => {
    const { droppable } = binding.value;
    if (!droppable) {
      return;
    }
    onDragOver(el, binding);
    onDragLeave(el, binding);
    onDrop(el, binding);
  }
};
var UploadInstall = {
  title: "Upload \u4E0A\u4F20",
  category: "\u6570\u636E\u5F55\u5165",
  status: "100%",
  install(app) {
    app.directive("file-drop", fileDropDirective);
    app.component(Upload.name, Upload);
  }
};
var devui = "";
const installs = [
  AccordionInstall,
  AlertInstall,
  AnchorInstall,
  AutoCompleteInstall,
  AvatarInstall,
  BackTopInstall,
  BadgeInstall,
  BreadcrumbInstall,
  ButtonInstall,
  CardInstall,
  CarouselInstall,
  CascaderInstall,
  CheckboxInstall,
  CollapseInstall,
  ColorPickerInstall,
  CommentInstall,
  CountdownInstall,
  DatePickerInstall,
  DatePickerProInstall,
  DragdropInstall,
  DrawerInstall,
  DropdownInstall,
  EditableSelectInstall,
  FormInstall,
  FullscreenInstall,
  GanttInstall,
  GridInstall,
  IconInstall,
  ImagePreviewInstall,
  InputInstall,
  InputIconInstall,
  InputNumberInstall,
  LayoutInstall,
  ListInstall,
  LoadingInstall,
  MentionInstall,
  MenuInstall,
  MessageInstall,
  ModalInstall,
  MultiAutoCompleteInstall,
  NavSpriteInstall,
  NotificationInstall,
  OverlayInstall,
  PaginationInstall,
  PanelInstall,
  PopoverInstall,
  ProgressInstall,
  QuadrantDiagramInstall,
  RadioInstall,
  RateInstall,
  ReadTipInstall,
  ResultInstall,
  RippleInstall,
  SearchInstall,
  SelectInstall,
  SkeletonInstall,
  SliderInstall,
  SplitterInstall,
  StatisticInstall,
  StatusInstall,
  StepsInstall,
  StepsGuideInstall,
  StickyInstall,
  SwitchInstall,
  TableInstall,
  TabsInstall,
  TagInstall,
  TagInputInstall,
  TextareaInstall,
  TimePickerInstall,
  TimeSelectInstall,
  TimelineInstall,
  TooltipInstall,
  TransferInstall,
  TreeInstall,
  TreeSelectInstall,
  UploadInstall,
  VirtualListInstall
];
var vueDevui = {
  version: "1.5.3",
  install(app) {
    installs.forEach((p) => app.use(p));
  }
};
export { Accordion, Alert, Anchor, Aside, AutoComplete, Avatar, BackTop, Badge, Breadcrumb, DButton as Button, ButtonGroup, Card, Carousel, CarouselItem, Cascader, Checkbox, CheckboxButton, DCheckboxGroup as CheckboxGroup, Col, Collapse, CollapseItem, ColorPicker, Column, Comment, Content, Countdown, DRangeDatePickerPro, DatePicker, DatePickerPro, DraggableDirective, Drawer, DrawerService, Dropdown$1 as Dropdown, DropdownMenu, DroppableDirective, EditableSelect, FixedOverlay, FlexibleOverlay, Footer$1 as Footer, Form, FormItem, FormOperation, Fullscreen, Gantt, Header$1 as Header, DIcon as Icon, IconGroup, ImagePreviewDirective, ImagePreviewService, DInput as Input, InputIcon, InputNumber, Layout, List, ListItem, LoadingDirective, loading as LoadingService, Mention, Menu, MenuItem, Message, Modal, MultiAutoComplete, NavSprite, Notification, NotificationService, Option, OptionGroup, Pagination, Panel, PanelBody, PanelFooter, PanelHeader, Popover, Progress, QuadrantDiagram, Radio, RadioButton, RadioGroup, Rate, ReadTip, Result, RippleDirective, Row, DSearch as Search, Select, Skeleton, SkeletonItem, Slider, SortableDirective, Splitter, Statistic, Status, Step, Steps, StepsGuide, StepsGuideDirective, StickSlider, Sticky, SubMenu, Switch, Tab, Table, Tabs, Tag, TagInput, Textarea, TimePicker, TimeSelect, Timeline, TimelineItem, Tooltip, Transfer, Tree, TreeSelect, Upload, VirtualList, vueDevui as default };
